ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.syntax unified
  15              		.file	"queue.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.comm	xQueueRegistry,80,4
  20              		.section	.text.xQueueGenericReset,"ax",%progbits
  21              		.align	2
  22              		.global	xQueueGenericReset
  23              		.thumb
  24              		.thumb_func
  25              		.type	xQueueGenericReset, %function
  26              	xQueueGenericReset:
  27              	.LFB64:
  28              		.file 1 "FreeRTOS\\queue.c"
   1:FreeRTOS/queue.c **** /*
   2:FreeRTOS/queue.c ****     FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
   3:FreeRTOS/queue.c ****     All rights reserved
   4:FreeRTOS/queue.c **** 
   5:FreeRTOS/queue.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:FreeRTOS/queue.c **** 
   7:FreeRTOS/queue.c ****     This file is part of the FreeRTOS distribution.
   8:FreeRTOS/queue.c **** 
   9:FreeRTOS/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:FreeRTOS/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  11:FreeRTOS/queue.c ****     Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
  12:FreeRTOS/queue.c **** 
  13:FreeRTOS/queue.c ****     ***************************************************************************
  14:FreeRTOS/queue.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:FreeRTOS/queue.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:FreeRTOS/queue.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:FreeRTOS/queue.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:FreeRTOS/queue.c ****     ***************************************************************************
  19:FreeRTOS/queue.c **** 
  20:FreeRTOS/queue.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:FreeRTOS/queue.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:FreeRTOS/queue.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:FreeRTOS/queue.c ****     link: http://www.freertos.org/a00114.html
  24:FreeRTOS/queue.c **** 
  25:FreeRTOS/queue.c ****     ***************************************************************************
  26:FreeRTOS/queue.c ****      *                                                                       *
  27:FreeRTOS/queue.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:FreeRTOS/queue.c ****      *    robust, strictly quality controlled, supported, and cross          *
  29:FreeRTOS/queue.c ****      *    platform software that is more than just the market leader, it     *
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 2


  30:FreeRTOS/queue.c ****      *    is the industry's de facto standard.                               *
  31:FreeRTOS/queue.c ****      *                                                                       *
  32:FreeRTOS/queue.c ****      *    Help yourself get started quickly while simultaneously helping     *
  33:FreeRTOS/queue.c ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:FreeRTOS/queue.c ****      *    tutorial book, reference manual, or both:                          *
  35:FreeRTOS/queue.c ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:FreeRTOS/queue.c ****      *                                                                       *
  37:FreeRTOS/queue.c ****     ***************************************************************************
  38:FreeRTOS/queue.c **** 
  39:FreeRTOS/queue.c ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:FreeRTOS/queue.c ****     the FAQ page "My application does not run, what could be wrong?".  Have you
  41:FreeRTOS/queue.c ****     defined configASSERT()?
  42:FreeRTOS/queue.c **** 
  43:FreeRTOS/queue.c ****     http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:FreeRTOS/queue.c ****     embedded software for free we request you assist our global community by
  45:FreeRTOS/queue.c ****     participating in the support forum.
  46:FreeRTOS/queue.c **** 
  47:FreeRTOS/queue.c ****     http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:FreeRTOS/queue.c ****     be as productive as possible as early as possible.  Now you can receive
  49:FreeRTOS/queue.c ****     FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:FreeRTOS/queue.c ****     Ltd, and the world's leading authority on the world's leading RTOS.
  51:FreeRTOS/queue.c **** 
  52:FreeRTOS/queue.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:FreeRTOS/queue.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:FreeRTOS/queue.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  55:FreeRTOS/queue.c **** 
  56:FreeRTOS/queue.c ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:FreeRTOS/queue.c ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
  58:FreeRTOS/queue.c **** 
  59:FreeRTOS/queue.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:FreeRTOS/queue.c ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:FreeRTOS/queue.c ****     licenses offer ticketed support, indemnification and commercial middleware.
  62:FreeRTOS/queue.c **** 
  63:FreeRTOS/queue.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:FreeRTOS/queue.c ****     engineered and independently SIL3 certified version for use in safety and
  65:FreeRTOS/queue.c ****     mission critical applications that require provable dependability.
  66:FreeRTOS/queue.c **** 
  67:FreeRTOS/queue.c ****     1 tab == 4 spaces!
  68:FreeRTOS/queue.c **** */
  69:FreeRTOS/queue.c **** 
  70:FreeRTOS/queue.c **** #include <stdlib.h>
  71:FreeRTOS/queue.c **** #include <string.h>
  72:FreeRTOS/queue.c **** 
  73:FreeRTOS/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  74:FreeRTOS/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  75:FreeRTOS/queue.c **** task.h is included from an application file. */
  76:FreeRTOS/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  77:FreeRTOS/queue.c **** 
  78:FreeRTOS/queue.c **** #include "FreeRTOS.h"
  79:FreeRTOS/queue.c **** #include "task.h"
  80:FreeRTOS/queue.c **** #include "queue.h"
  81:FreeRTOS/queue.c **** 
  82:FreeRTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  83:FreeRTOS/queue.c **** 	#include "croutine.h"
  84:FreeRTOS/queue.c **** #endif
  85:FreeRTOS/queue.c **** 
  86:FreeRTOS/queue.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 3


  87:FreeRTOS/queue.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  88:FreeRTOS/queue.c **** header files above, but not in this file, in order to generate the correct
  89:FreeRTOS/queue.c **** privileged Vs unprivileged linkage and placement. */
  90:FreeRTOS/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  91:FreeRTOS/queue.c **** 
  92:FreeRTOS/queue.c **** 
  93:FreeRTOS/queue.c **** /* Constants used with the xRxLock and xTxLock structure members. */
  94:FreeRTOS/queue.c **** #define queueUNLOCKED					( ( BaseType_t ) -1 )
  95:FreeRTOS/queue.c **** #define queueLOCKED_UNMODIFIED			( ( BaseType_t ) 0 )
  96:FreeRTOS/queue.c **** 
  97:FreeRTOS/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  98:FreeRTOS/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  99:FreeRTOS/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
 100:FreeRTOS/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
 101:FreeRTOS/queue.c **** pcTail pointer actually points to the mutex holder (if any).  Map alternative
 102:FreeRTOS/queue.c **** names to the pcHead and pcTail structure members to ensure the readability of
 103:FreeRTOS/queue.c **** the code is maintained despite this dual use of two structure members.  An
 104:FreeRTOS/queue.c **** alternative implementation would be to use a union, but use of a union is
 105:FreeRTOS/queue.c **** against the coding standard (although an exception to the standard has been
 106:FreeRTOS/queue.c **** permitted where the dual use also significantly changes the type of the
 107:FreeRTOS/queue.c **** structure member). */
 108:FreeRTOS/queue.c **** #define pxMutexHolder					pcTail
 109:FreeRTOS/queue.c **** #define uxQueueType						pcHead
 110:FreeRTOS/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
 111:FreeRTOS/queue.c **** 
 112:FreeRTOS/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
 113:FreeRTOS/queue.c **** zero. */
 114:FreeRTOS/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
 115:FreeRTOS/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
 116:FreeRTOS/queue.c **** 
 117:FreeRTOS/queue.c **** #if( configUSE_PREEMPTION == 0 )
 118:FreeRTOS/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 119:FreeRTOS/queue.c **** 	performed just because a higher priority task has been woken. */
 120:FreeRTOS/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
 121:FreeRTOS/queue.c **** #else
 122:FreeRTOS/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 123:FreeRTOS/queue.c **** #endif
 124:FreeRTOS/queue.c **** 
 125:FreeRTOS/queue.c **** /*
 126:FreeRTOS/queue.c ****  * Definition of the queue used by the scheduler.
 127:FreeRTOS/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
 128:FreeRTOS/queue.c ****  * rationale: http://www.freertos.org/Embedded-RTOS-Queues.html
 129:FreeRTOS/queue.c ****  */
 130:FreeRTOS/queue.c **** typedef struct QueueDefinition
 131:FreeRTOS/queue.c **** {
 132:FreeRTOS/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
 133:FreeRTOS/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
 134:FreeRTOS/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
 135:FreeRTOS/queue.c **** 
 136:FreeRTOS/queue.c **** 	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclus
 137:FreeRTOS/queue.c **** 	{
 138:FreeRTOS/queue.c **** 		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the stru
 139:FreeRTOS/queue.c **** 		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex h
 140:FreeRTOS/queue.c **** 	} u;
 141:FreeRTOS/queue.c **** 
 142:FreeRTOS/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 143:FreeRTOS/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 4


 144:FreeRTOS/queue.c **** 
 145:FreeRTOS/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 146:FreeRTOS/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 147:FreeRTOS/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 148:FreeRTOS/queue.c **** 
 149:FreeRTOS/queue.c **** 	volatile BaseType_t xRxLock;	/*< Stores the number of items received from the queue (removed from 
 150:FreeRTOS/queue.c **** 	volatile BaseType_t xTxLock;	/*< Stores the number of items transmitted to the queue (added to the
 151:FreeRTOS/queue.c **** 
 152:FreeRTOS/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 153:FreeRTOS/queue.c **** 		UBaseType_t uxQueueNumber;
 154:FreeRTOS/queue.c **** 		uint8_t ucQueueType;
 155:FreeRTOS/queue.c **** 	#endif
 156:FreeRTOS/queue.c **** 
 157:FreeRTOS/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 158:FreeRTOS/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 159:FreeRTOS/queue.c **** 	#endif
 160:FreeRTOS/queue.c **** 
 161:FreeRTOS/queue.c **** } xQUEUE;
 162:FreeRTOS/queue.c **** 
 163:FreeRTOS/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 164:FreeRTOS/queue.c **** name below to enable the use of older kernel aware debuggers. */
 165:FreeRTOS/queue.c **** typedef xQUEUE Queue_t;
 166:FreeRTOS/queue.c **** 
 167:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 168:FreeRTOS/queue.c **** 
 169:FreeRTOS/queue.c **** /*
 170:FreeRTOS/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 171:FreeRTOS/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 172:FreeRTOS/queue.c ****  */
 173:FreeRTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 174:FreeRTOS/queue.c **** 
 175:FreeRTOS/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 176:FreeRTOS/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 177:FreeRTOS/queue.c **** 	more user friendly. */
 178:FreeRTOS/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 179:FreeRTOS/queue.c **** 	{
 180:FreeRTOS/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 181:FreeRTOS/queue.c **** 		QueueHandle_t xHandle;
 182:FreeRTOS/queue.c **** 	} xQueueRegistryItem;
 183:FreeRTOS/queue.c **** 
 184:FreeRTOS/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 185:FreeRTOS/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 186:FreeRTOS/queue.c **** 	debuggers. */
 187:FreeRTOS/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 188:FreeRTOS/queue.c **** 
 189:FreeRTOS/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 190:FreeRTOS/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 191:FreeRTOS/queue.c **** 	array position being vacant. */
 192:FreeRTOS/queue.c **** 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 193:FreeRTOS/queue.c **** 
 194:FreeRTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 195:FreeRTOS/queue.c **** 
 196:FreeRTOS/queue.c **** /*
 197:FreeRTOS/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 198:FreeRTOS/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 199:FreeRTOS/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 200:FreeRTOS/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 5


 201:FreeRTOS/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 202:FreeRTOS/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 203:FreeRTOS/queue.c ****  */
 204:FreeRTOS/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 205:FreeRTOS/queue.c **** 
 206:FreeRTOS/queue.c **** /*
 207:FreeRTOS/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 208:FreeRTOS/queue.c ****  *
 209:FreeRTOS/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 210:FreeRTOS/queue.c ****  */
 211:FreeRTOS/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 212:FreeRTOS/queue.c **** 
 213:FreeRTOS/queue.c **** /*
 214:FreeRTOS/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 215:FreeRTOS/queue.c ****  *
 216:FreeRTOS/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 217:FreeRTOS/queue.c ****  */
 218:FreeRTOS/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 219:FreeRTOS/queue.c **** 
 220:FreeRTOS/queue.c **** /*
 221:FreeRTOS/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 222:FreeRTOS/queue.c ****  * back of the queue.
 223:FreeRTOS/queue.c ****  */
 224:FreeRTOS/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
 225:FreeRTOS/queue.c **** 
 226:FreeRTOS/queue.c **** /*
 227:FreeRTOS/queue.c ****  * Copies an item out of a queue.
 228:FreeRTOS/queue.c ****  */
 229:FreeRTOS/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 230:FreeRTOS/queue.c **** 
 231:FreeRTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 232:FreeRTOS/queue.c **** 	/*
 233:FreeRTOS/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 234:FreeRTOS/queue.c **** 	 * the queue set that the queue contains data.
 235:FreeRTOS/queue.c **** 	 */
 236:FreeRTOS/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCop
 237:FreeRTOS/queue.c **** #endif
 238:FreeRTOS/queue.c **** 
 239:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 240:FreeRTOS/queue.c **** 
 241:FreeRTOS/queue.c **** /*
 242:FreeRTOS/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 243:FreeRTOS/queue.c ****  * accessing the queue event lists.
 244:FreeRTOS/queue.c ****  */
 245:FreeRTOS/queue.c **** #define prvLockQueue( pxQueue )								\
 246:FreeRTOS/queue.c **** 	taskENTER_CRITICAL();									\
 247:FreeRTOS/queue.c **** 	{														\
 248:FreeRTOS/queue.c **** 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
 249:FreeRTOS/queue.c **** 		{													\
 250:FreeRTOS/queue.c **** 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
 251:FreeRTOS/queue.c **** 		}													\
 252:FreeRTOS/queue.c **** 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
 253:FreeRTOS/queue.c **** 		{													\
 254:FreeRTOS/queue.c **** 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
 255:FreeRTOS/queue.c **** 		}													\
 256:FreeRTOS/queue.c **** 	}														\
 257:FreeRTOS/queue.c **** 	taskEXIT_CRITICAL()
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 6


 258:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 259:FreeRTOS/queue.c **** 
 260:FreeRTOS/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 261:FreeRTOS/queue.c **** {
  29              		.loc 1 261 0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 16
  32              		@ frame_needed = 1, uses_anonymous_args = 0
  33 0000 80B5     		push	{r7, lr}
  34              		.cfi_def_cfa_offset 8
  35              		.cfi_offset 7, -8
  36              		.cfi_offset 14, -4
  37 0002 84B0     		sub	sp, sp, #16
  38              		.cfi_def_cfa_offset 24
  39 0004 00AF     		add	r7, sp, #0
  40              		.cfi_def_cfa_register 7
  41 0006 7860     		str	r0, [r7, #4]
  42 0008 3960     		str	r1, [r7]
 262:FreeRTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  43              		.loc 1 262 0
  44 000a 7B68     		ldr	r3, [r7, #4]
  45 000c FB60     		str	r3, [r7, #12]
 263:FreeRTOS/queue.c **** 
 264:FreeRTOS/queue.c **** 	configASSERT( pxQueue );
 265:FreeRTOS/queue.c **** 
 266:FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
  46              		.loc 1 266 0
  47 000e FFF7FEFF 		bl	vPortEnterCritical
 267:FreeRTOS/queue.c **** 	{
 268:FreeRTOS/queue.c **** 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  48              		.loc 1 268 0
  49 0012 FB68     		ldr	r3, [r7, #12]
  50 0014 1A68     		ldr	r2, [r3]
  51 0016 FB68     		ldr	r3, [r7, #12]
  52 0018 DB6B     		ldr	r3, [r3, #60]
  53 001a F968     		ldr	r1, [r7, #12]
  54 001c 096C     		ldr	r1, [r1, #64]
  55 001e 01FB03F3 		mul	r3, r1, r3
  56 0022 1A44     		add	r2, r2, r3
  57 0024 FB68     		ldr	r3, [r7, #12]
  58 0026 5A60     		str	r2, [r3, #4]
 269:FreeRTOS/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  59              		.loc 1 269 0
  60 0028 FB68     		ldr	r3, [r7, #12]
  61 002a 0022     		movs	r2, #0
  62 002c 9A63     		str	r2, [r3, #56]
 270:FreeRTOS/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
  63              		.loc 1 270 0
  64 002e FB68     		ldr	r3, [r7, #12]
  65 0030 1A68     		ldr	r2, [r3]
  66 0032 FB68     		ldr	r3, [r7, #12]
  67 0034 9A60     		str	r2, [r3, #8]
 271:FreeRTOS/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue-
  68              		.loc 1 271 0
  69 0036 FB68     		ldr	r3, [r7, #12]
  70 0038 1A68     		ldr	r2, [r3]
  71 003a FB68     		ldr	r3, [r7, #12]
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 7


  72 003c DB6B     		ldr	r3, [r3, #60]
  73 003e 013B     		subs	r3, r3, #1
  74 0040 F968     		ldr	r1, [r7, #12]
  75 0042 096C     		ldr	r1, [r1, #64]
  76 0044 01FB03F3 		mul	r3, r1, r3
  77 0048 1A44     		add	r2, r2, r3
  78 004a FB68     		ldr	r3, [r7, #12]
  79 004c DA60     		str	r2, [r3, #12]
 272:FreeRTOS/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
  80              		.loc 1 272 0
  81 004e FB68     		ldr	r3, [r7, #12]
  82 0050 4FF0FF32 		mov	r2, #-1
  83 0054 5A64     		str	r2, [r3, #68]
 273:FreeRTOS/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
  84              		.loc 1 273 0
  85 0056 FB68     		ldr	r3, [r7, #12]
  86 0058 4FF0FF32 		mov	r2, #-1
  87 005c 9A64     		str	r2, [r3, #72]
 274:FreeRTOS/queue.c **** 
 275:FreeRTOS/queue.c **** 		if( xNewQueue == pdFALSE )
  88              		.loc 1 275 0
  89 005e 3B68     		ldr	r3, [r7]
  90 0060 002B     		cmp	r3, #0
  91 0062 0ED1     		bne	.L2
 276:FreeRTOS/queue.c **** 		{
 277:FreeRTOS/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 278:FreeRTOS/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 279:FreeRTOS/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 280:FreeRTOS/queue.c **** 			the queue, then one should be unblocked as after this function exits
 281:FreeRTOS/queue.c **** 			it will be possible to write to it. */
 282:FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  92              		.loc 1 282 0
  93 0064 FB68     		ldr	r3, [r7, #12]
  94 0066 1B69     		ldr	r3, [r3, #16]
  95 0068 002B     		cmp	r3, #0
  96 006a 14D0     		beq	.L3
 283:FreeRTOS/queue.c **** 			{
 284:FreeRTOS/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  97              		.loc 1 284 0
  98 006c FB68     		ldr	r3, [r7, #12]
  99 006e 1033     		adds	r3, r3, #16
 100 0070 1846     		mov	r0, r3
 101 0072 FFF7FEFF 		bl	xTaskRemoveFromEventList
 102 0076 0346     		mov	r3, r0
 103 0078 012B     		cmp	r3, #1
 104 007a 0CD1     		bne	.L3
 285:FreeRTOS/queue.c **** 				{
 286:FreeRTOS/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 105              		.loc 1 286 0
 106 007c FFF7FEFF 		bl	vPortYield
 107 0080 09E0     		b	.L3
 108              	.L2:
 287:FreeRTOS/queue.c **** 				}
 288:FreeRTOS/queue.c **** 				else
 289:FreeRTOS/queue.c **** 				{
 290:FreeRTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 291:FreeRTOS/queue.c **** 				}
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 8


 292:FreeRTOS/queue.c **** 			}
 293:FreeRTOS/queue.c **** 			else
 294:FreeRTOS/queue.c **** 			{
 295:FreeRTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 296:FreeRTOS/queue.c **** 			}
 297:FreeRTOS/queue.c **** 		}
 298:FreeRTOS/queue.c **** 		else
 299:FreeRTOS/queue.c **** 		{
 300:FreeRTOS/queue.c **** 			/* Ensure the event queues start in the correct state. */
 301:FreeRTOS/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 109              		.loc 1 301 0
 110 0082 FB68     		ldr	r3, [r7, #12]
 111 0084 1033     		adds	r3, r3, #16
 112 0086 1846     		mov	r0, r3
 113 0088 FFF7FEFF 		bl	vListInitialise
 302:FreeRTOS/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 114              		.loc 1 302 0
 115 008c FB68     		ldr	r3, [r7, #12]
 116 008e 2433     		adds	r3, r3, #36
 117 0090 1846     		mov	r0, r3
 118 0092 FFF7FEFF 		bl	vListInitialise
 119              	.L3:
 303:FreeRTOS/queue.c **** 		}
 304:FreeRTOS/queue.c **** 	}
 305:FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 120              		.loc 1 305 0
 121 0096 FFF7FEFF 		bl	vPortExitCritical
 306:FreeRTOS/queue.c **** 
 307:FreeRTOS/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 308:FreeRTOS/queue.c **** 	versions. */
 309:FreeRTOS/queue.c **** 	return pdPASS;
 122              		.loc 1 309 0
 123 009a 0123     		movs	r3, #1
 310:FreeRTOS/queue.c **** }
 124              		.loc 1 310 0
 125 009c 1846     		mov	r0, r3
 126 009e 1037     		adds	r7, r7, #16
 127              		.cfi_def_cfa_offset 8
 128 00a0 BD46     		mov	sp, r7
 129              		.cfi_def_cfa_register 13
 130              		@ sp needed
 131 00a2 80BD     		pop	{r7, pc}
 132              		.cfi_endproc
 133              	.LFE64:
 134              		.size	xQueueGenericReset, .-xQueueGenericReset
 135              		.section	.text.xQueueGenericCreate,"ax",%progbits
 136              		.align	2
 137              		.global	xQueueGenericCreate
 138              		.thumb
 139              		.thumb_func
 140              		.type	xQueueGenericCreate, %function
 141              	xQueueGenericCreate:
 142              	.LFB65:
 311:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 312:FreeRTOS/queue.c **** 
 313:FreeRTOS/queue.c **** QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, c
 314:FreeRTOS/queue.c **** {
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 9


 143              		.loc 1 314 0
 144              		.cfi_startproc
 145              		@ args = 0, pretend = 0, frame = 32
 146              		@ frame_needed = 1, uses_anonymous_args = 0
 147 0000 80B5     		push	{r7, lr}
 148              		.cfi_def_cfa_offset 8
 149              		.cfi_offset 7, -8
 150              		.cfi_offset 14, -4
 151 0002 88B0     		sub	sp, sp, #32
 152              		.cfi_def_cfa_offset 40
 153 0004 00AF     		add	r7, sp, #0
 154              		.cfi_def_cfa_register 7
 155 0006 F860     		str	r0, [r7, #12]
 156 0008 B960     		str	r1, [r7, #8]
 157 000a 1346     		mov	r3, r2
 158 000c FB71     		strb	r3, [r7, #7]
 315:FreeRTOS/queue.c **** Queue_t *pxNewQueue;
 316:FreeRTOS/queue.c **** size_t xQueueSizeInBytes;
 317:FreeRTOS/queue.c **** QueueHandle_t xReturn = NULL;
 159              		.loc 1 317 0
 160 000e 0023     		movs	r3, #0
 161 0010 BB61     		str	r3, [r7, #24]
 318:FreeRTOS/queue.c **** 
 319:FreeRTOS/queue.c **** 	/* Remove compiler warnings about unused parameters should
 320:FreeRTOS/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 321:FreeRTOS/queue.c **** 	( void ) ucQueueType;
 322:FreeRTOS/queue.c **** 
 323:FreeRTOS/queue.c **** 	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 324:FreeRTOS/queue.c **** 
 325:FreeRTOS/queue.c **** 	if( uxItemSize == ( UBaseType_t ) 0 )
 162              		.loc 1 325 0
 163 0012 BB68     		ldr	r3, [r7, #8]
 164 0014 002B     		cmp	r3, #0
 165 0016 02D1     		bne	.L6
 326:FreeRTOS/queue.c **** 	{
 327:FreeRTOS/queue.c **** 		/* There is not going to be a queue storage area. */
 328:FreeRTOS/queue.c **** 		xQueueSizeInBytes = ( size_t ) 0;
 166              		.loc 1 328 0
 167 0018 0023     		movs	r3, #0
 168 001a FB61     		str	r3, [r7, #28]
 169 001c 05E0     		b	.L7
 170              	.L6:
 329:FreeRTOS/queue.c **** 	}
 330:FreeRTOS/queue.c **** 	else
 331:FreeRTOS/queue.c **** 	{
 332:FreeRTOS/queue.c **** 		/* The queue is one byte longer than asked for to make wrap checking
 333:FreeRTOS/queue.c **** 		easier/faster. */
 334:FreeRTOS/queue.c **** 		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA 
 171              		.loc 1 334 0
 172 001e FB68     		ldr	r3, [r7, #12]
 173 0020 BA68     		ldr	r2, [r7, #8]
 174 0022 02FB03F3 		mul	r3, r2, r3
 175 0026 0133     		adds	r3, r3, #1
 176 0028 FB61     		str	r3, [r7, #28]
 177              	.L7:
 335:FreeRTOS/queue.c **** 	}
 336:FreeRTOS/queue.c **** 
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 10


 337:FreeRTOS/queue.c **** 	/* Allocate the new queue structure and storage area. */
 338:FreeRTOS/queue.c **** 	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 178              		.loc 1 338 0
 179 002a FB69     		ldr	r3, [r7, #28]
 180 002c 4C33     		adds	r3, r3, #76
 181 002e 1846     		mov	r0, r3
 182 0030 FFF7FEFF 		bl	pvPortMalloc
 183 0034 7861     		str	r0, [r7, #20]
 339:FreeRTOS/queue.c **** 
 340:FreeRTOS/queue.c **** 	if( pxNewQueue != NULL )
 184              		.loc 1 340 0
 185 0036 7B69     		ldr	r3, [r7, #20]
 186 0038 002B     		cmp	r3, #0
 187 003a 17D0     		beq	.L8
 341:FreeRTOS/queue.c **** 	{
 342:FreeRTOS/queue.c **** 		if( uxItemSize == ( UBaseType_t ) 0 )
 188              		.loc 1 342 0
 189 003c BB68     		ldr	r3, [r7, #8]
 190 003e 002B     		cmp	r3, #0
 191 0040 03D1     		bne	.L9
 343:FreeRTOS/queue.c **** 		{
 344:FreeRTOS/queue.c **** 			/* No RAM was allocated for the queue storage area, but PC head
 345:FreeRTOS/queue.c **** 			cannot be set to NULL because NULL is used as a key to say the queue
 346:FreeRTOS/queue.c **** 			is used as a mutex.  Therefore just set pcHead to point to the queue
 347:FreeRTOS/queue.c **** 			as a benign value that is known to be within the memory map. */
 348:FreeRTOS/queue.c **** 			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 192              		.loc 1 348 0
 193 0042 7B69     		ldr	r3, [r7, #20]
 194 0044 7A69     		ldr	r2, [r7, #20]
 195 0046 1A60     		str	r2, [r3]
 196 0048 04E0     		b	.L10
 197              	.L9:
 349:FreeRTOS/queue.c **** 		}
 350:FreeRTOS/queue.c **** 		else
 351:FreeRTOS/queue.c **** 		{
 352:FreeRTOS/queue.c **** 			/* Jump past the queue structure to find the location of the queue
 353:FreeRTOS/queue.c **** 			storage area. */
 354:FreeRTOS/queue.c **** 			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
 198              		.loc 1 354 0
 199 004a 7B69     		ldr	r3, [r7, #20]
 200 004c 03F14C02 		add	r2, r3, #76
 201 0050 7B69     		ldr	r3, [r7, #20]
 202 0052 1A60     		str	r2, [r3]
 203              	.L10:
 355:FreeRTOS/queue.c **** 		}
 356:FreeRTOS/queue.c **** 
 357:FreeRTOS/queue.c **** 		/* Initialise the queue members as described above where the queue type
 358:FreeRTOS/queue.c **** 		is defined. */
 359:FreeRTOS/queue.c **** 		pxNewQueue->uxLength = uxQueueLength;
 204              		.loc 1 359 0
 205 0054 7B69     		ldr	r3, [r7, #20]
 206 0056 FA68     		ldr	r2, [r7, #12]
 207 0058 DA63     		str	r2, [r3, #60]
 360:FreeRTOS/queue.c **** 		pxNewQueue->uxItemSize = uxItemSize;
 208              		.loc 1 360 0
 209 005a 7B69     		ldr	r3, [r7, #20]
 210 005c BA68     		ldr	r2, [r7, #8]
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 11


 211 005e 1A64     		str	r2, [r3, #64]
 361:FreeRTOS/queue.c **** 		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 212              		.loc 1 361 0
 213 0060 0121     		movs	r1, #1
 214 0062 7869     		ldr	r0, [r7, #20]
 215 0064 FFF7FEFF 		bl	xQueueGenericReset
 362:FreeRTOS/queue.c **** 
 363:FreeRTOS/queue.c **** 		#if ( configUSE_TRACE_FACILITY == 1 )
 364:FreeRTOS/queue.c **** 		{
 365:FreeRTOS/queue.c **** 			pxNewQueue->ucQueueType = ucQueueType;
 366:FreeRTOS/queue.c **** 		}
 367:FreeRTOS/queue.c **** 		#endif /* configUSE_TRACE_FACILITY */
 368:FreeRTOS/queue.c **** 
 369:FreeRTOS/queue.c **** 		#if( configUSE_QUEUE_SETS == 1 )
 370:FreeRTOS/queue.c **** 		{
 371:FreeRTOS/queue.c **** 			pxNewQueue->pxQueueSetContainer = NULL;
 372:FreeRTOS/queue.c **** 		}
 373:FreeRTOS/queue.c **** 		#endif /* configUSE_QUEUE_SETS */
 374:FreeRTOS/queue.c **** 
 375:FreeRTOS/queue.c **** 		traceQUEUE_CREATE( pxNewQueue );
 376:FreeRTOS/queue.c **** 		xReturn = pxNewQueue;
 216              		.loc 1 376 0
 217 0068 7B69     		ldr	r3, [r7, #20]
 218 006a BB61     		str	r3, [r7, #24]
 219              	.L8:
 377:FreeRTOS/queue.c **** 	}
 378:FreeRTOS/queue.c **** 	else
 379:FreeRTOS/queue.c **** 	{
 380:FreeRTOS/queue.c **** 		mtCOVERAGE_TEST_MARKER();
 381:FreeRTOS/queue.c **** 	}
 382:FreeRTOS/queue.c **** 
 383:FreeRTOS/queue.c **** 	configASSERT( xReturn );
 384:FreeRTOS/queue.c **** 
 385:FreeRTOS/queue.c **** 	return xReturn;
 220              		.loc 1 385 0
 221 006c BB69     		ldr	r3, [r7, #24]
 386:FreeRTOS/queue.c **** }
 222              		.loc 1 386 0
 223 006e 1846     		mov	r0, r3
 224 0070 2037     		adds	r7, r7, #32
 225              		.cfi_def_cfa_offset 8
 226 0072 BD46     		mov	sp, r7
 227              		.cfi_def_cfa_register 13
 228              		@ sp needed
 229 0074 80BD     		pop	{r7, pc}
 230              		.cfi_endproc
 231              	.LFE65:
 232              		.size	xQueueGenericCreate, .-xQueueGenericCreate
 233 0076 00BF     		.section	.text.xQueueCreateMutex,"ax",%progbits
 234              		.align	2
 235              		.global	xQueueCreateMutex
 236              		.thumb
 237              		.thumb_func
 238              		.type	xQueueCreateMutex, %function
 239              	xQueueCreateMutex:
 240              	.LFB66:
 387:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 12


 388:FreeRTOS/queue.c **** 
 389:FreeRTOS/queue.c **** #if ( configUSE_MUTEXES == 1 )
 390:FreeRTOS/queue.c **** 
 391:FreeRTOS/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 392:FreeRTOS/queue.c **** 	{
 241              		.loc 1 392 0
 242              		.cfi_startproc
 243              		@ args = 0, pretend = 0, frame = 16
 244              		@ frame_needed = 1, uses_anonymous_args = 0
 245 0000 80B5     		push	{r7, lr}
 246              		.cfi_def_cfa_offset 8
 247              		.cfi_offset 7, -8
 248              		.cfi_offset 14, -4
 249 0002 84B0     		sub	sp, sp, #16
 250              		.cfi_def_cfa_offset 24
 251 0004 00AF     		add	r7, sp, #0
 252              		.cfi_def_cfa_register 7
 253 0006 0346     		mov	r3, r0
 254 0008 FB71     		strb	r3, [r7, #7]
 393:FreeRTOS/queue.c **** 	Queue_t *pxNewQueue;
 394:FreeRTOS/queue.c **** 
 395:FreeRTOS/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 396:FreeRTOS/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 397:FreeRTOS/queue.c **** 		( void ) ucQueueType;
 398:FreeRTOS/queue.c **** 
 399:FreeRTOS/queue.c **** 		/* Allocate the new queue structure. */
 400:FreeRTOS/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
 255              		.loc 1 400 0
 256 000a 4C20     		movs	r0, #76
 257 000c FFF7FEFF 		bl	pvPortMalloc
 258 0010 F860     		str	r0, [r7, #12]
 401:FreeRTOS/queue.c **** 		if( pxNewQueue != NULL )
 259              		.loc 1 401 0
 260 0012 FB68     		ldr	r3, [r7, #12]
 261 0014 002B     		cmp	r3, #0
 262 0016 2CD0     		beq	.L13
 402:FreeRTOS/queue.c **** 		{
 403:FreeRTOS/queue.c **** 			/* Information required for priority inheritance. */
 404:FreeRTOS/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 263              		.loc 1 404 0
 264 0018 FB68     		ldr	r3, [r7, #12]
 265 001a 0022     		movs	r2, #0
 266 001c 5A60     		str	r2, [r3, #4]
 405:FreeRTOS/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 267              		.loc 1 405 0
 268 001e FB68     		ldr	r3, [r7, #12]
 269 0020 0022     		movs	r2, #0
 270 0022 1A60     		str	r2, [r3]
 406:FreeRTOS/queue.c **** 
 407:FreeRTOS/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 408:FreeRTOS/queue.c **** 			of the queue. */
 409:FreeRTOS/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 271              		.loc 1 409 0
 272 0024 FB68     		ldr	r3, [r7, #12]
 273 0026 0022     		movs	r2, #0
 274 0028 9A60     		str	r2, [r3, #8]
 410:FreeRTOS/queue.c **** 			pxNewQueue->u.pcReadFrom = NULL;
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 13


 275              		.loc 1 410 0
 276 002a FB68     		ldr	r3, [r7, #12]
 277 002c 0022     		movs	r2, #0
 278 002e DA60     		str	r2, [r3, #12]
 411:FreeRTOS/queue.c **** 
 412:FreeRTOS/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 413:FreeRTOS/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 414:FreeRTOS/queue.c **** 			of the mutex. */
 415:FreeRTOS/queue.c **** 			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 279              		.loc 1 415 0
 280 0030 FB68     		ldr	r3, [r7, #12]
 281 0032 0022     		movs	r2, #0
 282 0034 9A63     		str	r2, [r3, #56]
 416:FreeRTOS/queue.c **** 			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
 283              		.loc 1 416 0
 284 0036 FB68     		ldr	r3, [r7, #12]
 285 0038 0122     		movs	r2, #1
 286 003a DA63     		str	r2, [r3, #60]
 417:FreeRTOS/queue.c **** 			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
 287              		.loc 1 417 0
 288 003c FB68     		ldr	r3, [r7, #12]
 289 003e 0022     		movs	r2, #0
 290 0040 1A64     		str	r2, [r3, #64]
 418:FreeRTOS/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 291              		.loc 1 418 0
 292 0042 FB68     		ldr	r3, [r7, #12]
 293 0044 4FF0FF32 		mov	r2, #-1
 294 0048 5A64     		str	r2, [r3, #68]
 419:FreeRTOS/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 295              		.loc 1 419 0
 296 004a FB68     		ldr	r3, [r7, #12]
 297 004c 4FF0FF32 		mov	r2, #-1
 298 0050 9A64     		str	r2, [r3, #72]
 420:FreeRTOS/queue.c **** 
 421:FreeRTOS/queue.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 422:FreeRTOS/queue.c **** 			{
 423:FreeRTOS/queue.c **** 				pxNewQueue->ucQueueType = ucQueueType;
 424:FreeRTOS/queue.c **** 			}
 425:FreeRTOS/queue.c **** 			#endif
 426:FreeRTOS/queue.c **** 
 427:FreeRTOS/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
 428:FreeRTOS/queue.c **** 			{
 429:FreeRTOS/queue.c **** 				pxNewQueue->pxQueueSetContainer = NULL;
 430:FreeRTOS/queue.c **** 			}
 431:FreeRTOS/queue.c **** 			#endif
 432:FreeRTOS/queue.c **** 
 433:FreeRTOS/queue.c **** 			/* Ensure the event queues start with the correct state. */
 434:FreeRTOS/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 299              		.loc 1 434 0
 300 0052 FB68     		ldr	r3, [r7, #12]
 301 0054 1033     		adds	r3, r3, #16
 302 0056 1846     		mov	r0, r3
 303 0058 FFF7FEFF 		bl	vListInitialise
 435:FreeRTOS/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 304              		.loc 1 435 0
 305 005c FB68     		ldr	r3, [r7, #12]
 306 005e 2433     		adds	r3, r3, #36
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 14


 307 0060 1846     		mov	r0, r3
 308 0062 FFF7FEFF 		bl	vListInitialise
 436:FreeRTOS/queue.c **** 
 437:FreeRTOS/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 438:FreeRTOS/queue.c **** 
 439:FreeRTOS/queue.c **** 			/* Start with the semaphore in the expected state. */
 440:FreeRTOS/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 309              		.loc 1 440 0
 310 0066 0023     		movs	r3, #0
 311 0068 0022     		movs	r2, #0
 312 006a 0021     		movs	r1, #0
 313 006c F868     		ldr	r0, [r7, #12]
 314 006e FFF7FEFF 		bl	xQueueGenericSend
 315              	.L13:
 441:FreeRTOS/queue.c **** 		}
 442:FreeRTOS/queue.c **** 		else
 443:FreeRTOS/queue.c **** 		{
 444:FreeRTOS/queue.c **** 			traceCREATE_MUTEX_FAILED();
 445:FreeRTOS/queue.c **** 		}
 446:FreeRTOS/queue.c **** 
 447:FreeRTOS/queue.c **** 		return pxNewQueue;
 316              		.loc 1 447 0
 317 0072 FB68     		ldr	r3, [r7, #12]
 448:FreeRTOS/queue.c **** 	}
 318              		.loc 1 448 0
 319 0074 1846     		mov	r0, r3
 320 0076 1037     		adds	r7, r7, #16
 321              		.cfi_def_cfa_offset 8
 322 0078 BD46     		mov	sp, r7
 323              		.cfi_def_cfa_register 13
 324              		@ sp needed
 325 007a 80BD     		pop	{r7, pc}
 326              		.cfi_endproc
 327              	.LFE66:
 328              		.size	xQueueCreateMutex, .-xQueueCreateMutex
 329              		.section	.text.xQueueGiveMutexRecursive,"ax",%progbits
 330              		.align	2
 331              		.global	xQueueGiveMutexRecursive
 332              		.thumb
 333              		.thumb_func
 334              		.type	xQueueGiveMutexRecursive, %function
 335              	xQueueGiveMutexRecursive:
 336              	.LFB67:
 449:FreeRTOS/queue.c **** 
 450:FreeRTOS/queue.c **** #endif /* configUSE_MUTEXES */
 451:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 452:FreeRTOS/queue.c **** 
 453:FreeRTOS/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 454:FreeRTOS/queue.c **** 
 455:FreeRTOS/queue.c **** 	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 456:FreeRTOS/queue.c **** 	{
 457:FreeRTOS/queue.c **** 	void *pxReturn;
 458:FreeRTOS/queue.c **** 
 459:FreeRTOS/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 460:FreeRTOS/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 461:FreeRTOS/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 462:FreeRTOS/queue.c **** 		identity of the mutex holder, as the holder may change between the
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 15


 463:FreeRTOS/queue.c **** 		following critical section exiting and the function returning. */
 464:FreeRTOS/queue.c **** 		taskENTER_CRITICAL();
 465:FreeRTOS/queue.c **** 		{
 466:FreeRTOS/queue.c **** 			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 467:FreeRTOS/queue.c **** 			{
 468:FreeRTOS/queue.c **** 				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
 469:FreeRTOS/queue.c **** 			}
 470:FreeRTOS/queue.c **** 			else
 471:FreeRTOS/queue.c **** 			{
 472:FreeRTOS/queue.c **** 				pxReturn = NULL;
 473:FreeRTOS/queue.c **** 			}
 474:FreeRTOS/queue.c **** 		}
 475:FreeRTOS/queue.c **** 		taskEXIT_CRITICAL();
 476:FreeRTOS/queue.c **** 
 477:FreeRTOS/queue.c **** 		return pxReturn;
 478:FreeRTOS/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 479:FreeRTOS/queue.c **** 
 480:FreeRTOS/queue.c **** #endif
 481:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 482:FreeRTOS/queue.c **** 
 483:FreeRTOS/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 484:FreeRTOS/queue.c **** 
 485:FreeRTOS/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 486:FreeRTOS/queue.c **** 	{
 337              		.loc 1 486 0
 338              		.cfi_startproc
 339              		@ args = 0, pretend = 0, frame = 16
 340              		@ frame_needed = 1, uses_anonymous_args = 0
 341 0000 90B5     		push	{r4, r7, lr}
 342              		.cfi_def_cfa_offset 12
 343              		.cfi_offset 4, -12
 344              		.cfi_offset 7, -8
 345              		.cfi_offset 14, -4
 346 0002 85B0     		sub	sp, sp, #20
 347              		.cfi_def_cfa_offset 32
 348 0004 00AF     		add	r7, sp, #0
 349              		.cfi_def_cfa_register 7
 350 0006 7860     		str	r0, [r7, #4]
 487:FreeRTOS/queue.c **** 	BaseType_t xReturn;
 488:FreeRTOS/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 351              		.loc 1 488 0
 352 0008 7B68     		ldr	r3, [r7, #4]
 353 000a BB60     		str	r3, [r7, #8]
 489:FreeRTOS/queue.c **** 
 490:FreeRTOS/queue.c **** 		configASSERT( pxMutex );
 491:FreeRTOS/queue.c **** 
 492:FreeRTOS/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 493:FreeRTOS/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 494:FreeRTOS/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 495:FreeRTOS/queue.c **** 		this is the only condition we are interested in it does not matter if
 496:FreeRTOS/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 497:FreeRTOS/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 498:FreeRTOS/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redunda
 354              		.loc 1 498 0
 355 000c BB68     		ldr	r3, [r7, #8]
 356 000e 5C68     		ldr	r4, [r3, #4]
 357 0010 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 16


 358 0014 0346     		mov	r3, r0
 359 0016 9C42     		cmp	r4, r3
 360 0018 11D1     		bne	.L16
 499:FreeRTOS/queue.c **** 		{
 500:FreeRTOS/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 501:FreeRTOS/queue.c **** 
 502:FreeRTOS/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 503:FreeRTOS/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 504:FreeRTOS/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 505:FreeRTOS/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 506:FreeRTOS/queue.c **** 			uxRecursiveCallCount member. */
 507:FreeRTOS/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )--;
 361              		.loc 1 507 0
 362 001a BB68     		ldr	r3, [r7, #8]
 363 001c DB68     		ldr	r3, [r3, #12]
 364 001e 5A1E     		subs	r2, r3, #1
 365 0020 BB68     		ldr	r3, [r7, #8]
 366 0022 DA60     		str	r2, [r3, #12]
 508:FreeRTOS/queue.c **** 
 509:FreeRTOS/queue.c **** 			/* Have we unwound the call count? */
 510:FreeRTOS/queue.c **** 			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 367              		.loc 1 510 0
 368 0024 BB68     		ldr	r3, [r7, #8]
 369 0026 DB68     		ldr	r3, [r3, #12]
 370 0028 002B     		cmp	r3, #0
 371 002a 05D1     		bne	.L17
 511:FreeRTOS/queue.c **** 			{
 512:FreeRTOS/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 513:FreeRTOS/queue.c **** 				task that might be waiting to access the mutex. */
 514:FreeRTOS/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 372              		.loc 1 514 0
 373 002c 0023     		movs	r3, #0
 374 002e 0022     		movs	r2, #0
 375 0030 0021     		movs	r1, #0
 376 0032 B868     		ldr	r0, [r7, #8]
 377 0034 FFF7FEFF 		bl	xQueueGenericSend
 378              	.L17:
 515:FreeRTOS/queue.c **** 			}
 516:FreeRTOS/queue.c **** 			else
 517:FreeRTOS/queue.c **** 			{
 518:FreeRTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 519:FreeRTOS/queue.c **** 			}
 520:FreeRTOS/queue.c **** 
 521:FreeRTOS/queue.c **** 			xReturn = pdPASS;
 379              		.loc 1 521 0
 380 0038 0123     		movs	r3, #1
 381 003a FB60     		str	r3, [r7, #12]
 382 003c 01E0     		b	.L18
 383              	.L16:
 522:FreeRTOS/queue.c **** 		}
 523:FreeRTOS/queue.c **** 		else
 524:FreeRTOS/queue.c **** 		{
 525:FreeRTOS/queue.c **** 			/* The mutex cannot be given because the calling task is not the
 526:FreeRTOS/queue.c **** 			holder. */
 527:FreeRTOS/queue.c **** 			xReturn = pdFAIL;
 384              		.loc 1 527 0
 385 003e 0023     		movs	r3, #0
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 17


 386 0040 FB60     		str	r3, [r7, #12]
 387              	.L18:
 528:FreeRTOS/queue.c **** 
 529:FreeRTOS/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 530:FreeRTOS/queue.c **** 		}
 531:FreeRTOS/queue.c **** 
 532:FreeRTOS/queue.c **** 		return xReturn;
 388              		.loc 1 532 0
 389 0042 FB68     		ldr	r3, [r7, #12]
 533:FreeRTOS/queue.c **** 	}
 390              		.loc 1 533 0
 391 0044 1846     		mov	r0, r3
 392 0046 1437     		adds	r7, r7, #20
 393              		.cfi_def_cfa_offset 12
 394 0048 BD46     		mov	sp, r7
 395              		.cfi_def_cfa_register 13
 396              		@ sp needed
 397 004a 90BD     		pop	{r4, r7, pc}
 398              		.cfi_endproc
 399              	.LFE67:
 400              		.size	xQueueGiveMutexRecursive, .-xQueueGiveMutexRecursive
 401              		.section	.text.xQueueTakeMutexRecursive,"ax",%progbits
 402              		.align	2
 403              		.global	xQueueTakeMutexRecursive
 404              		.thumb
 405              		.thumb_func
 406              		.type	xQueueTakeMutexRecursive, %function
 407              	xQueueTakeMutexRecursive:
 408              	.LFB68:
 534:FreeRTOS/queue.c **** 
 535:FreeRTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 536:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 537:FreeRTOS/queue.c **** 
 538:FreeRTOS/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 539:FreeRTOS/queue.c **** 
 540:FreeRTOS/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 541:FreeRTOS/queue.c **** 	{
 409              		.loc 1 541 0
 410              		.cfi_startproc
 411              		@ args = 0, pretend = 0, frame = 16
 412              		@ frame_needed = 1, uses_anonymous_args = 0
 413 0000 90B5     		push	{r4, r7, lr}
 414              		.cfi_def_cfa_offset 12
 415              		.cfi_offset 4, -12
 416              		.cfi_offset 7, -8
 417              		.cfi_offset 14, -4
 418 0002 85B0     		sub	sp, sp, #20
 419              		.cfi_def_cfa_offset 32
 420 0004 00AF     		add	r7, sp, #0
 421              		.cfi_def_cfa_register 7
 422 0006 7860     		str	r0, [r7, #4]
 423 0008 3960     		str	r1, [r7]
 542:FreeRTOS/queue.c **** 	BaseType_t xReturn;
 543:FreeRTOS/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 424              		.loc 1 543 0
 425 000a 7B68     		ldr	r3, [r7, #4]
 426 000c BB60     		str	r3, [r7, #8]
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 18


 544:FreeRTOS/queue.c **** 
 545:FreeRTOS/queue.c **** 		configASSERT( pxMutex );
 546:FreeRTOS/queue.c **** 
 547:FreeRTOS/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 548:FreeRTOS/queue.c **** 		xQueueGiveMutexRecursive(). */
 549:FreeRTOS/queue.c **** 
 550:FreeRTOS/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 551:FreeRTOS/queue.c **** 
 552:FreeRTOS/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not r
 427              		.loc 1 552 0
 428 000e BB68     		ldr	r3, [r7, #8]
 429 0010 5C68     		ldr	r4, [r3, #4]
 430 0012 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 431 0016 0346     		mov	r3, r0
 432 0018 9C42     		cmp	r4, r3
 433 001a 07D1     		bne	.L21
 553:FreeRTOS/queue.c **** 		{
 554:FreeRTOS/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )++;
 434              		.loc 1 554 0
 435 001c BB68     		ldr	r3, [r7, #8]
 436 001e DB68     		ldr	r3, [r3, #12]
 437 0020 5A1C     		adds	r2, r3, #1
 438 0022 BB68     		ldr	r3, [r7, #8]
 439 0024 DA60     		str	r2, [r3, #12]
 555:FreeRTOS/queue.c **** 			xReturn = pdPASS;
 440              		.loc 1 555 0
 441 0026 0123     		movs	r3, #1
 442 0028 FB60     		str	r3, [r7, #12]
 443 002a 0EE0     		b	.L22
 444              	.L21:
 556:FreeRTOS/queue.c **** 		}
 557:FreeRTOS/queue.c **** 		else
 558:FreeRTOS/queue.c **** 		{
 559:FreeRTOS/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
 445              		.loc 1 559 0
 446 002c 0023     		movs	r3, #0
 447 002e 3A68     		ldr	r2, [r7]
 448 0030 0021     		movs	r1, #0
 449 0032 B868     		ldr	r0, [r7, #8]
 450 0034 FFF7FEFF 		bl	xQueueGenericReceive
 451 0038 F860     		str	r0, [r7, #12]
 560:FreeRTOS/queue.c **** 
 561:FreeRTOS/queue.c **** 			/* pdPASS will only be returned if the mutex was successfully
 562:FreeRTOS/queue.c **** 			obtained.  The calling task may have entered the Blocked state
 563:FreeRTOS/queue.c **** 			before reaching here. */
 564:FreeRTOS/queue.c **** 			if( xReturn == pdPASS )
 452              		.loc 1 564 0
 453 003a FB68     		ldr	r3, [r7, #12]
 454 003c 012B     		cmp	r3, #1
 455 003e 04D1     		bne	.L22
 565:FreeRTOS/queue.c **** 			{
 566:FreeRTOS/queue.c **** 				( pxMutex->u.uxRecursiveCallCount )++;
 456              		.loc 1 566 0
 457 0040 BB68     		ldr	r3, [r7, #8]
 458 0042 DB68     		ldr	r3, [r3, #12]
 459 0044 5A1C     		adds	r2, r3, #1
 460 0046 BB68     		ldr	r3, [r7, #8]
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 19


 461 0048 DA60     		str	r2, [r3, #12]
 462              	.L22:
 567:FreeRTOS/queue.c **** 			}
 568:FreeRTOS/queue.c **** 			else
 569:FreeRTOS/queue.c **** 			{
 570:FreeRTOS/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 571:FreeRTOS/queue.c **** 			}
 572:FreeRTOS/queue.c **** 		}
 573:FreeRTOS/queue.c **** 
 574:FreeRTOS/queue.c **** 		return xReturn;
 463              		.loc 1 574 0
 464 004a FB68     		ldr	r3, [r7, #12]
 575:FreeRTOS/queue.c **** 	}
 465              		.loc 1 575 0
 466 004c 1846     		mov	r0, r3
 467 004e 1437     		adds	r7, r7, #20
 468              		.cfi_def_cfa_offset 12
 469 0050 BD46     		mov	sp, r7
 470              		.cfi_def_cfa_register 13
 471              		@ sp needed
 472 0052 90BD     		pop	{r4, r7, pc}
 473              		.cfi_endproc
 474              	.LFE68:
 475              		.size	xQueueTakeMutexRecursive, .-xQueueTakeMutexRecursive
 476              		.section	.text.xQueueCreateCountingSemaphore,"ax",%progbits
 477              		.align	2
 478              		.global	xQueueCreateCountingSemaphore
 479              		.thumb
 480              		.thumb_func
 481              		.type	xQueueCreateCountingSemaphore, %function
 482              	xQueueCreateCountingSemaphore:
 483              	.LFB69:
 576:FreeRTOS/queue.c **** 
 577:FreeRTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 578:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 579:FreeRTOS/queue.c **** 
 580:FreeRTOS/queue.c **** #if ( configUSE_COUNTING_SEMAPHORES == 1 )
 581:FreeRTOS/queue.c **** 
 582:FreeRTOS/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 583:FreeRTOS/queue.c **** 	{
 484              		.loc 1 583 0
 485              		.cfi_startproc
 486              		@ args = 0, pretend = 0, frame = 16
 487              		@ frame_needed = 1, uses_anonymous_args = 0
 488 0000 80B5     		push	{r7, lr}
 489              		.cfi_def_cfa_offset 8
 490              		.cfi_offset 7, -8
 491              		.cfi_offset 14, -4
 492 0002 84B0     		sub	sp, sp, #16
 493              		.cfi_def_cfa_offset 24
 494 0004 00AF     		add	r7, sp, #0
 495              		.cfi_def_cfa_register 7
 496 0006 7860     		str	r0, [r7, #4]
 497 0008 3960     		str	r1, [r7]
 584:FreeRTOS/queue.c **** 	QueueHandle_t xHandle;
 585:FreeRTOS/queue.c **** 
 586:FreeRTOS/queue.c **** 		configASSERT( uxMaxCount != 0 );
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 20


 587:FreeRTOS/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 588:FreeRTOS/queue.c **** 
 589:FreeRTOS/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 498              		.loc 1 589 0
 499 000a 0222     		movs	r2, #2
 500 000c 0021     		movs	r1, #0
 501 000e 7868     		ldr	r0, [r7, #4]
 502 0010 FFF7FEFF 		bl	xQueueGenericCreate
 503 0014 F860     		str	r0, [r7, #12]
 590:FreeRTOS/queue.c **** 
 591:FreeRTOS/queue.c **** 		if( xHandle != NULL )
 504              		.loc 1 591 0
 505 0016 FB68     		ldr	r3, [r7, #12]
 506 0018 002B     		cmp	r3, #0
 507 001a 02D0     		beq	.L25
 592:FreeRTOS/queue.c **** 		{
 593:FreeRTOS/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 508              		.loc 1 593 0
 509 001c FB68     		ldr	r3, [r7, #12]
 510 001e 3A68     		ldr	r2, [r7]
 511 0020 9A63     		str	r2, [r3, #56]
 512              	.L25:
 594:FreeRTOS/queue.c **** 
 595:FreeRTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 596:FreeRTOS/queue.c **** 		}
 597:FreeRTOS/queue.c **** 		else
 598:FreeRTOS/queue.c **** 		{
 599:FreeRTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 600:FreeRTOS/queue.c **** 		}
 601:FreeRTOS/queue.c **** 
 602:FreeRTOS/queue.c **** 		configASSERT( xHandle );
 603:FreeRTOS/queue.c **** 		return xHandle;
 513              		.loc 1 603 0
 514 0022 FB68     		ldr	r3, [r7, #12]
 604:FreeRTOS/queue.c **** 	}
 515              		.loc 1 604 0
 516 0024 1846     		mov	r0, r3
 517 0026 1037     		adds	r7, r7, #16
 518              		.cfi_def_cfa_offset 8
 519 0028 BD46     		mov	sp, r7
 520              		.cfi_def_cfa_register 13
 521              		@ sp needed
 522 002a 80BD     		pop	{r7, pc}
 523              		.cfi_endproc
 524              	.LFE69:
 525              		.size	xQueueCreateCountingSemaphore, .-xQueueCreateCountingSemaphore
 526              		.section	.text.xQueueGenericSend,"ax",%progbits
 527              		.align	2
 528              		.global	xQueueGenericSend
 529              		.thumb
 530              		.thumb_func
 531              		.type	xQueueGenericSend, %function
 532              	xQueueGenericSend:
 533              	.LFB70:
 605:FreeRTOS/queue.c **** 
 606:FreeRTOS/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 607:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 21


 608:FreeRTOS/queue.c **** 
 609:FreeRTOS/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 610:FreeRTOS/queue.c **** {
 534              		.loc 1 610 0
 535              		.cfi_startproc
 536              		@ args = 0, pretend = 0, frame = 40
 537              		@ frame_needed = 1, uses_anonymous_args = 0
 538 0000 80B5     		push	{r7, lr}
 539              		.cfi_def_cfa_offset 8
 540              		.cfi_offset 7, -8
 541              		.cfi_offset 14, -4
 542 0002 8AB0     		sub	sp, sp, #40
 543              		.cfi_def_cfa_offset 48
 544 0004 00AF     		add	r7, sp, #0
 545              		.cfi_def_cfa_register 7
 546 0006 F860     		str	r0, [r7, #12]
 547 0008 B960     		str	r1, [r7, #8]
 548 000a 7A60     		str	r2, [r7, #4]
 549 000c 3B60     		str	r3, [r7]
 611:FreeRTOS/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 550              		.loc 1 611 0
 551 000e 0023     		movs	r3, #0
 552 0010 7B62     		str	r3, [r7, #36]
 612:FreeRTOS/queue.c **** TimeOut_t xTimeOut;
 613:FreeRTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 553              		.loc 1 613 0
 554 0012 FB68     		ldr	r3, [r7, #12]
 555 0014 3B62     		str	r3, [r7, #32]
 556              	.L42:
 614:FreeRTOS/queue.c **** 
 615:FreeRTOS/queue.c **** 	configASSERT( pxQueue );
 616:FreeRTOS/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 617:FreeRTOS/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 618:FreeRTOS/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 619:FreeRTOS/queue.c **** 	{
 620:FreeRTOS/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 621:FreeRTOS/queue.c **** 	}
 622:FreeRTOS/queue.c **** 	#endif
 623:FreeRTOS/queue.c **** 
 624:FreeRTOS/queue.c **** 
 625:FreeRTOS/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 626:FreeRTOS/queue.c **** 	statements within the function itself.  This is done in the interest
 627:FreeRTOS/queue.c **** 	of execution time efficiency. */
 628:FreeRTOS/queue.c **** 	for( ;; )
 629:FreeRTOS/queue.c **** 	{
 630:FreeRTOS/queue.c **** 		taskENTER_CRITICAL();
 557              		.loc 1 630 0
 558 0016 FFF7FEFF 		bl	vPortEnterCritical
 631:FreeRTOS/queue.c **** 		{
 632:FreeRTOS/queue.c **** 			/* Is there room on the queue now?  The running task must be the
 633:FreeRTOS/queue.c **** 			highest priority task wanting to access the queue.  If the head item
 634:FreeRTOS/queue.c **** 			in the queue is to be overwritten then it does not matter if the
 635:FreeRTOS/queue.c **** 			queue is full. */
 636:FreeRTOS/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 559              		.loc 1 636 0
 560 001a 3B6A     		ldr	r3, [r7, #32]
 561 001c 9A6B     		ldr	r2, [r3, #56]
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 22


 562 001e 3B6A     		ldr	r3, [r7, #32]
 563 0020 DB6B     		ldr	r3, [r3, #60]
 564 0022 9A42     		cmp	r2, r3
 565 0024 02D3     		bcc	.L28
 566              		.loc 1 636 0 is_stmt 0 discriminator 1
 567 0026 3B68     		ldr	r3, [r7]
 568 0028 022B     		cmp	r3, #2
 569 002a 1DD1     		bne	.L29
 570              	.L28:
 637:FreeRTOS/queue.c **** 			{
 638:FreeRTOS/queue.c **** 				traceQUEUE_SEND( pxQueue );
 639:FreeRTOS/queue.c **** 				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 571              		.loc 1 639 0 is_stmt 1
 572 002c 3A68     		ldr	r2, [r7]
 573 002e B968     		ldr	r1, [r7, #8]
 574 0030 386A     		ldr	r0, [r7, #32]
 575 0032 FFF7FEFF 		bl	prvCopyDataToQueue
 576 0036 F861     		str	r0, [r7, #28]
 640:FreeRTOS/queue.c **** 
 641:FreeRTOS/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 642:FreeRTOS/queue.c **** 				{
 643:FreeRTOS/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 644:FreeRTOS/queue.c **** 					{
 645:FreeRTOS/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
 646:FreeRTOS/queue.c **** 						{
 647:FreeRTOS/queue.c **** 							/* The queue is a member of a queue set, and posting
 648:FreeRTOS/queue.c **** 							to the queue set caused a higher priority task to
 649:FreeRTOS/queue.c **** 							unblock. A context switch is required. */
 650:FreeRTOS/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 651:FreeRTOS/queue.c **** 						}
 652:FreeRTOS/queue.c **** 						else
 653:FreeRTOS/queue.c **** 						{
 654:FreeRTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 655:FreeRTOS/queue.c **** 						}
 656:FreeRTOS/queue.c **** 					}
 657:FreeRTOS/queue.c **** 					else
 658:FreeRTOS/queue.c **** 					{
 659:FreeRTOS/queue.c **** 						/* If there was a task waiting for data to arrive on the
 660:FreeRTOS/queue.c **** 						queue then unblock it now. */
 661:FreeRTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 662:FreeRTOS/queue.c **** 						{
 663:FreeRTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 664:FreeRTOS/queue.c **** 							{
 665:FreeRTOS/queue.c **** 								/* The unblocked task has a priority higher than
 666:FreeRTOS/queue.c **** 								our own so yield immediately.  Yes it is ok to
 667:FreeRTOS/queue.c **** 								do this from within the critical section - the
 668:FreeRTOS/queue.c **** 								kernel takes care of that. */
 669:FreeRTOS/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 670:FreeRTOS/queue.c **** 							}
 671:FreeRTOS/queue.c **** 							else
 672:FreeRTOS/queue.c **** 							{
 673:FreeRTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 674:FreeRTOS/queue.c **** 							}
 675:FreeRTOS/queue.c **** 						}
 676:FreeRTOS/queue.c **** 						else if( xYieldRequired != pdFALSE )
 677:FreeRTOS/queue.c **** 						{
 678:FreeRTOS/queue.c **** 							/* This path is a special case that will only get
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 23


 679:FreeRTOS/queue.c **** 							executed if the task was holding multiple mutexes
 680:FreeRTOS/queue.c **** 							and the mutexes were given back in an order that is
 681:FreeRTOS/queue.c **** 							different to that in which they were taken. */
 682:FreeRTOS/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 683:FreeRTOS/queue.c **** 						}
 684:FreeRTOS/queue.c **** 						else
 685:FreeRTOS/queue.c **** 						{
 686:FreeRTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 687:FreeRTOS/queue.c **** 						}
 688:FreeRTOS/queue.c **** 					}
 689:FreeRTOS/queue.c **** 				}
 690:FreeRTOS/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 691:FreeRTOS/queue.c **** 				{
 692:FreeRTOS/queue.c **** 					/* If there was a task waiting for data to arrive on the
 693:FreeRTOS/queue.c **** 					queue then unblock it now. */
 694:FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 577              		.loc 1 694 0
 578 0038 3B6A     		ldr	r3, [r7, #32]
 579 003a 5B6A     		ldr	r3, [r3, #36]
 580 003c 002B     		cmp	r3, #0
 581 003e 0AD0     		beq	.L30
 695:FreeRTOS/queue.c **** 					{
 696:FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 582              		.loc 1 696 0
 583 0040 3B6A     		ldr	r3, [r7, #32]
 584 0042 2433     		adds	r3, r3, #36
 585 0044 1846     		mov	r0, r3
 586 0046 FFF7FEFF 		bl	xTaskRemoveFromEventList
 587 004a 0346     		mov	r3, r0
 588 004c 012B     		cmp	r3, #1
 589 004e 07D1     		bne	.L31
 697:FreeRTOS/queue.c **** 						{
 698:FreeRTOS/queue.c **** 							/* The unblocked task has a priority higher than
 699:FreeRTOS/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 700:FreeRTOS/queue.c **** 							this from within the critical section - the kernel
 701:FreeRTOS/queue.c **** 							takes care of that. */
 702:FreeRTOS/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 590              		.loc 1 702 0
 591 0050 FFF7FEFF 		bl	vPortYield
 592 0054 04E0     		b	.L31
 593              	.L30:
 703:FreeRTOS/queue.c **** 						}
 704:FreeRTOS/queue.c **** 						else
 705:FreeRTOS/queue.c **** 						{
 706:FreeRTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 707:FreeRTOS/queue.c **** 						}
 708:FreeRTOS/queue.c **** 					}
 709:FreeRTOS/queue.c **** 					else if( xYieldRequired != pdFALSE )
 594              		.loc 1 709 0
 595 0056 FB69     		ldr	r3, [r7, #28]
 596 0058 002B     		cmp	r3, #0
 597 005a 01D0     		beq	.L31
 710:FreeRTOS/queue.c **** 					{
 711:FreeRTOS/queue.c **** 						/* This path is a special case that will only get
 712:FreeRTOS/queue.c **** 						executed if the task was holding multiple mutexes and
 713:FreeRTOS/queue.c **** 						the mutexes were given back in an order that is
 714:FreeRTOS/queue.c **** 						different to that in which they were taken. */
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 24


 715:FreeRTOS/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 598              		.loc 1 715 0
 599 005c FFF7FEFF 		bl	vPortYield
 600              	.L31:
 716:FreeRTOS/queue.c **** 					}
 717:FreeRTOS/queue.c **** 					else
 718:FreeRTOS/queue.c **** 					{
 719:FreeRTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 720:FreeRTOS/queue.c **** 					}
 721:FreeRTOS/queue.c **** 				}
 722:FreeRTOS/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 723:FreeRTOS/queue.c **** 
 724:FreeRTOS/queue.c **** 				taskEXIT_CRITICAL();
 601              		.loc 1 724 0
 602 0060 FFF7FEFF 		bl	vPortExitCritical
 725:FreeRTOS/queue.c **** 				return pdPASS;
 603              		.loc 1 725 0
 604 0064 0123     		movs	r3, #1
 605 0066 56E0     		b	.L43
 606              	.L29:
 726:FreeRTOS/queue.c **** 			}
 727:FreeRTOS/queue.c **** 			else
 728:FreeRTOS/queue.c **** 			{
 729:FreeRTOS/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 607              		.loc 1 729 0
 608 0068 7B68     		ldr	r3, [r7, #4]
 609 006a 002B     		cmp	r3, #0
 610 006c 03D1     		bne	.L33
 730:FreeRTOS/queue.c **** 				{
 731:FreeRTOS/queue.c **** 					/* The queue was full and no block time is specified (or
 732:FreeRTOS/queue.c **** 					the block time has expired) so leave now. */
 733:FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 611              		.loc 1 733 0
 612 006e FFF7FEFF 		bl	vPortExitCritical
 734:FreeRTOS/queue.c **** 
 735:FreeRTOS/queue.c **** 					/* Return to the original privilege level before exiting
 736:FreeRTOS/queue.c **** 					the function. */
 737:FreeRTOS/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 738:FreeRTOS/queue.c **** 					return errQUEUE_FULL;
 613              		.loc 1 738 0
 614 0072 0023     		movs	r3, #0
 615 0074 4FE0     		b	.L43
 616              	.L33:
 739:FreeRTOS/queue.c **** 				}
 740:FreeRTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 617              		.loc 1 740 0
 618 0076 7B6A     		ldr	r3, [r7, #36]
 619 0078 002B     		cmp	r3, #0
 620 007a 06D1     		bne	.L34
 741:FreeRTOS/queue.c **** 				{
 742:FreeRTOS/queue.c **** 					/* The queue was full and a block time was specified so
 743:FreeRTOS/queue.c **** 					configure the timeout structure. */
 744:FreeRTOS/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 621              		.loc 1 744 0
 622 007c 07F11403 		add	r3, r7, #20
 623 0080 1846     		mov	r0, r3
 624 0082 FFF7FEFF 		bl	vTaskSetTimeOutState
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 25


 745:FreeRTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 625              		.loc 1 745 0
 626 0086 0123     		movs	r3, #1
 627 0088 7B62     		str	r3, [r7, #36]
 628              	.L34:
 746:FreeRTOS/queue.c **** 				}
 747:FreeRTOS/queue.c **** 				else
 748:FreeRTOS/queue.c **** 				{
 749:FreeRTOS/queue.c **** 					/* Entry time was already set. */
 750:FreeRTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 751:FreeRTOS/queue.c **** 				}
 752:FreeRTOS/queue.c **** 			}
 753:FreeRTOS/queue.c **** 		}
 754:FreeRTOS/queue.c **** 		taskEXIT_CRITICAL();
 629              		.loc 1 754 0
 630 008a FFF7FEFF 		bl	vPortExitCritical
 755:FreeRTOS/queue.c **** 
 756:FreeRTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 757:FreeRTOS/queue.c **** 		now the critical section has been exited. */
 758:FreeRTOS/queue.c **** 
 759:FreeRTOS/queue.c **** 		vTaskSuspendAll();
 631              		.loc 1 759 0
 632 008e FFF7FEFF 		bl	vTaskSuspendAll
 760:FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 633              		.loc 1 760 0
 634 0092 FFF7FEFF 		bl	vPortEnterCritical
 635 0096 3B6A     		ldr	r3, [r7, #32]
 636 0098 5B6C     		ldr	r3, [r3, #68]
 637 009a B3F1FF3F 		cmp	r3, #-1
 638 009e 02D1     		bne	.L35
 639              		.loc 1 760 0 is_stmt 0 discriminator 1
 640 00a0 3B6A     		ldr	r3, [r7, #32]
 641 00a2 0022     		movs	r2, #0
 642 00a4 5A64     		str	r2, [r3, #68]
 643              	.L35:
 644              		.loc 1 760 0 discriminator 3
 645 00a6 3B6A     		ldr	r3, [r7, #32]
 646 00a8 9B6C     		ldr	r3, [r3, #72]
 647 00aa B3F1FF3F 		cmp	r3, #-1
 648 00ae 02D1     		bne	.L36
 649              		.loc 1 760 0 discriminator 4
 650 00b0 3B6A     		ldr	r3, [r7, #32]
 651 00b2 0022     		movs	r2, #0
 652 00b4 9A64     		str	r2, [r3, #72]
 653              	.L36:
 654              		.loc 1 760 0 discriminator 6
 655 00b6 FFF7FEFF 		bl	vPortExitCritical
 761:FreeRTOS/queue.c **** 
 762:FreeRTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 763:FreeRTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 656              		.loc 1 763 0 is_stmt 1 discriminator 6
 657 00ba 3A1D     		adds	r2, r7, #4
 658 00bc 07F11403 		add	r3, r7, #20
 659 00c0 1146     		mov	r1, r2
 660 00c2 1846     		mov	r0, r3
 661 00c4 FFF7FEFF 		bl	xTaskCheckForTimeOut
 662 00c8 0346     		mov	r3, r0
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 26


 663 00ca 002B     		cmp	r3, #0
 664 00cc 1DD1     		bne	.L37
 764:FreeRTOS/queue.c **** 		{
 765:FreeRTOS/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 665              		.loc 1 765 0
 666 00ce 386A     		ldr	r0, [r7, #32]
 667 00d0 FFF7FEFF 		bl	prvIsQueueFull
 668 00d4 0346     		mov	r3, r0
 669 00d6 002B     		cmp	r3, #0
 670 00d8 11D0     		beq	.L38
 766:FreeRTOS/queue.c **** 			{
 767:FreeRTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 768:FreeRTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 671              		.loc 1 768 0
 672 00da 3B6A     		ldr	r3, [r7, #32]
 673 00dc 1033     		adds	r3, r3, #16
 674 00de 7A68     		ldr	r2, [r7, #4]
 675 00e0 1146     		mov	r1, r2
 676 00e2 1846     		mov	r0, r3
 677 00e4 FFF7FEFF 		bl	vTaskPlaceOnEventList
 769:FreeRTOS/queue.c **** 
 770:FreeRTOS/queue.c **** 				/* Unlocking the queue means queue events can effect the
 771:FreeRTOS/queue.c **** 				event list.  It is possible	that interrupts occurring now
 772:FreeRTOS/queue.c **** 				remove this task from the event	list again - but as the
 773:FreeRTOS/queue.c **** 				scheduler is suspended the task will go onto the pending
 774:FreeRTOS/queue.c **** 				ready last instead of the actual ready list. */
 775:FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 678              		.loc 1 775 0
 679 00e8 386A     		ldr	r0, [r7, #32]
 680 00ea FFF7FEFF 		bl	prvUnlockQueue
 776:FreeRTOS/queue.c **** 
 777:FreeRTOS/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 778:FreeRTOS/queue.c **** 				ready list into the ready list - so it is feasible that this
 779:FreeRTOS/queue.c **** 				task is already in a ready list before it yields - in which
 780:FreeRTOS/queue.c **** 				case the yield will not cause a context switch unless there
 781:FreeRTOS/queue.c **** 				is also a higher priority task in the pending ready list. */
 782:FreeRTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 681              		.loc 1 782 0
 682 00ee FFF7FEFF 		bl	xTaskResumeAll
 683 00f2 0346     		mov	r3, r0
 684 00f4 002B     		cmp	r3, #0
 685 00f6 8ED1     		bne	.L42
 783:FreeRTOS/queue.c **** 				{
 784:FreeRTOS/queue.c **** 					portYIELD_WITHIN_API();
 686              		.loc 1 784 0
 687 00f8 FFF7FEFF 		bl	vPortYield
 688 00fc 8BE7     		b	.L42
 689              	.L38:
 785:FreeRTOS/queue.c **** 				}
 786:FreeRTOS/queue.c **** 			}
 787:FreeRTOS/queue.c **** 			else
 788:FreeRTOS/queue.c **** 			{
 789:FreeRTOS/queue.c **** 				/* Try again. */
 790:FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 690              		.loc 1 790 0
 691 00fe 386A     		ldr	r0, [r7, #32]
 692 0100 FFF7FEFF 		bl	prvUnlockQueue
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 27


 791:FreeRTOS/queue.c **** 				( void ) xTaskResumeAll();
 693              		.loc 1 791 0
 694 0104 FFF7FEFF 		bl	xTaskResumeAll
 695 0108 85E7     		b	.L42
 696              	.L37:
 792:FreeRTOS/queue.c **** 			}
 793:FreeRTOS/queue.c **** 		}
 794:FreeRTOS/queue.c **** 		else
 795:FreeRTOS/queue.c **** 		{
 796:FreeRTOS/queue.c **** 			/* The timeout has expired. */
 797:FreeRTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 697              		.loc 1 797 0
 698 010a 386A     		ldr	r0, [r7, #32]
 699 010c FFF7FEFF 		bl	prvUnlockQueue
 798:FreeRTOS/queue.c **** 			( void ) xTaskResumeAll();
 700              		.loc 1 798 0
 701 0110 FFF7FEFF 		bl	xTaskResumeAll
 799:FreeRTOS/queue.c **** 
 800:FreeRTOS/queue.c **** 			/* Return to the original privilege level before exiting the
 801:FreeRTOS/queue.c **** 			function. */
 802:FreeRTOS/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 803:FreeRTOS/queue.c **** 			return errQUEUE_FULL;
 702              		.loc 1 803 0
 703 0114 0023     		movs	r3, #0
 704              	.L43:
 804:FreeRTOS/queue.c **** 		}
 805:FreeRTOS/queue.c **** 	}
 806:FreeRTOS/queue.c **** }
 705              		.loc 1 806 0 discriminator 3
 706 0116 1846     		mov	r0, r3
 707 0118 2837     		adds	r7, r7, #40
 708              		.cfi_def_cfa_offset 8
 709 011a BD46     		mov	sp, r7
 710              		.cfi_def_cfa_register 13
 711              		@ sp needed
 712 011c 80BD     		pop	{r7, pc}
 713              		.cfi_endproc
 714              	.LFE70:
 715              		.size	xQueueGenericSend, .-xQueueGenericSend
 716 011e 00BF     		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 717              		.align	2
 718              		.global	xQueueGenericSendFromISR
 719              		.thumb
 720              		.thumb_func
 721              		.type	xQueueGenericSendFromISR, %function
 722              	xQueueGenericSendFromISR:
 723              	.LFB71:
 807:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 808:FreeRTOS/queue.c **** 
 809:FreeRTOS/queue.c **** #if ( configUSE_ALTERNATIVE_API == 1 )
 810:FreeRTOS/queue.c **** 
 811:FreeRTOS/queue.c **** 	BaseType_t xQueueAltGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_
 812:FreeRTOS/queue.c **** 	{
 813:FreeRTOS/queue.c **** 	BaseType_t xEntryTimeSet = pdFALSE;
 814:FreeRTOS/queue.c **** 	TimeOut_t xTimeOut;
 815:FreeRTOS/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 816:FreeRTOS/queue.c **** 
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 28


 817:FreeRTOS/queue.c **** 		configASSERT( pxQueue );
 818:FreeRTOS/queue.c **** 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 819:FreeRTOS/queue.c **** 
 820:FreeRTOS/queue.c **** 		for( ;; )
 821:FreeRTOS/queue.c **** 		{
 822:FreeRTOS/queue.c **** 			taskENTER_CRITICAL();
 823:FreeRTOS/queue.c **** 			{
 824:FreeRTOS/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 825:FreeRTOS/queue.c **** 				the highest priority task wanting to access the queue. */
 826:FreeRTOS/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 827:FreeRTOS/queue.c **** 				{
 828:FreeRTOS/queue.c **** 					traceQUEUE_SEND( pxQueue );
 829:FreeRTOS/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 830:FreeRTOS/queue.c **** 
 831:FreeRTOS/queue.c **** 					/* If there was a task waiting for data to arrive on the
 832:FreeRTOS/queue.c **** 					queue then unblock it now. */
 833:FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 834:FreeRTOS/queue.c **** 					{
 835:FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 836:FreeRTOS/queue.c **** 						{
 837:FreeRTOS/queue.c **** 							/* The unblocked task has a priority higher than
 838:FreeRTOS/queue.c **** 							our own so yield immediately. */
 839:FreeRTOS/queue.c **** 							portYIELD_WITHIN_API();
 840:FreeRTOS/queue.c **** 						}
 841:FreeRTOS/queue.c **** 						else
 842:FreeRTOS/queue.c **** 						{
 843:FreeRTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 844:FreeRTOS/queue.c **** 						}
 845:FreeRTOS/queue.c **** 					}
 846:FreeRTOS/queue.c **** 					else
 847:FreeRTOS/queue.c **** 					{
 848:FreeRTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 849:FreeRTOS/queue.c **** 					}
 850:FreeRTOS/queue.c **** 
 851:FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 852:FreeRTOS/queue.c **** 					return pdPASS;
 853:FreeRTOS/queue.c **** 				}
 854:FreeRTOS/queue.c **** 				else
 855:FreeRTOS/queue.c **** 				{
 856:FreeRTOS/queue.c **** 					if( xTicksToWait == ( TickType_t ) 0 )
 857:FreeRTOS/queue.c **** 					{
 858:FreeRTOS/queue.c **** 						taskEXIT_CRITICAL();
 859:FreeRTOS/queue.c **** 						return errQUEUE_FULL;
 860:FreeRTOS/queue.c **** 					}
 861:FreeRTOS/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 862:FreeRTOS/queue.c **** 					{
 863:FreeRTOS/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 864:FreeRTOS/queue.c **** 						xEntryTimeSet = pdTRUE;
 865:FreeRTOS/queue.c **** 					}
 866:FreeRTOS/queue.c **** 				}
 867:FreeRTOS/queue.c **** 			}
 868:FreeRTOS/queue.c **** 			taskEXIT_CRITICAL();
 869:FreeRTOS/queue.c **** 
 870:FreeRTOS/queue.c **** 			taskENTER_CRITICAL();
 871:FreeRTOS/queue.c **** 			{
 872:FreeRTOS/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 873:FreeRTOS/queue.c **** 				{
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 29


 874:FreeRTOS/queue.c **** 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
 875:FreeRTOS/queue.c **** 					{
 876:FreeRTOS/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 877:FreeRTOS/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 878:FreeRTOS/queue.c **** 						portYIELD_WITHIN_API();
 879:FreeRTOS/queue.c **** 					}
 880:FreeRTOS/queue.c **** 					else
 881:FreeRTOS/queue.c **** 					{
 882:FreeRTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 883:FreeRTOS/queue.c **** 					}
 884:FreeRTOS/queue.c **** 				}
 885:FreeRTOS/queue.c **** 				else
 886:FreeRTOS/queue.c **** 				{
 887:FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 888:FreeRTOS/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 889:FreeRTOS/queue.c **** 					return errQUEUE_FULL;
 890:FreeRTOS/queue.c **** 				}
 891:FreeRTOS/queue.c **** 			}
 892:FreeRTOS/queue.c **** 			taskEXIT_CRITICAL();
 893:FreeRTOS/queue.c **** 		}
 894:FreeRTOS/queue.c **** 	}
 895:FreeRTOS/queue.c **** 
 896:FreeRTOS/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 897:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 898:FreeRTOS/queue.c **** 
 899:FreeRTOS/queue.c **** #if ( configUSE_ALTERNATIVE_API == 1 )
 900:FreeRTOS/queue.c **** 
 901:FreeRTOS/queue.c **** 	BaseType_t xQueueAltGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicks
 902:FreeRTOS/queue.c **** 	{
 903:FreeRTOS/queue.c **** 	BaseType_t xEntryTimeSet = pdFALSE;
 904:FreeRTOS/queue.c **** 	TimeOut_t xTimeOut;
 905:FreeRTOS/queue.c **** 	int8_t *pcOriginalReadPosition;
 906:FreeRTOS/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 907:FreeRTOS/queue.c **** 
 908:FreeRTOS/queue.c **** 		configASSERT( pxQueue );
 909:FreeRTOS/queue.c **** 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 910:FreeRTOS/queue.c **** 
 911:FreeRTOS/queue.c **** 		for( ;; )
 912:FreeRTOS/queue.c **** 		{
 913:FreeRTOS/queue.c **** 			taskENTER_CRITICAL();
 914:FreeRTOS/queue.c **** 			{
 915:FreeRTOS/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 916:FreeRTOS/queue.c **** 				{
 917:FreeRTOS/queue.c **** 					/* Remember our read position in case we are just peeking. */
 918:FreeRTOS/queue.c **** 					pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 919:FreeRTOS/queue.c **** 
 920:FreeRTOS/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 921:FreeRTOS/queue.c **** 
 922:FreeRTOS/queue.c **** 					if( xJustPeeking == pdFALSE )
 923:FreeRTOS/queue.c **** 					{
 924:FreeRTOS/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 925:FreeRTOS/queue.c **** 
 926:FreeRTOS/queue.c **** 						/* Data is actually being removed (not just peeked). */
 927:FreeRTOS/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 928:FreeRTOS/queue.c **** 
 929:FreeRTOS/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 930:FreeRTOS/queue.c **** 						{
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 30


 931:FreeRTOS/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 932:FreeRTOS/queue.c **** 							{
 933:FreeRTOS/queue.c **** 								/* Record the information required to implement
 934:FreeRTOS/queue.c **** 								priority inheritance should it become necessary. */
 935:FreeRTOS/queue.c **** 								pxQueue->pxMutexHolder = ( int8_t * ) xTaskGetCurrentTaskHandle();
 936:FreeRTOS/queue.c **** 							}
 937:FreeRTOS/queue.c **** 							else
 938:FreeRTOS/queue.c **** 							{
 939:FreeRTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 940:FreeRTOS/queue.c **** 							}
 941:FreeRTOS/queue.c **** 						}
 942:FreeRTOS/queue.c **** 						#endif
 943:FreeRTOS/queue.c **** 
 944:FreeRTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 945:FreeRTOS/queue.c **** 						{
 946:FreeRTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 947:FreeRTOS/queue.c **** 							{
 948:FreeRTOS/queue.c **** 								portYIELD_WITHIN_API();
 949:FreeRTOS/queue.c **** 							}
 950:FreeRTOS/queue.c **** 							else
 951:FreeRTOS/queue.c **** 							{
 952:FreeRTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 953:FreeRTOS/queue.c **** 							}
 954:FreeRTOS/queue.c **** 						}
 955:FreeRTOS/queue.c **** 					}
 956:FreeRTOS/queue.c **** 					else
 957:FreeRTOS/queue.c **** 					{
 958:FreeRTOS/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 959:FreeRTOS/queue.c **** 
 960:FreeRTOS/queue.c **** 						/* The data is not being removed, so reset our read
 961:FreeRTOS/queue.c **** 						pointer. */
 962:FreeRTOS/queue.c **** 						pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 963:FreeRTOS/queue.c **** 
 964:FreeRTOS/queue.c **** 						/* The data is being left in the queue, so see if there are
 965:FreeRTOS/queue.c **** 						any other tasks waiting for the data. */
 966:FreeRTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 967:FreeRTOS/queue.c **** 						{
 968:FreeRTOS/queue.c **** 							/* Tasks that are removed from the event list will get added to
 969:FreeRTOS/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 970:FreeRTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 971:FreeRTOS/queue.c **** 							{
 972:FreeRTOS/queue.c **** 								/* The task waiting has a higher priority than this task. */
 973:FreeRTOS/queue.c **** 								portYIELD_WITHIN_API();
 974:FreeRTOS/queue.c **** 							}
 975:FreeRTOS/queue.c **** 							else
 976:FreeRTOS/queue.c **** 							{
 977:FreeRTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 978:FreeRTOS/queue.c **** 							}
 979:FreeRTOS/queue.c **** 						}
 980:FreeRTOS/queue.c **** 						else
 981:FreeRTOS/queue.c **** 						{
 982:FreeRTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 983:FreeRTOS/queue.c **** 						}
 984:FreeRTOS/queue.c **** 					}
 985:FreeRTOS/queue.c **** 
 986:FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 987:FreeRTOS/queue.c **** 					return pdPASS;
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 31


 988:FreeRTOS/queue.c **** 				}
 989:FreeRTOS/queue.c **** 				else
 990:FreeRTOS/queue.c **** 				{
 991:FreeRTOS/queue.c **** 					if( xTicksToWait == ( TickType_t ) 0 )
 992:FreeRTOS/queue.c **** 					{
 993:FreeRTOS/queue.c **** 						taskEXIT_CRITICAL();
 994:FreeRTOS/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 995:FreeRTOS/queue.c **** 						return errQUEUE_EMPTY;
 996:FreeRTOS/queue.c **** 					}
 997:FreeRTOS/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 998:FreeRTOS/queue.c **** 					{
 999:FreeRTOS/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
1000:FreeRTOS/queue.c **** 						xEntryTimeSet = pdTRUE;
1001:FreeRTOS/queue.c **** 					}
1002:FreeRTOS/queue.c **** 				}
1003:FreeRTOS/queue.c **** 			}
1004:FreeRTOS/queue.c **** 			taskEXIT_CRITICAL();
1005:FreeRTOS/queue.c **** 
1006:FreeRTOS/queue.c **** 			taskENTER_CRITICAL();
1007:FreeRTOS/queue.c **** 			{
1008:FreeRTOS/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1009:FreeRTOS/queue.c **** 				{
1010:FreeRTOS/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1011:FreeRTOS/queue.c **** 					{
1012:FreeRTOS/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1013:FreeRTOS/queue.c **** 
1014:FreeRTOS/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
1015:FreeRTOS/queue.c **** 						{
1016:FreeRTOS/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1017:FreeRTOS/queue.c **** 							{
1018:FreeRTOS/queue.c **** 								taskENTER_CRITICAL();
1019:FreeRTOS/queue.c **** 								{
1020:FreeRTOS/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
1021:FreeRTOS/queue.c **** 								}
1022:FreeRTOS/queue.c **** 								taskEXIT_CRITICAL();
1023:FreeRTOS/queue.c **** 							}
1024:FreeRTOS/queue.c **** 							else
1025:FreeRTOS/queue.c **** 							{
1026:FreeRTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1027:FreeRTOS/queue.c **** 							}
1028:FreeRTOS/queue.c **** 						}
1029:FreeRTOS/queue.c **** 						#endif
1030:FreeRTOS/queue.c **** 
1031:FreeRTOS/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1032:FreeRTOS/queue.c **** 						portYIELD_WITHIN_API();
1033:FreeRTOS/queue.c **** 					}
1034:FreeRTOS/queue.c **** 					else
1035:FreeRTOS/queue.c **** 					{
1036:FreeRTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1037:FreeRTOS/queue.c **** 					}
1038:FreeRTOS/queue.c **** 				}
1039:FreeRTOS/queue.c **** 				else
1040:FreeRTOS/queue.c **** 				{
1041:FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
1042:FreeRTOS/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1043:FreeRTOS/queue.c **** 					return errQUEUE_EMPTY;
1044:FreeRTOS/queue.c **** 				}
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 32


1045:FreeRTOS/queue.c **** 			}
1046:FreeRTOS/queue.c **** 			taskEXIT_CRITICAL();
1047:FreeRTOS/queue.c **** 		}
1048:FreeRTOS/queue.c **** 	}
1049:FreeRTOS/queue.c **** 
1050:FreeRTOS/queue.c **** 
1051:FreeRTOS/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
1052:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1053:FreeRTOS/queue.c **** 
1054:FreeRTOS/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
1055:FreeRTOS/queue.c **** {
 724              		.loc 1 1055 0
 725              		.cfi_startproc
 726              		@ args = 0, pretend = 0, frame = 32
 727              		@ frame_needed = 1, uses_anonymous_args = 0
 728 0000 80B5     		push	{r7, lr}
 729              		.cfi_def_cfa_offset 8
 730              		.cfi_offset 7, -8
 731              		.cfi_offset 14, -4
 732 0002 88B0     		sub	sp, sp, #32
 733              		.cfi_def_cfa_offset 40
 734 0004 00AF     		add	r7, sp, #0
 735              		.cfi_def_cfa_register 7
 736 0006 F860     		str	r0, [r7, #12]
 737 0008 B960     		str	r1, [r7, #8]
 738 000a 7A60     		str	r2, [r7, #4]
 739 000c 3B60     		str	r3, [r7]
1056:FreeRTOS/queue.c **** BaseType_t xReturn;
1057:FreeRTOS/queue.c **** UBaseType_t uxSavedInterruptStatus;
1058:FreeRTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 740              		.loc 1 1058 0
 741 000e FB68     		ldr	r3, [r7, #12]
 742 0010 BB61     		str	r3, [r7, #24]
1059:FreeRTOS/queue.c **** 
1060:FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1061:FreeRTOS/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1062:FreeRTOS/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
1063:FreeRTOS/queue.c **** 
1064:FreeRTOS/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1065:FreeRTOS/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1066:FreeRTOS/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1067:FreeRTOS/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1068:FreeRTOS/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1069:FreeRTOS/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1070:FreeRTOS/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1071:FreeRTOS/queue.c **** 	assigned a priority above the configured maximum system call priority.
1072:FreeRTOS/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1073:FreeRTOS/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1074:FreeRTOS/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1075:FreeRTOS/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1076:FreeRTOS/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1077:FreeRTOS/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1078:FreeRTOS/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1079:FreeRTOS/queue.c **** 
1080:FreeRTOS/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
1081:FreeRTOS/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
1082:FreeRTOS/queue.c **** 	read, instead return a flag to say whether a context switch is required or
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 33


1083:FreeRTOS/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1084:FreeRTOS/queue.c **** 	post). */
1085:FreeRTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 743              		.loc 1 1085 0
 744 0012 FFF7FEFF 		bl	ulPortSetInterruptMask
 745 0016 7861     		str	r0, [r7, #20]
1086:FreeRTOS/queue.c **** 	{
1087:FreeRTOS/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 746              		.loc 1 1087 0
 747 0018 BB69     		ldr	r3, [r7, #24]
 748 001a 9A6B     		ldr	r2, [r3, #56]
 749 001c BB69     		ldr	r3, [r7, #24]
 750 001e DB6B     		ldr	r3, [r3, #60]
 751 0020 9A42     		cmp	r2, r3
 752 0022 02D3     		bcc	.L45
 753              		.loc 1 1087 0 is_stmt 0 discriminator 1
 754 0024 3B68     		ldr	r3, [r7]
 755 0026 022B     		cmp	r3, #2
 756 0028 24D1     		bne	.L46
 757              	.L45:
1088:FreeRTOS/queue.c **** 		{
1089:FreeRTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1090:FreeRTOS/queue.c **** 
1091:FreeRTOS/queue.c **** 			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
1092:FreeRTOS/queue.c **** 			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
1093:FreeRTOS/queue.c **** 			in a task disinheriting a priority and prvCopyDataToQueue() can be
1094:FreeRTOS/queue.c **** 			called here even though the disinherit function does not check if
1095:FreeRTOS/queue.c **** 			the scheduler is suspended before accessing the ready lists. */
1096:FreeRTOS/queue.c **** 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 758              		.loc 1 1096 0 is_stmt 1
 759 002a 3A68     		ldr	r2, [r7]
 760 002c B968     		ldr	r1, [r7, #8]
 761 002e B869     		ldr	r0, [r7, #24]
 762 0030 FFF7FEFF 		bl	prvCopyDataToQueue
1097:FreeRTOS/queue.c **** 
1098:FreeRTOS/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1099:FreeRTOS/queue.c **** 			be done when the queue is unlocked later. */
1100:FreeRTOS/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 763              		.loc 1 1100 0
 764 0034 BB69     		ldr	r3, [r7, #24]
 765 0036 9B6C     		ldr	r3, [r3, #72]
 766 0038 B3F1FF3F 		cmp	r3, #-1
 767 003c 12D1     		bne	.L47
1101:FreeRTOS/queue.c **** 			{
1102:FreeRTOS/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1103:FreeRTOS/queue.c **** 				{
1104:FreeRTOS/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1105:FreeRTOS/queue.c **** 					{
1106:FreeRTOS/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
1107:FreeRTOS/queue.c **** 						{
1108:FreeRTOS/queue.c **** 							/* The queue is a member of a queue set, and posting
1109:FreeRTOS/queue.c **** 							to the queue set caused a higher priority task to
1110:FreeRTOS/queue.c **** 							unblock.  A context switch is required. */
1111:FreeRTOS/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1112:FreeRTOS/queue.c **** 							{
1113:FreeRTOS/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1114:FreeRTOS/queue.c **** 							}
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 34


1115:FreeRTOS/queue.c **** 							else
1116:FreeRTOS/queue.c **** 							{
1117:FreeRTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1118:FreeRTOS/queue.c **** 							}
1119:FreeRTOS/queue.c **** 						}
1120:FreeRTOS/queue.c **** 						else
1121:FreeRTOS/queue.c **** 						{
1122:FreeRTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1123:FreeRTOS/queue.c **** 						}
1124:FreeRTOS/queue.c **** 					}
1125:FreeRTOS/queue.c **** 					else
1126:FreeRTOS/queue.c **** 					{
1127:FreeRTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1128:FreeRTOS/queue.c **** 						{
1129:FreeRTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1130:FreeRTOS/queue.c **** 							{
1131:FreeRTOS/queue.c **** 								/* The task waiting has a higher priority so
1132:FreeRTOS/queue.c **** 								record that a context switch is required. */
1133:FreeRTOS/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1134:FreeRTOS/queue.c **** 								{
1135:FreeRTOS/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1136:FreeRTOS/queue.c **** 								}
1137:FreeRTOS/queue.c **** 								else
1138:FreeRTOS/queue.c **** 								{
1139:FreeRTOS/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1140:FreeRTOS/queue.c **** 								}
1141:FreeRTOS/queue.c **** 							}
1142:FreeRTOS/queue.c **** 							else
1143:FreeRTOS/queue.c **** 							{
1144:FreeRTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1145:FreeRTOS/queue.c **** 							}
1146:FreeRTOS/queue.c **** 						}
1147:FreeRTOS/queue.c **** 						else
1148:FreeRTOS/queue.c **** 						{
1149:FreeRTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1150:FreeRTOS/queue.c **** 						}
1151:FreeRTOS/queue.c **** 					}
1152:FreeRTOS/queue.c **** 				}
1153:FreeRTOS/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1154:FreeRTOS/queue.c **** 				{
1155:FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 768              		.loc 1 1155 0
 769 003e BB69     		ldr	r3, [r7, #24]
 770 0040 5B6A     		ldr	r3, [r3, #36]
 771 0042 002B     		cmp	r3, #0
 772 0044 13D0     		beq	.L48
1156:FreeRTOS/queue.c **** 					{
1157:FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 773              		.loc 1 1157 0
 774 0046 BB69     		ldr	r3, [r7, #24]
 775 0048 2433     		adds	r3, r3, #36
 776 004a 1846     		mov	r0, r3
 777 004c FFF7FEFF 		bl	xTaskRemoveFromEventList
 778 0050 0346     		mov	r3, r0
 779 0052 002B     		cmp	r3, #0
 780 0054 0BD0     		beq	.L48
1158:FreeRTOS/queue.c **** 						{
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 35


1159:FreeRTOS/queue.c **** 							/* The task waiting has a higher priority so record that a
1160:FreeRTOS/queue.c **** 							context	switch is required. */
1161:FreeRTOS/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 781              		.loc 1 1161 0
 782 0056 7B68     		ldr	r3, [r7, #4]
 783 0058 002B     		cmp	r3, #0
 784 005a 08D0     		beq	.L48
1162:FreeRTOS/queue.c **** 							{
1163:FreeRTOS/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 785              		.loc 1 1163 0
 786 005c 7B68     		ldr	r3, [r7, #4]
 787 005e 0122     		movs	r2, #1
 788 0060 1A60     		str	r2, [r3]
 789 0062 04E0     		b	.L48
 790              	.L47:
1164:FreeRTOS/queue.c **** 							}
1165:FreeRTOS/queue.c **** 							else
1166:FreeRTOS/queue.c **** 							{
1167:FreeRTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1168:FreeRTOS/queue.c **** 							}
1169:FreeRTOS/queue.c **** 						}
1170:FreeRTOS/queue.c **** 						else
1171:FreeRTOS/queue.c **** 						{
1172:FreeRTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1173:FreeRTOS/queue.c **** 						}
1174:FreeRTOS/queue.c **** 					}
1175:FreeRTOS/queue.c **** 					else
1176:FreeRTOS/queue.c **** 					{
1177:FreeRTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1178:FreeRTOS/queue.c **** 					}
1179:FreeRTOS/queue.c **** 				}
1180:FreeRTOS/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1181:FreeRTOS/queue.c **** 			}
1182:FreeRTOS/queue.c **** 			else
1183:FreeRTOS/queue.c **** 			{
1184:FreeRTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1185:FreeRTOS/queue.c **** 				knows that data was posted while it was locked. */
1186:FreeRTOS/queue.c **** 				++( pxQueue->xTxLock );
 791              		.loc 1 1186 0
 792 0064 BB69     		ldr	r3, [r7, #24]
 793 0066 9B6C     		ldr	r3, [r3, #72]
 794 0068 5A1C     		adds	r2, r3, #1
 795 006a BB69     		ldr	r3, [r7, #24]
 796 006c 9A64     		str	r2, [r3, #72]
 797              	.L48:
1187:FreeRTOS/queue.c **** 			}
1188:FreeRTOS/queue.c **** 
1189:FreeRTOS/queue.c **** 			xReturn = pdPASS;
 798              		.loc 1 1189 0
 799 006e 0123     		movs	r3, #1
 800 0070 FB61     		str	r3, [r7, #28]
 801 0072 01E0     		b	.L49
 802              	.L46:
1190:FreeRTOS/queue.c **** 		}
1191:FreeRTOS/queue.c **** 		else
1192:FreeRTOS/queue.c **** 		{
1193:FreeRTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 36


1194:FreeRTOS/queue.c **** 			xReturn = errQUEUE_FULL;
 803              		.loc 1 1194 0
 804 0074 0023     		movs	r3, #0
 805 0076 FB61     		str	r3, [r7, #28]
 806              	.L49:
1195:FreeRTOS/queue.c **** 		}
1196:FreeRTOS/queue.c **** 	}
1197:FreeRTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 807              		.loc 1 1197 0
 808 0078 7869     		ldr	r0, [r7, #20]
 809 007a FFF7FEFF 		bl	vPortClearInterruptMask
1198:FreeRTOS/queue.c **** 
1199:FreeRTOS/queue.c **** 	return xReturn;
 810              		.loc 1 1199 0
 811 007e FB69     		ldr	r3, [r7, #28]
1200:FreeRTOS/queue.c **** }
 812              		.loc 1 1200 0
 813 0080 1846     		mov	r0, r3
 814 0082 2037     		adds	r7, r7, #32
 815              		.cfi_def_cfa_offset 8
 816 0084 BD46     		mov	sp, r7
 817              		.cfi_def_cfa_register 13
 818              		@ sp needed
 819 0086 80BD     		pop	{r7, pc}
 820              		.cfi_endproc
 821              	.LFE71:
 822              		.size	xQueueGenericSendFromISR, .-xQueueGenericSendFromISR
 823              		.section	.text.xQueueGiveFromISR,"ax",%progbits
 824              		.align	2
 825              		.global	xQueueGiveFromISR
 826              		.thumb
 827              		.thumb_func
 828              		.type	xQueueGiveFromISR, %function
 829              	xQueueGiveFromISR:
 830              	.LFB72:
1201:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1202:FreeRTOS/queue.c **** 
1203:FreeRTOS/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1204:FreeRTOS/queue.c **** {
 831              		.loc 1 1204 0
 832              		.cfi_startproc
 833              		@ args = 0, pretend = 0, frame = 24
 834              		@ frame_needed = 1, uses_anonymous_args = 0
 835 0000 80B5     		push	{r7, lr}
 836              		.cfi_def_cfa_offset 8
 837              		.cfi_offset 7, -8
 838              		.cfi_offset 14, -4
 839 0002 86B0     		sub	sp, sp, #24
 840              		.cfi_def_cfa_offset 32
 841 0004 00AF     		add	r7, sp, #0
 842              		.cfi_def_cfa_register 7
 843 0006 7860     		str	r0, [r7, #4]
 844 0008 3960     		str	r1, [r7]
1205:FreeRTOS/queue.c **** BaseType_t xReturn;
1206:FreeRTOS/queue.c **** UBaseType_t uxSavedInterruptStatus;
1207:FreeRTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 845              		.loc 1 1207 0
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 37


 846 000a 7B68     		ldr	r3, [r7, #4]
 847 000c 3B61     		str	r3, [r7, #16]
1208:FreeRTOS/queue.c **** 
1209:FreeRTOS/queue.c **** 	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1210:FreeRTOS/queue.c **** 	item size is 0.  Don't directly wake a task that was blocked on a queue
1211:FreeRTOS/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1212:FreeRTOS/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1213:FreeRTOS/queue.c **** 	post). */
1214:FreeRTOS/queue.c **** 
1215:FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1216:FreeRTOS/queue.c **** 
1217:FreeRTOS/queue.c **** 	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1218:FreeRTOS/queue.c **** 	if the item size is not 0. */
1219:FreeRTOS/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1220:FreeRTOS/queue.c **** 
1221:FreeRTOS/queue.c **** 	/* Normally a mutex would not be given from an interrupt, especially if
1222:FreeRTOS/queue.c **** 	there is a mutex holder, as priority inheritance makes no sense for an
1223:FreeRTOS/queue.c **** 	interrupts, only tasks. */
1224:FreeRTOS/queue.c **** 	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NU
1225:FreeRTOS/queue.c **** 
1226:FreeRTOS/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1227:FreeRTOS/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1228:FreeRTOS/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1229:FreeRTOS/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1230:FreeRTOS/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1231:FreeRTOS/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1232:FreeRTOS/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1233:FreeRTOS/queue.c **** 	assigned a priority above the configured maximum system call priority.
1234:FreeRTOS/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1235:FreeRTOS/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1236:FreeRTOS/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1237:FreeRTOS/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1238:FreeRTOS/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1239:FreeRTOS/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1240:FreeRTOS/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1241:FreeRTOS/queue.c **** 
1242:FreeRTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 848              		.loc 1 1242 0
 849 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 850 0012 F860     		str	r0, [r7, #12]
1243:FreeRTOS/queue.c **** 	{
1244:FreeRTOS/queue.c **** 		/* When the queue is used to implement a semaphore no data is ever
1245:FreeRTOS/queue.c **** 		moved through the queue but it is still valid to see if the queue 'has
1246:FreeRTOS/queue.c **** 		space'. */
1247:FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 851              		.loc 1 1247 0
 852 0014 3B69     		ldr	r3, [r7, #16]
 853 0016 9A6B     		ldr	r2, [r3, #56]
 854 0018 3B69     		ldr	r3, [r7, #16]
 855 001a DB6B     		ldr	r3, [r3, #60]
 856 001c 9A42     		cmp	r2, r3
 857 001e 24D2     		bcs	.L52
1248:FreeRTOS/queue.c **** 		{
1249:FreeRTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1250:FreeRTOS/queue.c **** 
1251:FreeRTOS/queue.c **** 			/* A task can only have an inherited priority if it is a mutex
1252:FreeRTOS/queue.c **** 			holder - and if there is a mutex holder then the mutex cannot be
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 38


1253:FreeRTOS/queue.c **** 			given from an ISR.  As this is the ISR version of the function it
1254:FreeRTOS/queue.c **** 			can be assumed there is no mutex holder and no need to determine if
1255:FreeRTOS/queue.c **** 			priority disinheritance is needed.  Simply increase the count of
1256:FreeRTOS/queue.c **** 			messages (semaphores) available. */
1257:FreeRTOS/queue.c **** 			++( pxQueue->uxMessagesWaiting );
 858              		.loc 1 1257 0
 859 0020 3B69     		ldr	r3, [r7, #16]
 860 0022 9B6B     		ldr	r3, [r3, #56]
 861 0024 5A1C     		adds	r2, r3, #1
 862 0026 3B69     		ldr	r3, [r7, #16]
 863 0028 9A63     		str	r2, [r3, #56]
1258:FreeRTOS/queue.c **** 
1259:FreeRTOS/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1260:FreeRTOS/queue.c **** 			be done when the queue is unlocked later. */
1261:FreeRTOS/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 864              		.loc 1 1261 0
 865 002a 3B69     		ldr	r3, [r7, #16]
 866 002c 9B6C     		ldr	r3, [r3, #72]
 867 002e B3F1FF3F 		cmp	r3, #-1
 868 0032 12D1     		bne	.L53
1262:FreeRTOS/queue.c **** 			{
1263:FreeRTOS/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1264:FreeRTOS/queue.c **** 				{
1265:FreeRTOS/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1266:FreeRTOS/queue.c **** 					{
1267:FreeRTOS/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
1268:FreeRTOS/queue.c **** 						{
1269:FreeRTOS/queue.c **** 							/* The semaphore is a member of a queue set, and
1270:FreeRTOS/queue.c **** 							posting	to the queue set caused a higher priority
1271:FreeRTOS/queue.c **** 							task to	unblock.  A context switch is required. */
1272:FreeRTOS/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1273:FreeRTOS/queue.c **** 							{
1274:FreeRTOS/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1275:FreeRTOS/queue.c **** 							}
1276:FreeRTOS/queue.c **** 							else
1277:FreeRTOS/queue.c **** 							{
1278:FreeRTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1279:FreeRTOS/queue.c **** 							}
1280:FreeRTOS/queue.c **** 						}
1281:FreeRTOS/queue.c **** 						else
1282:FreeRTOS/queue.c **** 						{
1283:FreeRTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1284:FreeRTOS/queue.c **** 						}
1285:FreeRTOS/queue.c **** 					}
1286:FreeRTOS/queue.c **** 					else
1287:FreeRTOS/queue.c **** 					{
1288:FreeRTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1289:FreeRTOS/queue.c **** 						{
1290:FreeRTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1291:FreeRTOS/queue.c **** 							{
1292:FreeRTOS/queue.c **** 								/* The task waiting has a higher priority so
1293:FreeRTOS/queue.c **** 								record that a context switch is required. */
1294:FreeRTOS/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1295:FreeRTOS/queue.c **** 								{
1296:FreeRTOS/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1297:FreeRTOS/queue.c **** 								}
1298:FreeRTOS/queue.c **** 								else
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 39


1299:FreeRTOS/queue.c **** 								{
1300:FreeRTOS/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1301:FreeRTOS/queue.c **** 								}
1302:FreeRTOS/queue.c **** 							}
1303:FreeRTOS/queue.c **** 							else
1304:FreeRTOS/queue.c **** 							{
1305:FreeRTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1306:FreeRTOS/queue.c **** 							}
1307:FreeRTOS/queue.c **** 						}
1308:FreeRTOS/queue.c **** 						else
1309:FreeRTOS/queue.c **** 						{
1310:FreeRTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1311:FreeRTOS/queue.c **** 						}
1312:FreeRTOS/queue.c **** 					}
1313:FreeRTOS/queue.c **** 				}
1314:FreeRTOS/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1315:FreeRTOS/queue.c **** 				{
1316:FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 869              		.loc 1 1316 0
 870 0034 3B69     		ldr	r3, [r7, #16]
 871 0036 5B6A     		ldr	r3, [r3, #36]
 872 0038 002B     		cmp	r3, #0
 873 003a 13D0     		beq	.L54
1317:FreeRTOS/queue.c **** 					{
1318:FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 874              		.loc 1 1318 0
 875 003c 3B69     		ldr	r3, [r7, #16]
 876 003e 2433     		adds	r3, r3, #36
 877 0040 1846     		mov	r0, r3
 878 0042 FFF7FEFF 		bl	xTaskRemoveFromEventList
 879 0046 0346     		mov	r3, r0
 880 0048 002B     		cmp	r3, #0
 881 004a 0BD0     		beq	.L54
1319:FreeRTOS/queue.c **** 						{
1320:FreeRTOS/queue.c **** 							/* The task waiting has a higher priority so record that a
1321:FreeRTOS/queue.c **** 							context	switch is required. */
1322:FreeRTOS/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 882              		.loc 1 1322 0
 883 004c 3B68     		ldr	r3, [r7]
 884 004e 002B     		cmp	r3, #0
 885 0050 08D0     		beq	.L54
1323:FreeRTOS/queue.c **** 							{
1324:FreeRTOS/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 886              		.loc 1 1324 0
 887 0052 3B68     		ldr	r3, [r7]
 888 0054 0122     		movs	r2, #1
 889 0056 1A60     		str	r2, [r3]
 890 0058 04E0     		b	.L54
 891              	.L53:
1325:FreeRTOS/queue.c **** 							}
1326:FreeRTOS/queue.c **** 							else
1327:FreeRTOS/queue.c **** 							{
1328:FreeRTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1329:FreeRTOS/queue.c **** 							}
1330:FreeRTOS/queue.c **** 						}
1331:FreeRTOS/queue.c **** 						else
1332:FreeRTOS/queue.c **** 						{
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 40


1333:FreeRTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1334:FreeRTOS/queue.c **** 						}
1335:FreeRTOS/queue.c **** 					}
1336:FreeRTOS/queue.c **** 					else
1337:FreeRTOS/queue.c **** 					{
1338:FreeRTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1339:FreeRTOS/queue.c **** 					}
1340:FreeRTOS/queue.c **** 				}
1341:FreeRTOS/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1342:FreeRTOS/queue.c **** 			}
1343:FreeRTOS/queue.c **** 			else
1344:FreeRTOS/queue.c **** 			{
1345:FreeRTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1346:FreeRTOS/queue.c **** 				knows that data was posted while it was locked. */
1347:FreeRTOS/queue.c **** 				++( pxQueue->xTxLock );
 892              		.loc 1 1347 0
 893 005a 3B69     		ldr	r3, [r7, #16]
 894 005c 9B6C     		ldr	r3, [r3, #72]
 895 005e 5A1C     		adds	r2, r3, #1
 896 0060 3B69     		ldr	r3, [r7, #16]
 897 0062 9A64     		str	r2, [r3, #72]
 898              	.L54:
1348:FreeRTOS/queue.c **** 			}
1349:FreeRTOS/queue.c **** 
1350:FreeRTOS/queue.c **** 			xReturn = pdPASS;
 899              		.loc 1 1350 0
 900 0064 0123     		movs	r3, #1
 901 0066 7B61     		str	r3, [r7, #20]
 902 0068 01E0     		b	.L55
 903              	.L52:
1351:FreeRTOS/queue.c **** 		}
1352:FreeRTOS/queue.c **** 		else
1353:FreeRTOS/queue.c **** 		{
1354:FreeRTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1355:FreeRTOS/queue.c **** 			xReturn = errQUEUE_FULL;
 904              		.loc 1 1355 0
 905 006a 0023     		movs	r3, #0
 906 006c 7B61     		str	r3, [r7, #20]
 907              	.L55:
1356:FreeRTOS/queue.c **** 		}
1357:FreeRTOS/queue.c **** 	}
1358:FreeRTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 908              		.loc 1 1358 0
 909 006e F868     		ldr	r0, [r7, #12]
 910 0070 FFF7FEFF 		bl	vPortClearInterruptMask
1359:FreeRTOS/queue.c **** 
1360:FreeRTOS/queue.c **** 	return xReturn;
 911              		.loc 1 1360 0
 912 0074 7B69     		ldr	r3, [r7, #20]
1361:FreeRTOS/queue.c **** }
 913              		.loc 1 1361 0
 914 0076 1846     		mov	r0, r3
 915 0078 1837     		adds	r7, r7, #24
 916              		.cfi_def_cfa_offset 8
 917 007a BD46     		mov	sp, r7
 918              		.cfi_def_cfa_register 13
 919              		@ sp needed
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 41


 920 007c 80BD     		pop	{r7, pc}
 921              		.cfi_endproc
 922              	.LFE72:
 923              		.size	xQueueGiveFromISR, .-xQueueGiveFromISR
 924 007e 00BF     		.section	.text.xQueueGenericReceive,"ax",%progbits
 925              		.align	2
 926              		.global	xQueueGenericReceive
 927              		.thumb
 928              		.thumb_func
 929              		.type	xQueueGenericReceive, %function
 930              	xQueueGenericReceive:
 931              	.LFB73:
1362:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1363:FreeRTOS/queue.c **** 
1364:FreeRTOS/queue.c **** BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWa
1365:FreeRTOS/queue.c **** {
 932              		.loc 1 1365 0
 933              		.cfi_startproc
 934              		@ args = 0, pretend = 0, frame = 40
 935              		@ frame_needed = 1, uses_anonymous_args = 0
 936 0000 80B5     		push	{r7, lr}
 937              		.cfi_def_cfa_offset 8
 938              		.cfi_offset 7, -8
 939              		.cfi_offset 14, -4
 940 0002 8AB0     		sub	sp, sp, #40
 941              		.cfi_def_cfa_offset 48
 942 0004 00AF     		add	r7, sp, #0
 943              		.cfi_def_cfa_register 7
 944 0006 F860     		str	r0, [r7, #12]
 945 0008 B960     		str	r1, [r7, #8]
 946 000a 7A60     		str	r2, [r7, #4]
 947 000c 3B60     		str	r3, [r7]
1366:FreeRTOS/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 948              		.loc 1 1366 0
 949 000e 0023     		movs	r3, #0
 950 0010 7B62     		str	r3, [r7, #36]
1367:FreeRTOS/queue.c **** TimeOut_t xTimeOut;
1368:FreeRTOS/queue.c **** int8_t *pcOriginalReadPosition;
1369:FreeRTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 951              		.loc 1 1369 0
 952 0012 FB68     		ldr	r3, [r7, #12]
 953 0014 3B62     		str	r3, [r7, #32]
 954              	.L72:
1370:FreeRTOS/queue.c **** 
1371:FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1372:FreeRTOS/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1373:FreeRTOS/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1374:FreeRTOS/queue.c **** 	{
1375:FreeRTOS/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1376:FreeRTOS/queue.c **** 	}
1377:FreeRTOS/queue.c **** 	#endif
1378:FreeRTOS/queue.c **** 
1379:FreeRTOS/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1380:FreeRTOS/queue.c **** 	statements within the function itself.  This is done in the interest
1381:FreeRTOS/queue.c **** 	of execution time efficiency. */
1382:FreeRTOS/queue.c **** 
1383:FreeRTOS/queue.c **** 	for( ;; )
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 42


1384:FreeRTOS/queue.c **** 	{
1385:FreeRTOS/queue.c **** 		taskENTER_CRITICAL();
 955              		.loc 1 1385 0
 956 0016 FFF7FEFF 		bl	vPortEnterCritical
1386:FreeRTOS/queue.c **** 		{
1387:FreeRTOS/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1388:FreeRTOS/queue.c **** 			must be	the highest priority task wanting to access the queue. */
1389:FreeRTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 957              		.loc 1 1389 0
 958 001a 3B6A     		ldr	r3, [r7, #32]
 959 001c 9B6B     		ldr	r3, [r3, #56]
 960 001e 002B     		cmp	r3, #0
 961 0020 3BD0     		beq	.L58
1390:FreeRTOS/queue.c **** 			{
1391:FreeRTOS/queue.c **** 				/* Remember the read position in case the queue is only being
1392:FreeRTOS/queue.c **** 				peeked. */
1393:FreeRTOS/queue.c **** 				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 962              		.loc 1 1393 0
 963 0022 3B6A     		ldr	r3, [r7, #32]
 964 0024 DB68     		ldr	r3, [r3, #12]
 965 0026 FB61     		str	r3, [r7, #28]
1394:FreeRTOS/queue.c **** 
1395:FreeRTOS/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 966              		.loc 1 1395 0
 967 0028 B968     		ldr	r1, [r7, #8]
 968 002a 386A     		ldr	r0, [r7, #32]
 969 002c FFF7FEFF 		bl	prvCopyDataFromQueue
1396:FreeRTOS/queue.c **** 
1397:FreeRTOS/queue.c **** 				if( xJustPeeking == pdFALSE )
 970              		.loc 1 1397 0
 971 0030 3B68     		ldr	r3, [r7]
 972 0032 002B     		cmp	r3, #0
 973 0034 1CD1     		bne	.L59
1398:FreeRTOS/queue.c **** 				{
1399:FreeRTOS/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
1400:FreeRTOS/queue.c **** 
1401:FreeRTOS/queue.c **** 					/* Actually removing data, not just peeking. */
1402:FreeRTOS/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 974              		.loc 1 1402 0
 975 0036 3B6A     		ldr	r3, [r7, #32]
 976 0038 9B6B     		ldr	r3, [r3, #56]
 977 003a 5A1E     		subs	r2, r3, #1
 978 003c 3B6A     		ldr	r3, [r7, #32]
 979 003e 9A63     		str	r2, [r3, #56]
1403:FreeRTOS/queue.c **** 
1404:FreeRTOS/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
1405:FreeRTOS/queue.c **** 					{
1406:FreeRTOS/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 980              		.loc 1 1406 0
 981 0040 3B6A     		ldr	r3, [r7, #32]
 982 0042 1B68     		ldr	r3, [r3]
 983 0044 002B     		cmp	r3, #0
 984 0046 04D1     		bne	.L60
1407:FreeRTOS/queue.c **** 						{
1408:FreeRTOS/queue.c **** 							/* Record the information required to implement
1409:FreeRTOS/queue.c **** 							priority inheritance should it become necessary. */
1410:FreeRTOS/queue.c **** 							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is 
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 43


 985              		.loc 1 1410 0
 986 0048 FFF7FEFF 		bl	pvTaskIncrementMutexHeldCount
 987 004c 0246     		mov	r2, r0
 988 004e 3B6A     		ldr	r3, [r7, #32]
 989 0050 5A60     		str	r2, [r3, #4]
 990              	.L60:
1411:FreeRTOS/queue.c **** 						}
1412:FreeRTOS/queue.c **** 						else
1413:FreeRTOS/queue.c **** 						{
1414:FreeRTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1415:FreeRTOS/queue.c **** 						}
1416:FreeRTOS/queue.c **** 					}
1417:FreeRTOS/queue.c **** 					#endif /* configUSE_MUTEXES */
1418:FreeRTOS/queue.c **** 
1419:FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 991              		.loc 1 1419 0
 992 0052 3B6A     		ldr	r3, [r7, #32]
 993 0054 1B69     		ldr	r3, [r3, #16]
 994 0056 002B     		cmp	r3, #0
 995 0058 1BD0     		beq	.L61
1420:FreeRTOS/queue.c **** 					{
1421:FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 996              		.loc 1 1421 0
 997 005a 3B6A     		ldr	r3, [r7, #32]
 998 005c 1033     		adds	r3, r3, #16
 999 005e 1846     		mov	r0, r3
 1000 0060 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1001 0064 0346     		mov	r3, r0
 1002 0066 012B     		cmp	r3, #1
 1003 0068 13D1     		bne	.L61
1422:FreeRTOS/queue.c **** 						{
1423:FreeRTOS/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 1004              		.loc 1 1423 0
 1005 006a FFF7FEFF 		bl	vPortYield
 1006 006e 10E0     		b	.L61
 1007              	.L59:
1424:FreeRTOS/queue.c **** 						}
1425:FreeRTOS/queue.c **** 						else
1426:FreeRTOS/queue.c **** 						{
1427:FreeRTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1428:FreeRTOS/queue.c **** 						}
1429:FreeRTOS/queue.c **** 					}
1430:FreeRTOS/queue.c **** 					else
1431:FreeRTOS/queue.c **** 					{
1432:FreeRTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1433:FreeRTOS/queue.c **** 					}
1434:FreeRTOS/queue.c **** 				}
1435:FreeRTOS/queue.c **** 				else
1436:FreeRTOS/queue.c **** 				{
1437:FreeRTOS/queue.c **** 					traceQUEUE_PEEK( pxQueue );
1438:FreeRTOS/queue.c **** 
1439:FreeRTOS/queue.c **** 					/* The data is not being removed, so reset the read
1440:FreeRTOS/queue.c **** 					pointer. */
1441:FreeRTOS/queue.c **** 					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1008              		.loc 1 1441 0
 1009 0070 3B6A     		ldr	r3, [r7, #32]
 1010 0072 FA69     		ldr	r2, [r7, #28]
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 44


 1011 0074 DA60     		str	r2, [r3, #12]
1442:FreeRTOS/queue.c **** 
1443:FreeRTOS/queue.c **** 					/* The data is being left in the queue, so see if there are
1444:FreeRTOS/queue.c **** 					any other tasks waiting for the data. */
1445:FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1012              		.loc 1 1445 0
 1013 0076 3B6A     		ldr	r3, [r7, #32]
 1014 0078 5B6A     		ldr	r3, [r3, #36]
 1015 007a 002B     		cmp	r3, #0
 1016 007c 09D0     		beq	.L61
1446:FreeRTOS/queue.c **** 					{
1447:FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1017              		.loc 1 1447 0
 1018 007e 3B6A     		ldr	r3, [r7, #32]
 1019 0080 2433     		adds	r3, r3, #36
 1020 0082 1846     		mov	r0, r3
 1021 0084 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1022 0088 0346     		mov	r3, r0
 1023 008a 002B     		cmp	r3, #0
 1024 008c 01D0     		beq	.L61
1448:FreeRTOS/queue.c **** 						{
1449:FreeRTOS/queue.c **** 							/* The task waiting has a higher priority than this task. */
1450:FreeRTOS/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 1025              		.loc 1 1450 0
 1026 008e FFF7FEFF 		bl	vPortYield
 1027              	.L61:
1451:FreeRTOS/queue.c **** 						}
1452:FreeRTOS/queue.c **** 						else
1453:FreeRTOS/queue.c **** 						{
1454:FreeRTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1455:FreeRTOS/queue.c **** 						}
1456:FreeRTOS/queue.c **** 					}
1457:FreeRTOS/queue.c **** 					else
1458:FreeRTOS/queue.c **** 					{
1459:FreeRTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1460:FreeRTOS/queue.c **** 					}
1461:FreeRTOS/queue.c **** 				}
1462:FreeRTOS/queue.c **** 
1463:FreeRTOS/queue.c **** 				taskEXIT_CRITICAL();
 1028              		.loc 1 1463 0
 1029 0092 FFF7FEFF 		bl	vPortExitCritical
1464:FreeRTOS/queue.c **** 				return pdPASS;
 1030              		.loc 1 1464 0
 1031 0096 0123     		movs	r3, #1
 1032 0098 64E0     		b	.L73
 1033              	.L58:
1465:FreeRTOS/queue.c **** 			}
1466:FreeRTOS/queue.c **** 			else
1467:FreeRTOS/queue.c **** 			{
1468:FreeRTOS/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 1034              		.loc 1 1468 0
 1035 009a 7B68     		ldr	r3, [r7, #4]
 1036 009c 002B     		cmp	r3, #0
 1037 009e 03D1     		bne	.L63
1469:FreeRTOS/queue.c **** 				{
1470:FreeRTOS/queue.c **** 					/* The queue was empty and no block time is specified (or
1471:FreeRTOS/queue.c **** 					the block time has expired) so leave now. */
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 45


1472:FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 1038              		.loc 1 1472 0
 1039 00a0 FFF7FEFF 		bl	vPortExitCritical
1473:FreeRTOS/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1474:FreeRTOS/queue.c **** 					return errQUEUE_EMPTY;
 1040              		.loc 1 1474 0
 1041 00a4 0023     		movs	r3, #0
 1042 00a6 5DE0     		b	.L73
 1043              	.L63:
1475:FreeRTOS/queue.c **** 				}
1476:FreeRTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1044              		.loc 1 1476 0
 1045 00a8 7B6A     		ldr	r3, [r7, #36]
 1046 00aa 002B     		cmp	r3, #0
 1047 00ac 06D1     		bne	.L64
1477:FreeRTOS/queue.c **** 				{
1478:FreeRTOS/queue.c **** 					/* The queue was empty and a block time was specified so
1479:FreeRTOS/queue.c **** 					configure the timeout structure. */
1480:FreeRTOS/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 1048              		.loc 1 1480 0
 1049 00ae 07F11403 		add	r3, r7, #20
 1050 00b2 1846     		mov	r0, r3
 1051 00b4 FFF7FEFF 		bl	vTaskSetTimeOutState
1481:FreeRTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 1052              		.loc 1 1481 0
 1053 00b8 0123     		movs	r3, #1
 1054 00ba 7B62     		str	r3, [r7, #36]
 1055              	.L64:
1482:FreeRTOS/queue.c **** 				}
1483:FreeRTOS/queue.c **** 				else
1484:FreeRTOS/queue.c **** 				{
1485:FreeRTOS/queue.c **** 					/* Entry time was already set. */
1486:FreeRTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1487:FreeRTOS/queue.c **** 				}
1488:FreeRTOS/queue.c **** 			}
1489:FreeRTOS/queue.c **** 		}
1490:FreeRTOS/queue.c **** 		taskEXIT_CRITICAL();
 1056              		.loc 1 1490 0
 1057 00bc FFF7FEFF 		bl	vPortExitCritical
1491:FreeRTOS/queue.c **** 
1492:FreeRTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1493:FreeRTOS/queue.c **** 		now the critical section has been exited. */
1494:FreeRTOS/queue.c **** 
1495:FreeRTOS/queue.c **** 		vTaskSuspendAll();
 1058              		.loc 1 1495 0
 1059 00c0 FFF7FEFF 		bl	vTaskSuspendAll
1496:FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 1060              		.loc 1 1496 0
 1061 00c4 FFF7FEFF 		bl	vPortEnterCritical
 1062 00c8 3B6A     		ldr	r3, [r7, #32]
 1063 00ca 5B6C     		ldr	r3, [r3, #68]
 1064 00cc B3F1FF3F 		cmp	r3, #-1
 1065 00d0 02D1     		bne	.L65
 1066              		.loc 1 1496 0 is_stmt 0 discriminator 1
 1067 00d2 3B6A     		ldr	r3, [r7, #32]
 1068 00d4 0022     		movs	r2, #0
 1069 00d6 5A64     		str	r2, [r3, #68]
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 46


 1070              	.L65:
 1071              		.loc 1 1496 0 discriminator 3
 1072 00d8 3B6A     		ldr	r3, [r7, #32]
 1073 00da 9B6C     		ldr	r3, [r3, #72]
 1074 00dc B3F1FF3F 		cmp	r3, #-1
 1075 00e0 02D1     		bne	.L66
 1076              		.loc 1 1496 0 discriminator 4
 1077 00e2 3B6A     		ldr	r3, [r7, #32]
 1078 00e4 0022     		movs	r2, #0
 1079 00e6 9A64     		str	r2, [r3, #72]
 1080              	.L66:
 1081              		.loc 1 1496 0 discriminator 6
 1082 00e8 FFF7FEFF 		bl	vPortExitCritical
1497:FreeRTOS/queue.c **** 
1498:FreeRTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1499:FreeRTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1083              		.loc 1 1499 0 is_stmt 1 discriminator 6
 1084 00ec 3A1D     		adds	r2, r7, #4
 1085 00ee 07F11403 		add	r3, r7, #20
 1086 00f2 1146     		mov	r1, r2
 1087 00f4 1846     		mov	r0, r3
 1088 00f6 FFF7FEFF 		bl	xTaskCheckForTimeOut
 1089 00fa 0346     		mov	r3, r0
 1090 00fc 002B     		cmp	r3, #0
 1091 00fe 2BD1     		bne	.L67
1500:FreeRTOS/queue.c **** 		{
1501:FreeRTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1092              		.loc 1 1501 0
 1093 0100 386A     		ldr	r0, [r7, #32]
 1094 0102 FFF7FEFF 		bl	prvIsQueueEmpty
 1095 0106 0346     		mov	r3, r0
 1096 0108 002B     		cmp	r3, #0
 1097 010a 1FD0     		beq	.L68
1502:FreeRTOS/queue.c **** 			{
1503:FreeRTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1504:FreeRTOS/queue.c **** 
1505:FreeRTOS/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1506:FreeRTOS/queue.c **** 				{
1507:FreeRTOS/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1098              		.loc 1 1507 0
 1099 010c 3B6A     		ldr	r3, [r7, #32]
 1100 010e 1B68     		ldr	r3, [r3]
 1101 0110 002B     		cmp	r3, #0
 1102 0112 08D1     		bne	.L69
1508:FreeRTOS/queue.c **** 					{
1509:FreeRTOS/queue.c **** 						taskENTER_CRITICAL();
 1103              		.loc 1 1509 0
 1104 0114 FFF7FEFF 		bl	vPortEnterCritical
1510:FreeRTOS/queue.c **** 						{
1511:FreeRTOS/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 1105              		.loc 1 1511 0
 1106 0118 3B6A     		ldr	r3, [r7, #32]
 1107 011a 5B68     		ldr	r3, [r3, #4]
 1108 011c 1846     		mov	r0, r3
 1109 011e FFF7FEFF 		bl	vTaskPriorityInherit
1512:FreeRTOS/queue.c **** 						}
1513:FreeRTOS/queue.c **** 						taskEXIT_CRITICAL();
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 47


 1110              		.loc 1 1513 0
 1111 0122 FFF7FEFF 		bl	vPortExitCritical
 1112              	.L69:
1514:FreeRTOS/queue.c **** 					}
1515:FreeRTOS/queue.c **** 					else
1516:FreeRTOS/queue.c **** 					{
1517:FreeRTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1518:FreeRTOS/queue.c **** 					}
1519:FreeRTOS/queue.c **** 				}
1520:FreeRTOS/queue.c **** 				#endif
1521:FreeRTOS/queue.c **** 
1522:FreeRTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1113              		.loc 1 1522 0
 1114 0126 3B6A     		ldr	r3, [r7, #32]
 1115 0128 2433     		adds	r3, r3, #36
 1116 012a 7A68     		ldr	r2, [r7, #4]
 1117 012c 1146     		mov	r1, r2
 1118 012e 1846     		mov	r0, r3
 1119 0130 FFF7FEFF 		bl	vTaskPlaceOnEventList
1523:FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 1120              		.loc 1 1523 0
 1121 0134 386A     		ldr	r0, [r7, #32]
 1122 0136 FFF7FEFF 		bl	prvUnlockQueue
1524:FreeRTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1123              		.loc 1 1524 0
 1124 013a FFF7FEFF 		bl	xTaskResumeAll
 1125 013e 0346     		mov	r3, r0
 1126 0140 002B     		cmp	r3, #0
 1127 0142 7FF468AF 		bne	.L72
1525:FreeRTOS/queue.c **** 				{
1526:FreeRTOS/queue.c **** 					portYIELD_WITHIN_API();
 1128              		.loc 1 1526 0
 1129 0146 FFF7FEFF 		bl	vPortYield
 1130 014a 64E7     		b	.L72
 1131              	.L68:
1527:FreeRTOS/queue.c **** 				}
1528:FreeRTOS/queue.c **** 				else
1529:FreeRTOS/queue.c **** 				{
1530:FreeRTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1531:FreeRTOS/queue.c **** 				}
1532:FreeRTOS/queue.c **** 			}
1533:FreeRTOS/queue.c **** 			else
1534:FreeRTOS/queue.c **** 			{
1535:FreeRTOS/queue.c **** 				/* Try again. */
1536:FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 1132              		.loc 1 1536 0
 1133 014c 386A     		ldr	r0, [r7, #32]
 1134 014e FFF7FEFF 		bl	prvUnlockQueue
1537:FreeRTOS/queue.c **** 				( void ) xTaskResumeAll();
 1135              		.loc 1 1537 0
 1136 0152 FFF7FEFF 		bl	xTaskResumeAll
 1137 0156 5EE7     		b	.L72
 1138              	.L67:
1538:FreeRTOS/queue.c **** 			}
1539:FreeRTOS/queue.c **** 		}
1540:FreeRTOS/queue.c **** 		else
1541:FreeRTOS/queue.c **** 		{
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 48


1542:FreeRTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 1139              		.loc 1 1542 0
 1140 0158 386A     		ldr	r0, [r7, #32]
 1141 015a FFF7FEFF 		bl	prvUnlockQueue
1543:FreeRTOS/queue.c **** 			( void ) xTaskResumeAll();
 1142              		.loc 1 1543 0
 1143 015e FFF7FEFF 		bl	xTaskResumeAll
1544:FreeRTOS/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
1545:FreeRTOS/queue.c **** 			return errQUEUE_EMPTY;
 1144              		.loc 1 1545 0
 1145 0162 0023     		movs	r3, #0
 1146              	.L73:
1546:FreeRTOS/queue.c **** 		}
1547:FreeRTOS/queue.c **** 	}
1548:FreeRTOS/queue.c **** }
 1147              		.loc 1 1548 0 discriminator 4
 1148 0164 1846     		mov	r0, r3
 1149 0166 2837     		adds	r7, r7, #40
 1150              		.cfi_def_cfa_offset 8
 1151 0168 BD46     		mov	sp, r7
 1152              		.cfi_def_cfa_register 13
 1153              		@ sp needed
 1154 016a 80BD     		pop	{r7, pc}
 1155              		.cfi_endproc
 1156              	.LFE73:
 1157              		.size	xQueueGenericReceive, .-xQueueGenericReceive
 1158              		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 1159              		.align	2
 1160              		.global	xQueueReceiveFromISR
 1161              		.thumb
 1162              		.thumb_func
 1163              		.type	xQueueReceiveFromISR, %function
 1164              	xQueueReceiveFromISR:
 1165              	.LFB74:
1549:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1550:FreeRTOS/queue.c **** 
1551:FreeRTOS/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1552:FreeRTOS/queue.c **** {
 1166              		.loc 1 1552 0
 1167              		.cfi_startproc
 1168              		@ args = 0, pretend = 0, frame = 32
 1169              		@ frame_needed = 1, uses_anonymous_args = 0
 1170 0000 80B5     		push	{r7, lr}
 1171              		.cfi_def_cfa_offset 8
 1172              		.cfi_offset 7, -8
 1173              		.cfi_offset 14, -4
 1174 0002 88B0     		sub	sp, sp, #32
 1175              		.cfi_def_cfa_offset 40
 1176 0004 00AF     		add	r7, sp, #0
 1177              		.cfi_def_cfa_register 7
 1178 0006 F860     		str	r0, [r7, #12]
 1179 0008 B960     		str	r1, [r7, #8]
 1180 000a 7A60     		str	r2, [r7, #4]
1553:FreeRTOS/queue.c **** BaseType_t xReturn;
1554:FreeRTOS/queue.c **** UBaseType_t uxSavedInterruptStatus;
1555:FreeRTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1181              		.loc 1 1555 0
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 49


 1182 000c FB68     		ldr	r3, [r7, #12]
 1183 000e BB61     		str	r3, [r7, #24]
1556:FreeRTOS/queue.c **** 
1557:FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1558:FreeRTOS/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1559:FreeRTOS/queue.c **** 
1560:FreeRTOS/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1561:FreeRTOS/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1562:FreeRTOS/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1563:FreeRTOS/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1564:FreeRTOS/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1565:FreeRTOS/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1566:FreeRTOS/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1567:FreeRTOS/queue.c **** 	assigned a priority above the configured maximum system call priority.
1568:FreeRTOS/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1569:FreeRTOS/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1570:FreeRTOS/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1571:FreeRTOS/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1572:FreeRTOS/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1573:FreeRTOS/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1574:FreeRTOS/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1575:FreeRTOS/queue.c **** 
1576:FreeRTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1184              		.loc 1 1576 0
 1185 0010 FFF7FEFF 		bl	ulPortSetInterruptMask
 1186 0014 7861     		str	r0, [r7, #20]
1577:FreeRTOS/queue.c **** 	{
1578:FreeRTOS/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1579:FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1187              		.loc 1 1579 0
 1188 0016 BB69     		ldr	r3, [r7, #24]
 1189 0018 9B6B     		ldr	r3, [r3, #56]
 1190 001a 002B     		cmp	r3, #0
 1191 001c 28D0     		beq	.L75
1580:FreeRTOS/queue.c **** 		{
1581:FreeRTOS/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1582:FreeRTOS/queue.c **** 
1583:FreeRTOS/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1192              		.loc 1 1583 0
 1193 001e B968     		ldr	r1, [r7, #8]
 1194 0020 B869     		ldr	r0, [r7, #24]
 1195 0022 FFF7FEFF 		bl	prvCopyDataFromQueue
1584:FreeRTOS/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 1196              		.loc 1 1584 0
 1197 0026 BB69     		ldr	r3, [r7, #24]
 1198 0028 9B6B     		ldr	r3, [r3, #56]
 1199 002a 5A1E     		subs	r2, r3, #1
 1200 002c BB69     		ldr	r3, [r7, #24]
 1201 002e 9A63     		str	r2, [r3, #56]
1585:FreeRTOS/queue.c **** 
1586:FreeRTOS/queue.c **** 			/* If the queue is locked the event list will not be modified.
1587:FreeRTOS/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1588:FreeRTOS/queue.c **** 			will know that an ISR has removed data while the queue was
1589:FreeRTOS/queue.c **** 			locked. */
1590:FreeRTOS/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
 1202              		.loc 1 1590 0
 1203 0030 BB69     		ldr	r3, [r7, #24]
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 50


 1204 0032 5B6C     		ldr	r3, [r3, #68]
 1205 0034 B3F1FF3F 		cmp	r3, #-1
 1206 0038 12D1     		bne	.L76
1591:FreeRTOS/queue.c **** 			{
1592:FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1207              		.loc 1 1592 0
 1208 003a BB69     		ldr	r3, [r7, #24]
 1209 003c 1B69     		ldr	r3, [r3, #16]
 1210 003e 002B     		cmp	r3, #0
 1211 0040 13D0     		beq	.L77
1593:FreeRTOS/queue.c **** 				{
1594:FreeRTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1212              		.loc 1 1594 0
 1213 0042 BB69     		ldr	r3, [r7, #24]
 1214 0044 1033     		adds	r3, r3, #16
 1215 0046 1846     		mov	r0, r3
 1216 0048 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1217 004c 0346     		mov	r3, r0
 1218 004e 002B     		cmp	r3, #0
 1219 0050 0BD0     		beq	.L77
1595:FreeRTOS/queue.c **** 					{
1596:FreeRTOS/queue.c **** 						/* The task waiting has a higher priority than us so
1597:FreeRTOS/queue.c **** 						force a context switch. */
1598:FreeRTOS/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
 1220              		.loc 1 1598 0
 1221 0052 7B68     		ldr	r3, [r7, #4]
 1222 0054 002B     		cmp	r3, #0
 1223 0056 08D0     		beq	.L77
1599:FreeRTOS/queue.c **** 						{
1600:FreeRTOS/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
 1224              		.loc 1 1600 0
 1225 0058 7B68     		ldr	r3, [r7, #4]
 1226 005a 0122     		movs	r2, #1
 1227 005c 1A60     		str	r2, [r3]
 1228 005e 04E0     		b	.L77
 1229              	.L76:
1601:FreeRTOS/queue.c **** 						}
1602:FreeRTOS/queue.c **** 						else
1603:FreeRTOS/queue.c **** 						{
1604:FreeRTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1605:FreeRTOS/queue.c **** 						}
1606:FreeRTOS/queue.c **** 					}
1607:FreeRTOS/queue.c **** 					else
1608:FreeRTOS/queue.c **** 					{
1609:FreeRTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1610:FreeRTOS/queue.c **** 					}
1611:FreeRTOS/queue.c **** 				}
1612:FreeRTOS/queue.c **** 				else
1613:FreeRTOS/queue.c **** 				{
1614:FreeRTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1615:FreeRTOS/queue.c **** 				}
1616:FreeRTOS/queue.c **** 			}
1617:FreeRTOS/queue.c **** 			else
1618:FreeRTOS/queue.c **** 			{
1619:FreeRTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1620:FreeRTOS/queue.c **** 				knows that data was removed while it was locked. */
1621:FreeRTOS/queue.c **** 				++( pxQueue->xRxLock );
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 51


 1230              		.loc 1 1621 0
 1231 0060 BB69     		ldr	r3, [r7, #24]
 1232 0062 5B6C     		ldr	r3, [r3, #68]
 1233 0064 5A1C     		adds	r2, r3, #1
 1234 0066 BB69     		ldr	r3, [r7, #24]
 1235 0068 5A64     		str	r2, [r3, #68]
 1236              	.L77:
1622:FreeRTOS/queue.c **** 			}
1623:FreeRTOS/queue.c **** 
1624:FreeRTOS/queue.c **** 			xReturn = pdPASS;
 1237              		.loc 1 1624 0
 1238 006a 0123     		movs	r3, #1
 1239 006c FB61     		str	r3, [r7, #28]
 1240 006e 01E0     		b	.L78
 1241              	.L75:
1625:FreeRTOS/queue.c **** 		}
1626:FreeRTOS/queue.c **** 		else
1627:FreeRTOS/queue.c **** 		{
1628:FreeRTOS/queue.c **** 			xReturn = pdFAIL;
 1242              		.loc 1 1628 0
 1243 0070 0023     		movs	r3, #0
 1244 0072 FB61     		str	r3, [r7, #28]
 1245              	.L78:
1629:FreeRTOS/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1630:FreeRTOS/queue.c **** 		}
1631:FreeRTOS/queue.c **** 	}
1632:FreeRTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1246              		.loc 1 1632 0
 1247 0074 7869     		ldr	r0, [r7, #20]
 1248 0076 FFF7FEFF 		bl	vPortClearInterruptMask
1633:FreeRTOS/queue.c **** 
1634:FreeRTOS/queue.c **** 	return xReturn;
 1249              		.loc 1 1634 0
 1250 007a FB69     		ldr	r3, [r7, #28]
1635:FreeRTOS/queue.c **** }
 1251              		.loc 1 1635 0
 1252 007c 1846     		mov	r0, r3
 1253 007e 2037     		adds	r7, r7, #32
 1254              		.cfi_def_cfa_offset 8
 1255 0080 BD46     		mov	sp, r7
 1256              		.cfi_def_cfa_register 13
 1257              		@ sp needed
 1258 0082 80BD     		pop	{r7, pc}
 1259              		.cfi_endproc
 1260              	.LFE74:
 1261              		.size	xQueueReceiveFromISR, .-xQueueReceiveFromISR
 1262              		.section	.text.xQueuePeekFromISR,"ax",%progbits
 1263              		.align	2
 1264              		.global	xQueuePeekFromISR
 1265              		.thumb
 1266              		.thumb_func
 1267              		.type	xQueuePeekFromISR, %function
 1268              	xQueuePeekFromISR:
 1269              	.LFB75:
1636:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1637:FreeRTOS/queue.c **** 
1638:FreeRTOS/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 52


1639:FreeRTOS/queue.c **** {
 1270              		.loc 1 1639 0
 1271              		.cfi_startproc
 1272              		@ args = 0, pretend = 0, frame = 24
 1273              		@ frame_needed = 1, uses_anonymous_args = 0
 1274 0000 80B5     		push	{r7, lr}
 1275              		.cfi_def_cfa_offset 8
 1276              		.cfi_offset 7, -8
 1277              		.cfi_offset 14, -4
 1278 0002 86B0     		sub	sp, sp, #24
 1279              		.cfi_def_cfa_offset 32
 1280 0004 00AF     		add	r7, sp, #0
 1281              		.cfi_def_cfa_register 7
 1282 0006 7860     		str	r0, [r7, #4]
 1283 0008 3960     		str	r1, [r7]
1640:FreeRTOS/queue.c **** BaseType_t xReturn;
1641:FreeRTOS/queue.c **** UBaseType_t uxSavedInterruptStatus;
1642:FreeRTOS/queue.c **** int8_t *pcOriginalReadPosition;
1643:FreeRTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1284              		.loc 1 1643 0
 1285 000a 7B68     		ldr	r3, [r7, #4]
 1286 000c 3B61     		str	r3, [r7, #16]
1644:FreeRTOS/queue.c **** 
1645:FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1646:FreeRTOS/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1647:FreeRTOS/queue.c **** 	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1648:FreeRTOS/queue.c **** 
1649:FreeRTOS/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1650:FreeRTOS/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1651:FreeRTOS/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1652:FreeRTOS/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1653:FreeRTOS/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1654:FreeRTOS/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1655:FreeRTOS/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1656:FreeRTOS/queue.c **** 	assigned a priority above the configured maximum system call priority.
1657:FreeRTOS/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1658:FreeRTOS/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1659:FreeRTOS/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1660:FreeRTOS/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1661:FreeRTOS/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1662:FreeRTOS/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1663:FreeRTOS/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1664:FreeRTOS/queue.c **** 
1665:FreeRTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1287              		.loc 1 1665 0
 1288 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 1289 0012 F860     		str	r0, [r7, #12]
1666:FreeRTOS/queue.c **** 	{
1667:FreeRTOS/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1668:FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1290              		.loc 1 1668 0
 1291 0014 3B69     		ldr	r3, [r7, #16]
 1292 0016 9B6B     		ldr	r3, [r3, #56]
 1293 0018 002B     		cmp	r3, #0
 1294 001a 0CD0     		beq	.L81
1669:FreeRTOS/queue.c **** 		{
1670:FreeRTOS/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 53


1671:FreeRTOS/queue.c **** 
1672:FreeRTOS/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1673:FreeRTOS/queue.c **** 			actually being removed from the queue. */
1674:FreeRTOS/queue.c **** 			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1295              		.loc 1 1674 0
 1296 001c 3B69     		ldr	r3, [r7, #16]
 1297 001e DB68     		ldr	r3, [r3, #12]
 1298 0020 BB60     		str	r3, [r7, #8]
1675:FreeRTOS/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1299              		.loc 1 1675 0
 1300 0022 3968     		ldr	r1, [r7]
 1301 0024 3869     		ldr	r0, [r7, #16]
 1302 0026 FFF7FEFF 		bl	prvCopyDataFromQueue
1676:FreeRTOS/queue.c **** 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1303              		.loc 1 1676 0
 1304 002a 3B69     		ldr	r3, [r7, #16]
 1305 002c BA68     		ldr	r2, [r7, #8]
 1306 002e DA60     		str	r2, [r3, #12]
1677:FreeRTOS/queue.c **** 
1678:FreeRTOS/queue.c **** 			xReturn = pdPASS;
 1307              		.loc 1 1678 0
 1308 0030 0123     		movs	r3, #1
 1309 0032 7B61     		str	r3, [r7, #20]
 1310 0034 01E0     		b	.L82
 1311              	.L81:
1679:FreeRTOS/queue.c **** 		}
1680:FreeRTOS/queue.c **** 		else
1681:FreeRTOS/queue.c **** 		{
1682:FreeRTOS/queue.c **** 			xReturn = pdFAIL;
 1312              		.loc 1 1682 0
 1313 0036 0023     		movs	r3, #0
 1314 0038 7B61     		str	r3, [r7, #20]
 1315              	.L82:
1683:FreeRTOS/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1684:FreeRTOS/queue.c **** 		}
1685:FreeRTOS/queue.c **** 	}
1686:FreeRTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1316              		.loc 1 1686 0
 1317 003a F868     		ldr	r0, [r7, #12]
 1318 003c FFF7FEFF 		bl	vPortClearInterruptMask
1687:FreeRTOS/queue.c **** 
1688:FreeRTOS/queue.c **** 	return xReturn;
 1319              		.loc 1 1688 0
 1320 0040 7B69     		ldr	r3, [r7, #20]
1689:FreeRTOS/queue.c **** }
 1321              		.loc 1 1689 0
 1322 0042 1846     		mov	r0, r3
 1323 0044 1837     		adds	r7, r7, #24
 1324              		.cfi_def_cfa_offset 8
 1325 0046 BD46     		mov	sp, r7
 1326              		.cfi_def_cfa_register 13
 1327              		@ sp needed
 1328 0048 80BD     		pop	{r7, pc}
 1329              		.cfi_endproc
 1330              	.LFE75:
 1331              		.size	xQueuePeekFromISR, .-xQueuePeekFromISR
 1332 004a 00BF     		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 54


 1333              		.align	2
 1334              		.global	uxQueueMessagesWaiting
 1335              		.thumb
 1336              		.thumb_func
 1337              		.type	uxQueueMessagesWaiting, %function
 1338              	uxQueueMessagesWaiting:
 1339              	.LFB76:
1690:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1691:FreeRTOS/queue.c **** 
1692:FreeRTOS/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1693:FreeRTOS/queue.c **** {
 1340              		.loc 1 1693 0
 1341              		.cfi_startproc
 1342              		@ args = 0, pretend = 0, frame = 16
 1343              		@ frame_needed = 1, uses_anonymous_args = 0
 1344 0000 80B5     		push	{r7, lr}
 1345              		.cfi_def_cfa_offset 8
 1346              		.cfi_offset 7, -8
 1347              		.cfi_offset 14, -4
 1348 0002 84B0     		sub	sp, sp, #16
 1349              		.cfi_def_cfa_offset 24
 1350 0004 00AF     		add	r7, sp, #0
 1351              		.cfi_def_cfa_register 7
 1352 0006 7860     		str	r0, [r7, #4]
1694:FreeRTOS/queue.c **** UBaseType_t uxReturn;
1695:FreeRTOS/queue.c **** 
1696:FreeRTOS/queue.c **** 	configASSERT( xQueue );
1697:FreeRTOS/queue.c **** 
1698:FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 1353              		.loc 1 1698 0
 1354 0008 FFF7FEFF 		bl	vPortEnterCritical
1699:FreeRTOS/queue.c **** 	{
1700:FreeRTOS/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 1355              		.loc 1 1700 0
 1356 000c 7B68     		ldr	r3, [r7, #4]
 1357 000e 9B6B     		ldr	r3, [r3, #56]
 1358 0010 FB60     		str	r3, [r7, #12]
1701:FreeRTOS/queue.c **** 	}
1702:FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 1359              		.loc 1 1702 0
 1360 0012 FFF7FEFF 		bl	vPortExitCritical
1703:FreeRTOS/queue.c **** 
1704:FreeRTOS/queue.c **** 	return uxReturn;
 1361              		.loc 1 1704 0
 1362 0016 FB68     		ldr	r3, [r7, #12]
1705:FreeRTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1363              		.loc 1 1705 0
 1364 0018 1846     		mov	r0, r3
 1365 001a 1037     		adds	r7, r7, #16
 1366              		.cfi_def_cfa_offset 8
 1367 001c BD46     		mov	sp, r7
 1368              		.cfi_def_cfa_register 13
 1369              		@ sp needed
 1370 001e 80BD     		pop	{r7, pc}
 1371              		.cfi_endproc
 1372              	.LFE76:
 1373              		.size	uxQueueMessagesWaiting, .-uxQueueMessagesWaiting
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 55


 1374              		.section	.text.uxQueueSpacesAvailable,"ax",%progbits
 1375              		.align	2
 1376              		.global	uxQueueSpacesAvailable
 1377              		.thumb
 1378              		.thumb_func
 1379              		.type	uxQueueSpacesAvailable, %function
 1380              	uxQueueSpacesAvailable:
 1381              	.LFB77:
1706:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1707:FreeRTOS/queue.c **** 
1708:FreeRTOS/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1709:FreeRTOS/queue.c **** {
 1382              		.loc 1 1709 0
 1383              		.cfi_startproc
 1384              		@ args = 0, pretend = 0, frame = 16
 1385              		@ frame_needed = 1, uses_anonymous_args = 0
 1386 0000 80B5     		push	{r7, lr}
 1387              		.cfi_def_cfa_offset 8
 1388              		.cfi_offset 7, -8
 1389              		.cfi_offset 14, -4
 1390 0002 84B0     		sub	sp, sp, #16
 1391              		.cfi_def_cfa_offset 24
 1392 0004 00AF     		add	r7, sp, #0
 1393              		.cfi_def_cfa_register 7
 1394 0006 7860     		str	r0, [r7, #4]
1710:FreeRTOS/queue.c **** UBaseType_t uxReturn;
1711:FreeRTOS/queue.c **** Queue_t *pxQueue;
1712:FreeRTOS/queue.c **** 
1713:FreeRTOS/queue.c **** 	pxQueue = ( Queue_t * ) xQueue;
 1395              		.loc 1 1713 0
 1396 0008 7B68     		ldr	r3, [r7, #4]
 1397 000a FB60     		str	r3, [r7, #12]
1714:FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1715:FreeRTOS/queue.c **** 
1716:FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 1398              		.loc 1 1716 0
 1399 000c FFF7FEFF 		bl	vPortEnterCritical
1717:FreeRTOS/queue.c **** 	{
1718:FreeRTOS/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 1400              		.loc 1 1718 0
 1401 0010 FB68     		ldr	r3, [r7, #12]
 1402 0012 DA6B     		ldr	r2, [r3, #60]
 1403 0014 FB68     		ldr	r3, [r7, #12]
 1404 0016 9B6B     		ldr	r3, [r3, #56]
 1405 0018 D31A     		subs	r3, r2, r3
 1406 001a BB60     		str	r3, [r7, #8]
1719:FreeRTOS/queue.c **** 	}
1720:FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 1407              		.loc 1 1720 0
 1408 001c FFF7FEFF 		bl	vPortExitCritical
1721:FreeRTOS/queue.c **** 
1722:FreeRTOS/queue.c **** 	return uxReturn;
 1409              		.loc 1 1722 0
 1410 0020 BB68     		ldr	r3, [r7, #8]
1723:FreeRTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1411              		.loc 1 1723 0
 1412 0022 1846     		mov	r0, r3
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 56


 1413 0024 1037     		adds	r7, r7, #16
 1414              		.cfi_def_cfa_offset 8
 1415 0026 BD46     		mov	sp, r7
 1416              		.cfi_def_cfa_register 13
 1417              		@ sp needed
 1418 0028 80BD     		pop	{r7, pc}
 1419              		.cfi_endproc
 1420              	.LFE77:
 1421              		.size	uxQueueSpacesAvailable, .-uxQueueSpacesAvailable
 1422 002a 00BF     		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 1423              		.align	2
 1424              		.global	uxQueueMessagesWaitingFromISR
 1425              		.thumb
 1426              		.thumb_func
 1427              		.type	uxQueueMessagesWaitingFromISR, %function
 1428              	uxQueueMessagesWaitingFromISR:
 1429              	.LFB78:
1724:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1725:FreeRTOS/queue.c **** 
1726:FreeRTOS/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1727:FreeRTOS/queue.c **** {
 1430              		.loc 1 1727 0
 1431              		.cfi_startproc
 1432              		@ args = 0, pretend = 0, frame = 16
 1433              		@ frame_needed = 1, uses_anonymous_args = 0
 1434              		@ link register save eliminated.
 1435 0000 80B4     		push	{r7}
 1436              		.cfi_def_cfa_offset 4
 1437              		.cfi_offset 7, -4
 1438 0002 85B0     		sub	sp, sp, #20
 1439              		.cfi_def_cfa_offset 24
 1440 0004 00AF     		add	r7, sp, #0
 1441              		.cfi_def_cfa_register 7
 1442 0006 7860     		str	r0, [r7, #4]
1728:FreeRTOS/queue.c **** UBaseType_t uxReturn;
1729:FreeRTOS/queue.c **** 
1730:FreeRTOS/queue.c **** 	configASSERT( xQueue );
1731:FreeRTOS/queue.c **** 
1732:FreeRTOS/queue.c **** 	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 1443              		.loc 1 1732 0
 1444 0008 7B68     		ldr	r3, [r7, #4]
 1445 000a 9B6B     		ldr	r3, [r3, #56]
 1446 000c FB60     		str	r3, [r7, #12]
1733:FreeRTOS/queue.c **** 
1734:FreeRTOS/queue.c **** 	return uxReturn;
 1447              		.loc 1 1734 0
 1448 000e FB68     		ldr	r3, [r7, #12]
1735:FreeRTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1449              		.loc 1 1735 0
 1450 0010 1846     		mov	r0, r3
 1451 0012 1437     		adds	r7, r7, #20
 1452              		.cfi_def_cfa_offset 4
 1453 0014 BD46     		mov	sp, r7
 1454              		.cfi_def_cfa_register 13
 1455              		@ sp needed
 1456 0016 80BC     		pop	{r7}
 1457              		.cfi_restore 7
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 57


 1458              		.cfi_def_cfa_offset 0
 1459 0018 7047     		bx	lr
 1460              		.cfi_endproc
 1461              	.LFE78:
 1462              		.size	uxQueueMessagesWaitingFromISR, .-uxQueueMessagesWaitingFromISR
 1463 001a 00BF     		.section	.text.vQueueDelete,"ax",%progbits
 1464              		.align	2
 1465              		.global	vQueueDelete
 1466              		.thumb
 1467              		.thumb_func
 1468              		.type	vQueueDelete, %function
 1469              	vQueueDelete:
 1470              	.LFB79:
1736:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1737:FreeRTOS/queue.c **** 
1738:FreeRTOS/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1739:FreeRTOS/queue.c **** {
 1471              		.loc 1 1739 0
 1472              		.cfi_startproc
 1473              		@ args = 0, pretend = 0, frame = 16
 1474              		@ frame_needed = 1, uses_anonymous_args = 0
 1475 0000 80B5     		push	{r7, lr}
 1476              		.cfi_def_cfa_offset 8
 1477              		.cfi_offset 7, -8
 1478              		.cfi_offset 14, -4
 1479 0002 84B0     		sub	sp, sp, #16
 1480              		.cfi_def_cfa_offset 24
 1481 0004 00AF     		add	r7, sp, #0
 1482              		.cfi_def_cfa_register 7
 1483 0006 7860     		str	r0, [r7, #4]
1740:FreeRTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1484              		.loc 1 1740 0
 1485 0008 7B68     		ldr	r3, [r7, #4]
 1486 000a FB60     		str	r3, [r7, #12]
1741:FreeRTOS/queue.c **** 
1742:FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1743:FreeRTOS/queue.c **** 
1744:FreeRTOS/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1745:FreeRTOS/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1746:FreeRTOS/queue.c **** 	{
1747:FreeRTOS/queue.c **** 		vQueueUnregisterQueue( pxQueue );
 1487              		.loc 1 1747 0
 1488 000c F868     		ldr	r0, [r7, #12]
 1489 000e FFF7FEFF 		bl	vQueueUnregisterQueue
1748:FreeRTOS/queue.c **** 	}
1749:FreeRTOS/queue.c **** 	#endif
1750:FreeRTOS/queue.c **** 	vPortFree( pxQueue );
 1490              		.loc 1 1750 0
 1491 0012 F868     		ldr	r0, [r7, #12]
 1492 0014 FFF7FEFF 		bl	vPortFree
1751:FreeRTOS/queue.c **** }
 1493              		.loc 1 1751 0
 1494 0018 00BF     		nop
 1495 001a 1037     		adds	r7, r7, #16
 1496              		.cfi_def_cfa_offset 8
 1497 001c BD46     		mov	sp, r7
 1498              		.cfi_def_cfa_register 13
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 58


 1499              		@ sp needed
 1500 001e 80BD     		pop	{r7, pc}
 1501              		.cfi_endproc
 1502              	.LFE79:
 1503              		.size	vQueueDelete, .-vQueueDelete
 1504              		.section	.text.prvCopyDataToQueue,"ax",%progbits
 1505              		.align	2
 1506              		.thumb
 1507              		.thumb_func
 1508              		.type	prvCopyDataToQueue, %function
 1509              	prvCopyDataToQueue:
 1510              	.LFB80:
1752:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1753:FreeRTOS/queue.c **** 
1754:FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1755:FreeRTOS/queue.c **** 
1756:FreeRTOS/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
1757:FreeRTOS/queue.c **** 	{
1758:FreeRTOS/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
1759:FreeRTOS/queue.c **** 	}
1760:FreeRTOS/queue.c **** 
1761:FreeRTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1762:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1763:FreeRTOS/queue.c **** 
1764:FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1765:FreeRTOS/queue.c **** 
1766:FreeRTOS/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
1767:FreeRTOS/queue.c **** 	{
1768:FreeRTOS/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
1769:FreeRTOS/queue.c **** 	}
1770:FreeRTOS/queue.c **** 
1771:FreeRTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1772:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1773:FreeRTOS/queue.c **** 
1774:FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1775:FreeRTOS/queue.c **** 
1776:FreeRTOS/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
1777:FreeRTOS/queue.c **** 	{
1778:FreeRTOS/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
1779:FreeRTOS/queue.c **** 	}
1780:FreeRTOS/queue.c **** 
1781:FreeRTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1782:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1783:FreeRTOS/queue.c **** 
1784:FreeRTOS/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
1785:FreeRTOS/queue.c **** {
 1511              		.loc 1 1785 0
 1512              		.cfi_startproc
 1513              		@ args = 0, pretend = 0, frame = 24
 1514              		@ frame_needed = 1, uses_anonymous_args = 0
 1515 0000 80B5     		push	{r7, lr}
 1516              		.cfi_def_cfa_offset 8
 1517              		.cfi_offset 7, -8
 1518              		.cfi_offset 14, -4
 1519 0002 86B0     		sub	sp, sp, #24
 1520              		.cfi_def_cfa_offset 32
 1521 0004 00AF     		add	r7, sp, #0
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 59


 1522              		.cfi_def_cfa_register 7
 1523 0006 F860     		str	r0, [r7, #12]
 1524 0008 B960     		str	r1, [r7, #8]
 1525 000a 7A60     		str	r2, [r7, #4]
1786:FreeRTOS/queue.c **** BaseType_t xReturn = pdFALSE;
 1526              		.loc 1 1786 0
 1527 000c 0023     		movs	r3, #0
 1528 000e 7B61     		str	r3, [r7, #20]
1787:FreeRTOS/queue.c **** 
1788:FreeRTOS/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 1529              		.loc 1 1788 0
 1530 0010 FB68     		ldr	r3, [r7, #12]
 1531 0012 1B6C     		ldr	r3, [r3, #64]
 1532 0014 002B     		cmp	r3, #0
 1533 0016 0DD1     		bne	.L92
1789:FreeRTOS/queue.c **** 	{
1790:FreeRTOS/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1791:FreeRTOS/queue.c **** 		{
1792:FreeRTOS/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1534              		.loc 1 1792 0
 1535 0018 FB68     		ldr	r3, [r7, #12]
 1536 001a 1B68     		ldr	r3, [r3]
 1537 001c 002B     		cmp	r3, #0
 1538 001e 50D1     		bne	.L93
1793:FreeRTOS/queue.c **** 			{
1794:FreeRTOS/queue.c **** 				/* The mutex is no longer being held. */
1795:FreeRTOS/queue.c **** 				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 1539              		.loc 1 1795 0
 1540 0020 FB68     		ldr	r3, [r7, #12]
 1541 0022 5B68     		ldr	r3, [r3, #4]
 1542 0024 1846     		mov	r0, r3
 1543 0026 FFF7FEFF 		bl	xTaskPriorityDisinherit
 1544 002a 7861     		str	r0, [r7, #20]
1796:FreeRTOS/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 1545              		.loc 1 1796 0
 1546 002c FB68     		ldr	r3, [r7, #12]
 1547 002e 0022     		movs	r2, #0
 1548 0030 5A60     		str	r2, [r3, #4]
 1549 0032 46E0     		b	.L93
 1550              	.L92:
1797:FreeRTOS/queue.c **** 			}
1798:FreeRTOS/queue.c **** 			else
1799:FreeRTOS/queue.c **** 			{
1800:FreeRTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1801:FreeRTOS/queue.c **** 			}
1802:FreeRTOS/queue.c **** 		}
1803:FreeRTOS/queue.c **** 		#endif /* configUSE_MUTEXES */
1804:FreeRTOS/queue.c **** 	}
1805:FreeRTOS/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 1551              		.loc 1 1805 0
 1552 0034 7B68     		ldr	r3, [r7, #4]
 1553 0036 002B     		cmp	r3, #0
 1554 0038 19D1     		bne	.L94
1806:FreeRTOS/queue.c **** 	{
1807:FreeRTOS/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
 1555              		.loc 1 1807 0
 1556 003a FB68     		ldr	r3, [r7, #12]
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 60


 1557 003c 9868     		ldr	r0, [r3, #8]
 1558 003e FB68     		ldr	r3, [r7, #12]
 1559 0040 1B6C     		ldr	r3, [r3, #64]
 1560 0042 1A46     		mov	r2, r3
 1561 0044 B968     		ldr	r1, [r7, #8]
 1562 0046 FFF7FEFF 		bl	memcpy
1808:FreeRTOS/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 1563              		.loc 1 1808 0
 1564 004a FB68     		ldr	r3, [r7, #12]
 1565 004c 9A68     		ldr	r2, [r3, #8]
 1566 004e FB68     		ldr	r3, [r7, #12]
 1567 0050 1B6C     		ldr	r3, [r3, #64]
 1568 0052 1A44     		add	r2, r2, r3
 1569 0054 FB68     		ldr	r3, [r7, #12]
 1570 0056 9A60     		str	r2, [r3, #8]
1809:FreeRTOS/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
 1571              		.loc 1 1809 0
 1572 0058 FB68     		ldr	r3, [r7, #12]
 1573 005a 9A68     		ldr	r2, [r3, #8]
 1574 005c FB68     		ldr	r3, [r7, #12]
 1575 005e 5B68     		ldr	r3, [r3, #4]
 1576 0060 9A42     		cmp	r2, r3
 1577 0062 2ED3     		bcc	.L93
1810:FreeRTOS/queue.c **** 		{
1811:FreeRTOS/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 1578              		.loc 1 1811 0
 1579 0064 FB68     		ldr	r3, [r7, #12]
 1580 0066 1A68     		ldr	r2, [r3]
 1581 0068 FB68     		ldr	r3, [r7, #12]
 1582 006a 9A60     		str	r2, [r3, #8]
 1583 006c 29E0     		b	.L93
 1584              	.L94:
1812:FreeRTOS/queue.c **** 		}
1813:FreeRTOS/queue.c **** 		else
1814:FreeRTOS/queue.c **** 		{
1815:FreeRTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1816:FreeRTOS/queue.c **** 		}
1817:FreeRTOS/queue.c **** 	}
1818:FreeRTOS/queue.c **** 	else
1819:FreeRTOS/queue.c **** 	{
1820:FreeRTOS/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize 
 1585              		.loc 1 1820 0
 1586 006e FB68     		ldr	r3, [r7, #12]
 1587 0070 D868     		ldr	r0, [r3, #12]
 1588 0072 FB68     		ldr	r3, [r7, #12]
 1589 0074 1B6C     		ldr	r3, [r3, #64]
 1590 0076 1A46     		mov	r2, r3
 1591 0078 B968     		ldr	r1, [r7, #8]
 1592 007a FFF7FEFF 		bl	memcpy
1821:FreeRTOS/queue.c **** 		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 1593              		.loc 1 1821 0
 1594 007e FB68     		ldr	r3, [r7, #12]
 1595 0080 DA68     		ldr	r2, [r3, #12]
 1596 0082 FB68     		ldr	r3, [r7, #12]
 1597 0084 1B6C     		ldr	r3, [r3, #64]
 1598 0086 5B42     		negs	r3, r3
 1599 0088 1A44     		add	r2, r2, r3
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 61


 1600 008a FB68     		ldr	r3, [r7, #12]
 1601 008c DA60     		str	r2, [r3, #12]
1822:FreeRTOS/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 1602              		.loc 1 1822 0
 1603 008e FB68     		ldr	r3, [r7, #12]
 1604 0090 DA68     		ldr	r2, [r3, #12]
 1605 0092 FB68     		ldr	r3, [r7, #12]
 1606 0094 1B68     		ldr	r3, [r3]
 1607 0096 9A42     		cmp	r2, r3
 1608 0098 07D2     		bcs	.L95
1823:FreeRTOS/queue.c **** 		{
1824:FreeRTOS/queue.c **** 			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 1609              		.loc 1 1824 0
 1610 009a FB68     		ldr	r3, [r7, #12]
 1611 009c 5A68     		ldr	r2, [r3, #4]
 1612 009e FB68     		ldr	r3, [r7, #12]
 1613 00a0 1B6C     		ldr	r3, [r3, #64]
 1614 00a2 5B42     		negs	r3, r3
 1615 00a4 1A44     		add	r2, r2, r3
 1616 00a6 FB68     		ldr	r3, [r7, #12]
 1617 00a8 DA60     		str	r2, [r3, #12]
 1618              	.L95:
1825:FreeRTOS/queue.c **** 		}
1826:FreeRTOS/queue.c **** 		else
1827:FreeRTOS/queue.c **** 		{
1828:FreeRTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1829:FreeRTOS/queue.c **** 		}
1830:FreeRTOS/queue.c **** 
1831:FreeRTOS/queue.c **** 		if( xPosition == queueOVERWRITE )
 1619              		.loc 1 1831 0
 1620 00aa 7B68     		ldr	r3, [r7, #4]
 1621 00ac 022B     		cmp	r3, #2
 1622 00ae 08D1     		bne	.L93
1832:FreeRTOS/queue.c **** 		{
1833:FreeRTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1623              		.loc 1 1833 0
 1624 00b0 FB68     		ldr	r3, [r7, #12]
 1625 00b2 9B6B     		ldr	r3, [r3, #56]
 1626 00b4 002B     		cmp	r3, #0
 1627 00b6 04D0     		beq	.L93
1834:FreeRTOS/queue.c **** 			{
1835:FreeRTOS/queue.c **** 				/* An item is not being added but overwritten, so subtract
1836:FreeRTOS/queue.c **** 				one from the recorded number of items in the queue so when
1837:FreeRTOS/queue.c **** 				one is added again below the number of recorded items remains
1838:FreeRTOS/queue.c **** 				correct. */
1839:FreeRTOS/queue.c **** 				--( pxQueue->uxMessagesWaiting );
 1628              		.loc 1 1839 0
 1629 00b8 FB68     		ldr	r3, [r7, #12]
 1630 00ba 9B6B     		ldr	r3, [r3, #56]
 1631 00bc 5A1E     		subs	r2, r3, #1
 1632 00be FB68     		ldr	r3, [r7, #12]
 1633 00c0 9A63     		str	r2, [r3, #56]
 1634              	.L93:
1840:FreeRTOS/queue.c **** 			}
1841:FreeRTOS/queue.c **** 			else
1842:FreeRTOS/queue.c **** 			{
1843:FreeRTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 62


1844:FreeRTOS/queue.c **** 			}
1845:FreeRTOS/queue.c **** 		}
1846:FreeRTOS/queue.c **** 		else
1847:FreeRTOS/queue.c **** 		{
1848:FreeRTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1849:FreeRTOS/queue.c **** 		}
1850:FreeRTOS/queue.c **** 	}
1851:FreeRTOS/queue.c **** 
1852:FreeRTOS/queue.c **** 	++( pxQueue->uxMessagesWaiting );
 1635              		.loc 1 1852 0
 1636 00c2 FB68     		ldr	r3, [r7, #12]
 1637 00c4 9B6B     		ldr	r3, [r3, #56]
 1638 00c6 5A1C     		adds	r2, r3, #1
 1639 00c8 FB68     		ldr	r3, [r7, #12]
 1640 00ca 9A63     		str	r2, [r3, #56]
1853:FreeRTOS/queue.c **** 
1854:FreeRTOS/queue.c **** 	return xReturn;
 1641              		.loc 1 1854 0
 1642 00cc 7B69     		ldr	r3, [r7, #20]
1855:FreeRTOS/queue.c **** }
 1643              		.loc 1 1855 0
 1644 00ce 1846     		mov	r0, r3
 1645 00d0 1837     		adds	r7, r7, #24
 1646              		.cfi_def_cfa_offset 8
 1647 00d2 BD46     		mov	sp, r7
 1648              		.cfi_def_cfa_register 13
 1649              		@ sp needed
 1650 00d4 80BD     		pop	{r7, pc}
 1651              		.cfi_endproc
 1652              	.LFE80:
 1653              		.size	prvCopyDataToQueue, .-prvCopyDataToQueue
 1654 00d6 00BF     		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 1655              		.align	2
 1656              		.thumb
 1657              		.thumb_func
 1658              		.type	prvCopyDataFromQueue, %function
 1659              	prvCopyDataFromQueue:
 1660              	.LFB81:
1856:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1857:FreeRTOS/queue.c **** 
1858:FreeRTOS/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
1859:FreeRTOS/queue.c **** {
 1661              		.loc 1 1859 0
 1662              		.cfi_startproc
 1663              		@ args = 0, pretend = 0, frame = 8
 1664              		@ frame_needed = 1, uses_anonymous_args = 0
 1665 0000 80B5     		push	{r7, lr}
 1666              		.cfi_def_cfa_offset 8
 1667              		.cfi_offset 7, -8
 1668              		.cfi_offset 14, -4
 1669 0002 82B0     		sub	sp, sp, #8
 1670              		.cfi_def_cfa_offset 16
 1671 0004 00AF     		add	r7, sp, #0
 1672              		.cfi_def_cfa_register 7
 1673 0006 7860     		str	r0, [r7, #4]
 1674 0008 3960     		str	r1, [r7]
1860:FreeRTOS/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 63


 1675              		.loc 1 1860 0
 1676 000a 7B68     		ldr	r3, [r7, #4]
 1677 000c 1B6C     		ldr	r3, [r3, #64]
 1678 000e 002B     		cmp	r3, #0
 1679 0010 18D0     		beq	.L100
1861:FreeRTOS/queue.c **** 	{
1862:FreeRTOS/queue.c **** 		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 1680              		.loc 1 1862 0
 1681 0012 7B68     		ldr	r3, [r7, #4]
 1682 0014 DA68     		ldr	r2, [r3, #12]
 1683 0016 7B68     		ldr	r3, [r7, #4]
 1684 0018 1B6C     		ldr	r3, [r3, #64]
 1685 001a 1A44     		add	r2, r2, r3
 1686 001c 7B68     		ldr	r3, [r7, #4]
 1687 001e DA60     		str	r2, [r3, #12]
1863:FreeRTOS/queue.c **** 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of t
 1688              		.loc 1 1863 0
 1689 0020 7B68     		ldr	r3, [r7, #4]
 1690 0022 DA68     		ldr	r2, [r3, #12]
 1691 0024 7B68     		ldr	r3, [r7, #4]
 1692 0026 5B68     		ldr	r3, [r3, #4]
 1693 0028 9A42     		cmp	r2, r3
 1694 002a 03D3     		bcc	.L99
1864:FreeRTOS/queue.c **** 		{
1865:FreeRTOS/queue.c **** 			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 1695              		.loc 1 1865 0
 1696 002c 7B68     		ldr	r3, [r7, #4]
 1697 002e 1A68     		ldr	r2, [r3]
 1698 0030 7B68     		ldr	r3, [r7, #4]
 1699 0032 DA60     		str	r2, [r3, #12]
 1700              	.L99:
1866:FreeRTOS/queue.c **** 		}
1867:FreeRTOS/queue.c **** 		else
1868:FreeRTOS/queue.c **** 		{
1869:FreeRTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1870:FreeRTOS/queue.c **** 		}
1871:FreeRTOS/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxIte
 1701              		.loc 1 1871 0
 1702 0034 7B68     		ldr	r3, [r7, #4]
 1703 0036 D968     		ldr	r1, [r3, #12]
 1704 0038 7B68     		ldr	r3, [r7, #4]
 1705 003a 1B6C     		ldr	r3, [r3, #64]
 1706 003c 1A46     		mov	r2, r3
 1707 003e 3868     		ldr	r0, [r7]
 1708 0040 FFF7FEFF 		bl	memcpy
 1709              	.L100:
1872:FreeRTOS/queue.c **** 	}
1873:FreeRTOS/queue.c **** }
 1710              		.loc 1 1873 0
 1711 0044 00BF     		nop
 1712 0046 0837     		adds	r7, r7, #8
 1713              		.cfi_def_cfa_offset 8
 1714 0048 BD46     		mov	sp, r7
 1715              		.cfi_def_cfa_register 13
 1716              		@ sp needed
 1717 004a 80BD     		pop	{r7, pc}
 1718              		.cfi_endproc
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 64


 1719              	.LFE81:
 1720              		.size	prvCopyDataFromQueue, .-prvCopyDataFromQueue
 1721              		.section	.text.prvUnlockQueue,"ax",%progbits
 1722              		.align	2
 1723              		.thumb
 1724              		.thumb_func
 1725              		.type	prvUnlockQueue, %function
 1726              	prvUnlockQueue:
 1727              	.LFB82:
1874:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1875:FreeRTOS/queue.c **** 
1876:FreeRTOS/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
1877:FreeRTOS/queue.c **** {
 1728              		.loc 1 1877 0
 1729              		.cfi_startproc
 1730              		@ args = 0, pretend = 0, frame = 8
 1731              		@ frame_needed = 1, uses_anonymous_args = 0
 1732 0000 80B5     		push	{r7, lr}
 1733              		.cfi_def_cfa_offset 8
 1734              		.cfi_offset 7, -8
 1735              		.cfi_offset 14, -4
 1736 0002 82B0     		sub	sp, sp, #8
 1737              		.cfi_def_cfa_offset 16
 1738 0004 00AF     		add	r7, sp, #0
 1739              		.cfi_def_cfa_register 7
 1740 0006 7860     		str	r0, [r7, #4]
1878:FreeRTOS/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1879:FreeRTOS/queue.c **** 
1880:FreeRTOS/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1881:FreeRTOS/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1882:FreeRTOS/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1883:FreeRTOS/queue.c **** 	updated. */
1884:FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 1741              		.loc 1 1884 0
 1742 0008 FFF7FEFF 		bl	vPortEnterCritical
1885:FreeRTOS/queue.c **** 	{
1886:FreeRTOS/queue.c **** 		/* See if data was added to the queue while it was locked. */
1887:FreeRTOS/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 1743              		.loc 1 1887 0
 1744 000c 12E0     		b	.L102
 1745              	.L106:
1888:FreeRTOS/queue.c **** 		{
1889:FreeRTOS/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1890:FreeRTOS/queue.c **** 			blocked waiting for data to become available? */
1891:FreeRTOS/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
1892:FreeRTOS/queue.c **** 			{
1893:FreeRTOS/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
1894:FreeRTOS/queue.c **** 				{
1895:FreeRTOS/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
1896:FreeRTOS/queue.c **** 					{
1897:FreeRTOS/queue.c **** 						/* The queue is a member of a queue set, and posting to
1898:FreeRTOS/queue.c **** 						the queue set caused a higher priority task to unblock.
1899:FreeRTOS/queue.c **** 						A context switch is required. */
1900:FreeRTOS/queue.c **** 						vTaskMissedYield();
1901:FreeRTOS/queue.c **** 					}
1902:FreeRTOS/queue.c **** 					else
1903:FreeRTOS/queue.c **** 					{
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 65


1904:FreeRTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1905:FreeRTOS/queue.c **** 					}
1906:FreeRTOS/queue.c **** 				}
1907:FreeRTOS/queue.c **** 				else
1908:FreeRTOS/queue.c **** 				{
1909:FreeRTOS/queue.c **** 					/* Tasks that are removed from the event list will get added to
1910:FreeRTOS/queue.c **** 					the pending ready list as the scheduler is still suspended. */
1911:FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1912:FreeRTOS/queue.c **** 					{
1913:FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1914:FreeRTOS/queue.c **** 						{
1915:FreeRTOS/queue.c **** 							/* The task waiting has a higher priority so record that a
1916:FreeRTOS/queue.c **** 							context	switch is required. */
1917:FreeRTOS/queue.c **** 							vTaskMissedYield();
1918:FreeRTOS/queue.c **** 						}
1919:FreeRTOS/queue.c **** 						else
1920:FreeRTOS/queue.c **** 						{
1921:FreeRTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1922:FreeRTOS/queue.c **** 						}
1923:FreeRTOS/queue.c **** 					}
1924:FreeRTOS/queue.c **** 					else
1925:FreeRTOS/queue.c **** 					{
1926:FreeRTOS/queue.c **** 						break;
1927:FreeRTOS/queue.c **** 					}
1928:FreeRTOS/queue.c **** 				}
1929:FreeRTOS/queue.c **** 			}
1930:FreeRTOS/queue.c **** 			#else /* configUSE_QUEUE_SETS */
1931:FreeRTOS/queue.c **** 			{
1932:FreeRTOS/queue.c **** 				/* Tasks that are removed from the event list will get added to
1933:FreeRTOS/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1934:FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1746              		.loc 1 1934 0
 1747 000e 7B68     		ldr	r3, [r7, #4]
 1748 0010 5B6A     		ldr	r3, [r3, #36]
 1749 0012 002B     		cmp	r3, #0
 1750 0014 13D0     		beq	.L112
1935:FreeRTOS/queue.c **** 				{
1936:FreeRTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1751              		.loc 1 1936 0
 1752 0016 7B68     		ldr	r3, [r7, #4]
 1753 0018 2433     		adds	r3, r3, #36
 1754 001a 1846     		mov	r0, r3
 1755 001c FFF7FEFF 		bl	xTaskRemoveFromEventList
 1756 0020 0346     		mov	r3, r0
 1757 0022 002B     		cmp	r3, #0
 1758 0024 01D0     		beq	.L104
1937:FreeRTOS/queue.c **** 					{
1938:FreeRTOS/queue.c **** 						/* The task waiting has a higher priority so record that a
1939:FreeRTOS/queue.c **** 						context	switch is required. */
1940:FreeRTOS/queue.c **** 						vTaskMissedYield();
 1759              		.loc 1 1940 0
 1760 0026 FFF7FEFF 		bl	vTaskMissedYield
 1761              	.L104:
1941:FreeRTOS/queue.c **** 					}
1942:FreeRTOS/queue.c **** 					else
1943:FreeRTOS/queue.c **** 					{
1944:FreeRTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 66


1945:FreeRTOS/queue.c **** 					}
1946:FreeRTOS/queue.c **** 				}
1947:FreeRTOS/queue.c **** 				else
1948:FreeRTOS/queue.c **** 				{
1949:FreeRTOS/queue.c **** 					break;
1950:FreeRTOS/queue.c **** 				}
1951:FreeRTOS/queue.c **** 			}
1952:FreeRTOS/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
1953:FreeRTOS/queue.c **** 
1954:FreeRTOS/queue.c **** 			--( pxQueue->xTxLock );
 1762              		.loc 1 1954 0
 1763 002a 7B68     		ldr	r3, [r7, #4]
 1764 002c 9B6C     		ldr	r3, [r3, #72]
 1765 002e 5A1E     		subs	r2, r3, #1
 1766 0030 7B68     		ldr	r3, [r7, #4]
 1767 0032 9A64     		str	r2, [r3, #72]
 1768              	.L102:
1887:FreeRTOS/queue.c **** 		{
 1769              		.loc 1 1887 0
 1770 0034 7B68     		ldr	r3, [r7, #4]
 1771 0036 9B6C     		ldr	r3, [r3, #72]
 1772 0038 002B     		cmp	r3, #0
 1773 003a E8DC     		bgt	.L106
 1774 003c 00E0     		b	.L105
 1775              	.L112:
1949:FreeRTOS/queue.c **** 				}
 1776              		.loc 1 1949 0
 1777 003e 00BF     		nop
 1778              	.L105:
1955:FreeRTOS/queue.c **** 		}
1956:FreeRTOS/queue.c **** 
1957:FreeRTOS/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 1779              		.loc 1 1957 0
 1780 0040 7B68     		ldr	r3, [r7, #4]
 1781 0042 4FF0FF32 		mov	r2, #-1
 1782 0046 9A64     		str	r2, [r3, #72]
1958:FreeRTOS/queue.c **** 	}
1959:FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 1783              		.loc 1 1959 0
 1784 0048 FFF7FEFF 		bl	vPortExitCritical
1960:FreeRTOS/queue.c **** 
1961:FreeRTOS/queue.c **** 	/* Do the same for the Rx lock. */
1962:FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 1785              		.loc 1 1962 0
 1786 004c FFF7FEFF 		bl	vPortEnterCritical
1963:FreeRTOS/queue.c **** 	{
1964:FreeRTOS/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 1787              		.loc 1 1964 0
 1788 0050 12E0     		b	.L107
 1789              	.L111:
1965:FreeRTOS/queue.c **** 		{
1966:FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1790              		.loc 1 1966 0
 1791 0052 7B68     		ldr	r3, [r7, #4]
 1792 0054 1B69     		ldr	r3, [r3, #16]
 1793 0056 002B     		cmp	r3, #0
 1794 0058 13D0     		beq	.L113
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 67


1967:FreeRTOS/queue.c **** 			{
1968:FreeRTOS/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1795              		.loc 1 1968 0
 1796 005a 7B68     		ldr	r3, [r7, #4]
 1797 005c 1033     		adds	r3, r3, #16
 1798 005e 1846     		mov	r0, r3
 1799 0060 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1800 0064 0346     		mov	r3, r0
 1801 0066 002B     		cmp	r3, #0
 1802 0068 01D0     		beq	.L109
1969:FreeRTOS/queue.c **** 				{
1970:FreeRTOS/queue.c **** 					vTaskMissedYield();
 1803              		.loc 1 1970 0
 1804 006a FFF7FEFF 		bl	vTaskMissedYield
 1805              	.L109:
1971:FreeRTOS/queue.c **** 				}
1972:FreeRTOS/queue.c **** 				else
1973:FreeRTOS/queue.c **** 				{
1974:FreeRTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1975:FreeRTOS/queue.c **** 				}
1976:FreeRTOS/queue.c **** 
1977:FreeRTOS/queue.c **** 				--( pxQueue->xRxLock );
 1806              		.loc 1 1977 0
 1807 006e 7B68     		ldr	r3, [r7, #4]
 1808 0070 5B6C     		ldr	r3, [r3, #68]
 1809 0072 5A1E     		subs	r2, r3, #1
 1810 0074 7B68     		ldr	r3, [r7, #4]
 1811 0076 5A64     		str	r2, [r3, #68]
 1812              	.L107:
1964:FreeRTOS/queue.c **** 		{
 1813              		.loc 1 1964 0
 1814 0078 7B68     		ldr	r3, [r7, #4]
 1815 007a 5B6C     		ldr	r3, [r3, #68]
 1816 007c 002B     		cmp	r3, #0
 1817 007e E8DC     		bgt	.L111
 1818 0080 00E0     		b	.L110
 1819              	.L113:
1978:FreeRTOS/queue.c **** 			}
1979:FreeRTOS/queue.c **** 			else
1980:FreeRTOS/queue.c **** 			{
1981:FreeRTOS/queue.c **** 				break;
 1820              		.loc 1 1981 0
 1821 0082 00BF     		nop
 1822              	.L110:
1982:FreeRTOS/queue.c **** 			}
1983:FreeRTOS/queue.c **** 		}
1984:FreeRTOS/queue.c **** 
1985:FreeRTOS/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 1823              		.loc 1 1985 0
 1824 0084 7B68     		ldr	r3, [r7, #4]
 1825 0086 4FF0FF32 		mov	r2, #-1
 1826 008a 5A64     		str	r2, [r3, #68]
1986:FreeRTOS/queue.c **** 	}
1987:FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 1827              		.loc 1 1987 0
 1828 008c FFF7FEFF 		bl	vPortExitCritical
1988:FreeRTOS/queue.c **** }
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 68


 1829              		.loc 1 1988 0
 1830 0090 00BF     		nop
 1831 0092 0837     		adds	r7, r7, #8
 1832              		.cfi_def_cfa_offset 8
 1833 0094 BD46     		mov	sp, r7
 1834              		.cfi_def_cfa_register 13
 1835              		@ sp needed
 1836 0096 80BD     		pop	{r7, pc}
 1837              		.cfi_endproc
 1838              	.LFE82:
 1839              		.size	prvUnlockQueue, .-prvUnlockQueue
 1840              		.section	.text.prvIsQueueEmpty,"ax",%progbits
 1841              		.align	2
 1842              		.thumb
 1843              		.thumb_func
 1844              		.type	prvIsQueueEmpty, %function
 1845              	prvIsQueueEmpty:
 1846              	.LFB83:
1989:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1990:FreeRTOS/queue.c **** 
1991:FreeRTOS/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
1992:FreeRTOS/queue.c **** {
 1847              		.loc 1 1992 0
 1848              		.cfi_startproc
 1849              		@ args = 0, pretend = 0, frame = 16
 1850              		@ frame_needed = 1, uses_anonymous_args = 0
 1851 0000 80B5     		push	{r7, lr}
 1852              		.cfi_def_cfa_offset 8
 1853              		.cfi_offset 7, -8
 1854              		.cfi_offset 14, -4
 1855 0002 84B0     		sub	sp, sp, #16
 1856              		.cfi_def_cfa_offset 24
 1857 0004 00AF     		add	r7, sp, #0
 1858              		.cfi_def_cfa_register 7
 1859 0006 7860     		str	r0, [r7, #4]
1993:FreeRTOS/queue.c **** BaseType_t xReturn;
1994:FreeRTOS/queue.c **** 
1995:FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 1860              		.loc 1 1995 0
 1861 0008 FFF7FEFF 		bl	vPortEnterCritical
1996:FreeRTOS/queue.c **** 	{
1997:FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 1862              		.loc 1 1997 0
 1863 000c 7B68     		ldr	r3, [r7, #4]
 1864 000e 9B6B     		ldr	r3, [r3, #56]
 1865 0010 002B     		cmp	r3, #0
 1866 0012 02D1     		bne	.L115
1998:FreeRTOS/queue.c **** 		{
1999:FreeRTOS/queue.c **** 			xReturn = pdTRUE;
 1867              		.loc 1 1999 0
 1868 0014 0123     		movs	r3, #1
 1869 0016 FB60     		str	r3, [r7, #12]
 1870 0018 01E0     		b	.L116
 1871              	.L115:
2000:FreeRTOS/queue.c **** 		}
2001:FreeRTOS/queue.c **** 		else
2002:FreeRTOS/queue.c **** 		{
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 69


2003:FreeRTOS/queue.c **** 			xReturn = pdFALSE;
 1872              		.loc 1 2003 0
 1873 001a 0023     		movs	r3, #0
 1874 001c FB60     		str	r3, [r7, #12]
 1875              	.L116:
2004:FreeRTOS/queue.c **** 		}
2005:FreeRTOS/queue.c **** 	}
2006:FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 1876              		.loc 1 2006 0
 1877 001e FFF7FEFF 		bl	vPortExitCritical
2007:FreeRTOS/queue.c **** 
2008:FreeRTOS/queue.c **** 	return xReturn;
 1878              		.loc 1 2008 0
 1879 0022 FB68     		ldr	r3, [r7, #12]
2009:FreeRTOS/queue.c **** }
 1880              		.loc 1 2009 0
 1881 0024 1846     		mov	r0, r3
 1882 0026 1037     		adds	r7, r7, #16
 1883              		.cfi_def_cfa_offset 8
 1884 0028 BD46     		mov	sp, r7
 1885              		.cfi_def_cfa_register 13
 1886              		@ sp needed
 1887 002a 80BD     		pop	{r7, pc}
 1888              		.cfi_endproc
 1889              	.LFE83:
 1890              		.size	prvIsQueueEmpty, .-prvIsQueueEmpty
 1891              		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 1892              		.align	2
 1893              		.global	xQueueIsQueueEmptyFromISR
 1894              		.thumb
 1895              		.thumb_func
 1896              		.type	xQueueIsQueueEmptyFromISR, %function
 1897              	xQueueIsQueueEmptyFromISR:
 1898              	.LFB84:
2010:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2011:FreeRTOS/queue.c **** 
2012:FreeRTOS/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2013:FreeRTOS/queue.c **** {
 1899              		.loc 1 2013 0
 1900              		.cfi_startproc
 1901              		@ args = 0, pretend = 0, frame = 16
 1902              		@ frame_needed = 1, uses_anonymous_args = 0
 1903              		@ link register save eliminated.
 1904 0000 80B4     		push	{r7}
 1905              		.cfi_def_cfa_offset 4
 1906              		.cfi_offset 7, -4
 1907 0002 85B0     		sub	sp, sp, #20
 1908              		.cfi_def_cfa_offset 24
 1909 0004 00AF     		add	r7, sp, #0
 1910              		.cfi_def_cfa_register 7
 1911 0006 7860     		str	r0, [r7, #4]
2014:FreeRTOS/queue.c **** BaseType_t xReturn;
2015:FreeRTOS/queue.c **** 
2016:FreeRTOS/queue.c **** 	configASSERT( xQueue );
2017:FreeRTOS/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
 1912              		.loc 1 2017 0
 1913 0008 7B68     		ldr	r3, [r7, #4]
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 70


 1914 000a 9B6B     		ldr	r3, [r3, #56]
 1915 000c 002B     		cmp	r3, #0
 1916 000e 02D1     		bne	.L119
2018:FreeRTOS/queue.c **** 	{
2019:FreeRTOS/queue.c **** 		xReturn = pdTRUE;
 1917              		.loc 1 2019 0
 1918 0010 0123     		movs	r3, #1
 1919 0012 FB60     		str	r3, [r7, #12]
 1920 0014 01E0     		b	.L120
 1921              	.L119:
2020:FreeRTOS/queue.c **** 	}
2021:FreeRTOS/queue.c **** 	else
2022:FreeRTOS/queue.c **** 	{
2023:FreeRTOS/queue.c **** 		xReturn = pdFALSE;
 1922              		.loc 1 2023 0
 1923 0016 0023     		movs	r3, #0
 1924 0018 FB60     		str	r3, [r7, #12]
 1925              	.L120:
2024:FreeRTOS/queue.c **** 	}
2025:FreeRTOS/queue.c **** 
2026:FreeRTOS/queue.c **** 	return xReturn;
 1926              		.loc 1 2026 0
 1927 001a FB68     		ldr	r3, [r7, #12]
2027:FreeRTOS/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 1928              		.loc 1 2027 0
 1929 001c 1846     		mov	r0, r3
 1930 001e 1437     		adds	r7, r7, #20
 1931              		.cfi_def_cfa_offset 4
 1932 0020 BD46     		mov	sp, r7
 1933              		.cfi_def_cfa_register 13
 1934              		@ sp needed
 1935 0022 80BC     		pop	{r7}
 1936              		.cfi_restore 7
 1937              		.cfi_def_cfa_offset 0
 1938 0024 7047     		bx	lr
 1939              		.cfi_endproc
 1940              	.LFE84:
 1941              		.size	xQueueIsQueueEmptyFromISR, .-xQueueIsQueueEmptyFromISR
 1942 0026 00BF     		.section	.text.prvIsQueueFull,"ax",%progbits
 1943              		.align	2
 1944              		.thumb
 1945              		.thumb_func
 1946              		.type	prvIsQueueFull, %function
 1947              	prvIsQueueFull:
 1948              	.LFB85:
2028:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2029:FreeRTOS/queue.c **** 
2030:FreeRTOS/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
2031:FreeRTOS/queue.c **** {
 1949              		.loc 1 2031 0
 1950              		.cfi_startproc
 1951              		@ args = 0, pretend = 0, frame = 16
 1952              		@ frame_needed = 1, uses_anonymous_args = 0
 1953 0000 80B5     		push	{r7, lr}
 1954              		.cfi_def_cfa_offset 8
 1955              		.cfi_offset 7, -8
 1956              		.cfi_offset 14, -4
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 71


 1957 0002 84B0     		sub	sp, sp, #16
 1958              		.cfi_def_cfa_offset 24
 1959 0004 00AF     		add	r7, sp, #0
 1960              		.cfi_def_cfa_register 7
 1961 0006 7860     		str	r0, [r7, #4]
2032:FreeRTOS/queue.c **** BaseType_t xReturn;
2033:FreeRTOS/queue.c **** 
2034:FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 1962              		.loc 1 2034 0
 1963 0008 FFF7FEFF 		bl	vPortEnterCritical
2035:FreeRTOS/queue.c **** 	{
2036:FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 1964              		.loc 1 2036 0
 1965 000c 7B68     		ldr	r3, [r7, #4]
 1966 000e 9A6B     		ldr	r2, [r3, #56]
 1967 0010 7B68     		ldr	r3, [r7, #4]
 1968 0012 DB6B     		ldr	r3, [r3, #60]
 1969 0014 9A42     		cmp	r2, r3
 1970 0016 02D1     		bne	.L123
2037:FreeRTOS/queue.c **** 		{
2038:FreeRTOS/queue.c **** 			xReturn = pdTRUE;
 1971              		.loc 1 2038 0
 1972 0018 0123     		movs	r3, #1
 1973 001a FB60     		str	r3, [r7, #12]
 1974 001c 01E0     		b	.L124
 1975              	.L123:
2039:FreeRTOS/queue.c **** 		}
2040:FreeRTOS/queue.c **** 		else
2041:FreeRTOS/queue.c **** 		{
2042:FreeRTOS/queue.c **** 			xReturn = pdFALSE;
 1976              		.loc 1 2042 0
 1977 001e 0023     		movs	r3, #0
 1978 0020 FB60     		str	r3, [r7, #12]
 1979              	.L124:
2043:FreeRTOS/queue.c **** 		}
2044:FreeRTOS/queue.c **** 	}
2045:FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 1980              		.loc 1 2045 0
 1981 0022 FFF7FEFF 		bl	vPortExitCritical
2046:FreeRTOS/queue.c **** 
2047:FreeRTOS/queue.c **** 	return xReturn;
 1982              		.loc 1 2047 0
 1983 0026 FB68     		ldr	r3, [r7, #12]
2048:FreeRTOS/queue.c **** }
 1984              		.loc 1 2048 0
 1985 0028 1846     		mov	r0, r3
 1986 002a 1037     		adds	r7, r7, #16
 1987              		.cfi_def_cfa_offset 8
 1988 002c BD46     		mov	sp, r7
 1989              		.cfi_def_cfa_register 13
 1990              		@ sp needed
 1991 002e 80BD     		pop	{r7, pc}
 1992              		.cfi_endproc
 1993              	.LFE85:
 1994              		.size	prvIsQueueFull, .-prvIsQueueFull
 1995              		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 1996              		.align	2
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 72


 1997              		.global	xQueueIsQueueFullFromISR
 1998              		.thumb
 1999              		.thumb_func
 2000              		.type	xQueueIsQueueFullFromISR, %function
 2001              	xQueueIsQueueFullFromISR:
 2002              	.LFB86:
2049:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2050:FreeRTOS/queue.c **** 
2051:FreeRTOS/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2052:FreeRTOS/queue.c **** {
 2003              		.loc 1 2052 0
 2004              		.cfi_startproc
 2005              		@ args = 0, pretend = 0, frame = 16
 2006              		@ frame_needed = 1, uses_anonymous_args = 0
 2007              		@ link register save eliminated.
 2008 0000 80B4     		push	{r7}
 2009              		.cfi_def_cfa_offset 4
 2010              		.cfi_offset 7, -4
 2011 0002 85B0     		sub	sp, sp, #20
 2012              		.cfi_def_cfa_offset 24
 2013 0004 00AF     		add	r7, sp, #0
 2014              		.cfi_def_cfa_register 7
 2015 0006 7860     		str	r0, [r7, #4]
2053:FreeRTOS/queue.c **** BaseType_t xReturn;
2054:FreeRTOS/queue.c **** 
2055:FreeRTOS/queue.c **** 	configASSERT( xQueue );
2056:FreeRTOS/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
 2016              		.loc 1 2056 0
 2017 0008 7B68     		ldr	r3, [r7, #4]
 2018 000a 9A6B     		ldr	r2, [r3, #56]
 2019 000c 7B68     		ldr	r3, [r7, #4]
 2020 000e DB6B     		ldr	r3, [r3, #60]
 2021 0010 9A42     		cmp	r2, r3
 2022 0012 02D1     		bne	.L127
2057:FreeRTOS/queue.c **** 	{
2058:FreeRTOS/queue.c **** 		xReturn = pdTRUE;
 2023              		.loc 1 2058 0
 2024 0014 0123     		movs	r3, #1
 2025 0016 FB60     		str	r3, [r7, #12]
 2026 0018 01E0     		b	.L128
 2027              	.L127:
2059:FreeRTOS/queue.c **** 	}
2060:FreeRTOS/queue.c **** 	else
2061:FreeRTOS/queue.c **** 	{
2062:FreeRTOS/queue.c **** 		xReturn = pdFALSE;
 2028              		.loc 1 2062 0
 2029 001a 0023     		movs	r3, #0
 2030 001c FB60     		str	r3, [r7, #12]
 2031              	.L128:
2063:FreeRTOS/queue.c **** 	}
2064:FreeRTOS/queue.c **** 
2065:FreeRTOS/queue.c **** 	return xReturn;
 2032              		.loc 1 2065 0
 2033 001e FB68     		ldr	r3, [r7, #12]
2066:FreeRTOS/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2034              		.loc 1 2066 0
 2035 0020 1846     		mov	r0, r3
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 73


 2036 0022 1437     		adds	r7, r7, #20
 2037              		.cfi_def_cfa_offset 4
 2038 0024 BD46     		mov	sp, r7
 2039              		.cfi_def_cfa_register 13
 2040              		@ sp needed
 2041 0026 80BC     		pop	{r7}
 2042              		.cfi_restore 7
 2043              		.cfi_def_cfa_offset 0
 2044 0028 7047     		bx	lr
 2045              		.cfi_endproc
 2046              	.LFE86:
 2047              		.size	xQueueIsQueueFullFromISR, .-xQueueIsQueueFullFromISR
 2048 002a 00BF     		.section	.text.vQueueAddToRegistry,"ax",%progbits
 2049              		.align	2
 2050              		.global	vQueueAddToRegistry
 2051              		.thumb
 2052              		.thumb_func
 2053              		.type	vQueueAddToRegistry, %function
 2054              	vQueueAddToRegistry:
 2055              	.LFB87:
2067:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2068:FreeRTOS/queue.c **** 
2069:FreeRTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2070:FreeRTOS/queue.c **** 
2071:FreeRTOS/queue.c **** 	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait 
2072:FreeRTOS/queue.c **** 	{
2073:FreeRTOS/queue.c **** 	BaseType_t xReturn;
2074:FreeRTOS/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2075:FreeRTOS/queue.c **** 
2076:FreeRTOS/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
2077:FreeRTOS/queue.c **** 		is required to prevent an interrupt removing something from the queue
2078:FreeRTOS/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
2079:FreeRTOS/queue.c **** 		portDISABLE_INTERRUPTS();
2080:FreeRTOS/queue.c **** 		{
2081:FreeRTOS/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
2082:FreeRTOS/queue.c **** 			{
2083:FreeRTOS/queue.c **** 				/* The queue is full - do we want to block or just leave without
2084:FreeRTOS/queue.c **** 				posting? */
2085:FreeRTOS/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
2086:FreeRTOS/queue.c **** 				{
2087:FreeRTOS/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
2088:FreeRTOS/queue.c **** 					return indicating that we need to block. */
2089:FreeRTOS/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
2090:FreeRTOS/queue.c **** 					portENABLE_INTERRUPTS();
2091:FreeRTOS/queue.c **** 					return errQUEUE_BLOCKED;
2092:FreeRTOS/queue.c **** 				}
2093:FreeRTOS/queue.c **** 				else
2094:FreeRTOS/queue.c **** 				{
2095:FreeRTOS/queue.c **** 					portENABLE_INTERRUPTS();
2096:FreeRTOS/queue.c **** 					return errQUEUE_FULL;
2097:FreeRTOS/queue.c **** 				}
2098:FreeRTOS/queue.c **** 			}
2099:FreeRTOS/queue.c **** 		}
2100:FreeRTOS/queue.c **** 		portENABLE_INTERRUPTS();
2101:FreeRTOS/queue.c **** 
2102:FreeRTOS/queue.c **** 		portDISABLE_INTERRUPTS();
2103:FreeRTOS/queue.c **** 		{
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 74


2104:FreeRTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2105:FreeRTOS/queue.c **** 			{
2106:FreeRTOS/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
2107:FreeRTOS/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2108:FreeRTOS/queue.c **** 				xReturn = pdPASS;
2109:FreeRTOS/queue.c **** 
2110:FreeRTOS/queue.c **** 				/* Were any co-routines waiting for data to become available? */
2111:FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2112:FreeRTOS/queue.c **** 				{
2113:FreeRTOS/queue.c **** 					/* In this instance the co-routine could be placed directly
2114:FreeRTOS/queue.c **** 					into the ready list as we are within a critical section.
2115:FreeRTOS/queue.c **** 					Instead the same pending ready list mechanism is used as if
2116:FreeRTOS/queue.c **** 					the event were caused from within an interrupt. */
2117:FreeRTOS/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2118:FreeRTOS/queue.c **** 					{
2119:FreeRTOS/queue.c **** 						/* The co-routine waiting has a higher priority so record
2120:FreeRTOS/queue.c **** 						that a yield might be appropriate. */
2121:FreeRTOS/queue.c **** 						xReturn = errQUEUE_YIELD;
2122:FreeRTOS/queue.c **** 					}
2123:FreeRTOS/queue.c **** 					else
2124:FreeRTOS/queue.c **** 					{
2125:FreeRTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2126:FreeRTOS/queue.c **** 					}
2127:FreeRTOS/queue.c **** 				}
2128:FreeRTOS/queue.c **** 				else
2129:FreeRTOS/queue.c **** 				{
2130:FreeRTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2131:FreeRTOS/queue.c **** 				}
2132:FreeRTOS/queue.c **** 			}
2133:FreeRTOS/queue.c **** 			else
2134:FreeRTOS/queue.c **** 			{
2135:FreeRTOS/queue.c **** 				xReturn = errQUEUE_FULL;
2136:FreeRTOS/queue.c **** 			}
2137:FreeRTOS/queue.c **** 		}
2138:FreeRTOS/queue.c **** 		portENABLE_INTERRUPTS();
2139:FreeRTOS/queue.c **** 
2140:FreeRTOS/queue.c **** 		return xReturn;
2141:FreeRTOS/queue.c **** 	}
2142:FreeRTOS/queue.c **** 
2143:FreeRTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2144:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2145:FreeRTOS/queue.c **** 
2146:FreeRTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2147:FreeRTOS/queue.c **** 
2148:FreeRTOS/queue.c **** 	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2149:FreeRTOS/queue.c **** 	{
2150:FreeRTOS/queue.c **** 	BaseType_t xReturn;
2151:FreeRTOS/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2152:FreeRTOS/queue.c **** 
2153:FreeRTOS/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
2154:FreeRTOS/queue.c **** 		is required to prevent an interrupt adding something to the queue
2155:FreeRTOS/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
2156:FreeRTOS/queue.c **** 		portDISABLE_INTERRUPTS();
2157:FreeRTOS/queue.c **** 		{
2158:FreeRTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2159:FreeRTOS/queue.c **** 			{
2160:FreeRTOS/queue.c **** 				/* There are no messages in the queue, do we want to block or just
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 75


2161:FreeRTOS/queue.c **** 				leave with nothing? */
2162:FreeRTOS/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
2163:FreeRTOS/queue.c **** 				{
2164:FreeRTOS/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
2165:FreeRTOS/queue.c **** 					indicating that we need to block. */
2166:FreeRTOS/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
2167:FreeRTOS/queue.c **** 					portENABLE_INTERRUPTS();
2168:FreeRTOS/queue.c **** 					return errQUEUE_BLOCKED;
2169:FreeRTOS/queue.c **** 				}
2170:FreeRTOS/queue.c **** 				else
2171:FreeRTOS/queue.c **** 				{
2172:FreeRTOS/queue.c **** 					portENABLE_INTERRUPTS();
2173:FreeRTOS/queue.c **** 					return errQUEUE_FULL;
2174:FreeRTOS/queue.c **** 				}
2175:FreeRTOS/queue.c **** 			}
2176:FreeRTOS/queue.c **** 			else
2177:FreeRTOS/queue.c **** 			{
2178:FreeRTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2179:FreeRTOS/queue.c **** 			}
2180:FreeRTOS/queue.c **** 		}
2181:FreeRTOS/queue.c **** 		portENABLE_INTERRUPTS();
2182:FreeRTOS/queue.c **** 
2183:FreeRTOS/queue.c **** 		portDISABLE_INTERRUPTS();
2184:FreeRTOS/queue.c **** 		{
2185:FreeRTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2186:FreeRTOS/queue.c **** 			{
2187:FreeRTOS/queue.c **** 				/* Data is available from the queue. */
2188:FreeRTOS/queue.c **** 				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2189:FreeRTOS/queue.c **** 				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2190:FreeRTOS/queue.c **** 				{
2191:FreeRTOS/queue.c **** 					pxQueue->u.pcReadFrom = pxQueue->pcHead;
2192:FreeRTOS/queue.c **** 				}
2193:FreeRTOS/queue.c **** 				else
2194:FreeRTOS/queue.c **** 				{
2195:FreeRTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2196:FreeRTOS/queue.c **** 				}
2197:FreeRTOS/queue.c **** 				--( pxQueue->uxMessagesWaiting );
2198:FreeRTOS/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->u
2199:FreeRTOS/queue.c **** 
2200:FreeRTOS/queue.c **** 				xReturn = pdPASS;
2201:FreeRTOS/queue.c **** 
2202:FreeRTOS/queue.c **** 				/* Were any co-routines waiting for space to become available? */
2203:FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2204:FreeRTOS/queue.c **** 				{
2205:FreeRTOS/queue.c **** 					/* In this instance the co-routine could be placed directly
2206:FreeRTOS/queue.c **** 					into the ready list as we are within a critical section.
2207:FreeRTOS/queue.c **** 					Instead the same pending ready list mechanism is used as if
2208:FreeRTOS/queue.c **** 					the event were caused from within an interrupt. */
2209:FreeRTOS/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2210:FreeRTOS/queue.c **** 					{
2211:FreeRTOS/queue.c **** 						xReturn = errQUEUE_YIELD;
2212:FreeRTOS/queue.c **** 					}
2213:FreeRTOS/queue.c **** 					else
2214:FreeRTOS/queue.c **** 					{
2215:FreeRTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2216:FreeRTOS/queue.c **** 					}
2217:FreeRTOS/queue.c **** 				}
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 76


2218:FreeRTOS/queue.c **** 				else
2219:FreeRTOS/queue.c **** 				{
2220:FreeRTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2221:FreeRTOS/queue.c **** 				}
2222:FreeRTOS/queue.c **** 			}
2223:FreeRTOS/queue.c **** 			else
2224:FreeRTOS/queue.c **** 			{
2225:FreeRTOS/queue.c **** 				xReturn = pdFAIL;
2226:FreeRTOS/queue.c **** 			}
2227:FreeRTOS/queue.c **** 		}
2228:FreeRTOS/queue.c **** 		portENABLE_INTERRUPTS();
2229:FreeRTOS/queue.c **** 
2230:FreeRTOS/queue.c **** 		return xReturn;
2231:FreeRTOS/queue.c **** 	}
2232:FreeRTOS/queue.c **** 
2233:FreeRTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2234:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2235:FreeRTOS/queue.c **** 
2236:FreeRTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2237:FreeRTOS/queue.c **** 
2238:FreeRTOS/queue.c **** 	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRou
2239:FreeRTOS/queue.c **** 	{
2240:FreeRTOS/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2241:FreeRTOS/queue.c **** 
2242:FreeRTOS/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
2243:FreeRTOS/queue.c **** 		exit without doing anything. */
2244:FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2245:FreeRTOS/queue.c **** 		{
2246:FreeRTOS/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2247:FreeRTOS/queue.c **** 
2248:FreeRTOS/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
2249:FreeRTOS/queue.c **** 			co-routine has not already been woken. */
2250:FreeRTOS/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
2251:FreeRTOS/queue.c **** 			{
2252:FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2253:FreeRTOS/queue.c **** 				{
2254:FreeRTOS/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2255:FreeRTOS/queue.c **** 					{
2256:FreeRTOS/queue.c **** 						return pdTRUE;
2257:FreeRTOS/queue.c **** 					}
2258:FreeRTOS/queue.c **** 					else
2259:FreeRTOS/queue.c **** 					{
2260:FreeRTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2261:FreeRTOS/queue.c **** 					}
2262:FreeRTOS/queue.c **** 				}
2263:FreeRTOS/queue.c **** 				else
2264:FreeRTOS/queue.c **** 				{
2265:FreeRTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2266:FreeRTOS/queue.c **** 				}
2267:FreeRTOS/queue.c **** 			}
2268:FreeRTOS/queue.c **** 			else
2269:FreeRTOS/queue.c **** 			{
2270:FreeRTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2271:FreeRTOS/queue.c **** 			}
2272:FreeRTOS/queue.c **** 		}
2273:FreeRTOS/queue.c **** 		else
2274:FreeRTOS/queue.c **** 		{
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 77


2275:FreeRTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2276:FreeRTOS/queue.c **** 		}
2277:FreeRTOS/queue.c **** 
2278:FreeRTOS/queue.c **** 		return xCoRoutinePreviouslyWoken;
2279:FreeRTOS/queue.c **** 	}
2280:FreeRTOS/queue.c **** 
2281:FreeRTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2282:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2283:FreeRTOS/queue.c **** 
2284:FreeRTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2285:FreeRTOS/queue.c **** 
2286:FreeRTOS/queue.c **** 	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWo
2287:FreeRTOS/queue.c **** 	{
2288:FreeRTOS/queue.c **** 	BaseType_t xReturn;
2289:FreeRTOS/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2290:FreeRTOS/queue.c **** 
2291:FreeRTOS/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
2292:FreeRTOS/queue.c **** 		not then just leave without doing anything. */
2293:FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2294:FreeRTOS/queue.c **** 		{
2295:FreeRTOS/queue.c **** 			/* Copy the data from the queue. */
2296:FreeRTOS/queue.c **** 			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2297:FreeRTOS/queue.c **** 			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2298:FreeRTOS/queue.c **** 			{
2299:FreeRTOS/queue.c **** 				pxQueue->u.pcReadFrom = pxQueue->pcHead;
2300:FreeRTOS/queue.c **** 			}
2301:FreeRTOS/queue.c **** 			else
2302:FreeRTOS/queue.c **** 			{
2303:FreeRTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2304:FreeRTOS/queue.c **** 			}
2305:FreeRTOS/queue.c **** 			--( pxQueue->uxMessagesWaiting );
2306:FreeRTOS/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->ux
2307:FreeRTOS/queue.c **** 
2308:FreeRTOS/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
2309:FreeRTOS/queue.c **** 			{
2310:FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2311:FreeRTOS/queue.c **** 				{
2312:FreeRTOS/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2313:FreeRTOS/queue.c **** 					{
2314:FreeRTOS/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
2315:FreeRTOS/queue.c **** 					}
2316:FreeRTOS/queue.c **** 					else
2317:FreeRTOS/queue.c **** 					{
2318:FreeRTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2319:FreeRTOS/queue.c **** 					}
2320:FreeRTOS/queue.c **** 				}
2321:FreeRTOS/queue.c **** 				else
2322:FreeRTOS/queue.c **** 				{
2323:FreeRTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2324:FreeRTOS/queue.c **** 				}
2325:FreeRTOS/queue.c **** 			}
2326:FreeRTOS/queue.c **** 			else
2327:FreeRTOS/queue.c **** 			{
2328:FreeRTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2329:FreeRTOS/queue.c **** 			}
2330:FreeRTOS/queue.c **** 
2331:FreeRTOS/queue.c **** 			xReturn = pdPASS;
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 78


2332:FreeRTOS/queue.c **** 		}
2333:FreeRTOS/queue.c **** 		else
2334:FreeRTOS/queue.c **** 		{
2335:FreeRTOS/queue.c **** 			xReturn = pdFAIL;
2336:FreeRTOS/queue.c **** 		}
2337:FreeRTOS/queue.c **** 
2338:FreeRTOS/queue.c **** 		return xReturn;
2339:FreeRTOS/queue.c **** 	}
2340:FreeRTOS/queue.c **** 
2341:FreeRTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2342:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2343:FreeRTOS/queue.c **** 
2344:FreeRTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2345:FreeRTOS/queue.c **** 
2346:FreeRTOS/queue.c **** 	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified
2347:FreeRTOS/queue.c **** 	{
 2056              		.loc 1 2347 0
 2057              		.cfi_startproc
 2058              		@ args = 0, pretend = 0, frame = 16
 2059              		@ frame_needed = 1, uses_anonymous_args = 0
 2060              		@ link register save eliminated.
 2061 0000 80B4     		push	{r7}
 2062              		.cfi_def_cfa_offset 4
 2063              		.cfi_offset 7, -4
 2064 0002 85B0     		sub	sp, sp, #20
 2065              		.cfi_def_cfa_offset 24
 2066 0004 00AF     		add	r7, sp, #0
 2067              		.cfi_def_cfa_register 7
 2068 0006 7860     		str	r0, [r7, #4]
 2069 0008 3960     		str	r1, [r7]
2348:FreeRTOS/queue.c **** 	UBaseType_t ux;
2349:FreeRTOS/queue.c **** 
2350:FreeRTOS/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
2351:FreeRTOS/queue.c **** 		a free slot. */
2352:FreeRTOS/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2070              		.loc 1 2352 0
 2071 000a 0023     		movs	r3, #0
 2072 000c FB60     		str	r3, [r7, #12]
 2073 000e 14E0     		b	.L131
 2074              	.L134:
2353:FreeRTOS/queue.c **** 		{
2354:FreeRTOS/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 2075              		.loc 1 2354 0
 2076 0010 0E4A     		ldr	r2, .L135
 2077 0012 FB68     		ldr	r3, [r7, #12]
 2078 0014 52F83330 		ldr	r3, [r2, r3, lsl #3]
 2079 0018 002B     		cmp	r3, #0
 2080 001a 0BD1     		bne	.L132
2355:FreeRTOS/queue.c **** 			{
2356:FreeRTOS/queue.c **** 				/* Store the information on this queue. */
2357:FreeRTOS/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 2081              		.loc 1 2357 0
 2082 001c 0B49     		ldr	r1, .L135
 2083 001e FB68     		ldr	r3, [r7, #12]
 2084 0020 3A68     		ldr	r2, [r7]
 2085 0022 41F83320 		str	r2, [r1, r3, lsl #3]
2358:FreeRTOS/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 79


 2086              		.loc 1 2358 0
 2087 0026 094A     		ldr	r2, .L135
 2088 0028 FB68     		ldr	r3, [r7, #12]
 2089 002a DB00     		lsls	r3, r3, #3
 2090 002c 1344     		add	r3, r3, r2
 2091 002e 7A68     		ldr	r2, [r7, #4]
 2092 0030 5A60     		str	r2, [r3, #4]
2359:FreeRTOS/queue.c **** 
2360:FreeRTOS/queue.c **** 				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2361:FreeRTOS/queue.c **** 				break;
 2093              		.loc 1 2361 0
 2094 0032 05E0     		b	.L133
 2095              	.L132:
2352:FreeRTOS/queue.c **** 		{
 2096              		.loc 1 2352 0 discriminator 2
 2097 0034 FB68     		ldr	r3, [r7, #12]
 2098 0036 0133     		adds	r3, r3, #1
 2099 0038 FB60     		str	r3, [r7, #12]
 2100              	.L131:
2352:FreeRTOS/queue.c **** 		{
 2101              		.loc 1 2352 0 is_stmt 0 discriminator 1
 2102 003a FB68     		ldr	r3, [r7, #12]
 2103 003c 092B     		cmp	r3, #9
 2104 003e E7D9     		bls	.L134
 2105              	.L133:
2362:FreeRTOS/queue.c **** 			}
2363:FreeRTOS/queue.c **** 			else
2364:FreeRTOS/queue.c **** 			{
2365:FreeRTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2366:FreeRTOS/queue.c **** 			}
2367:FreeRTOS/queue.c **** 		}
2368:FreeRTOS/queue.c **** 	}
 2106              		.loc 1 2368 0 is_stmt 1
 2107 0040 00BF     		nop
 2108 0042 1437     		adds	r7, r7, #20
 2109              		.cfi_def_cfa_offset 4
 2110 0044 BD46     		mov	sp, r7
 2111              		.cfi_def_cfa_register 13
 2112              		@ sp needed
 2113 0046 80BC     		pop	{r7}
 2114              		.cfi_restore 7
 2115              		.cfi_def_cfa_offset 0
 2116 0048 7047     		bx	lr
 2117              	.L136:
 2118 004a 00BF     		.align	2
 2119              	.L135:
 2120 004c 00000000 		.word	xQueueRegistry
 2121              		.cfi_endproc
 2122              	.LFE87:
 2123              		.size	vQueueAddToRegistry, .-vQueueAddToRegistry
 2124              		.section	.text.vQueueUnregisterQueue,"ax",%progbits
 2125              		.align	2
 2126              		.global	vQueueUnregisterQueue
 2127              		.thumb
 2128              		.thumb_func
 2129              		.type	vQueueUnregisterQueue, %function
 2130              	vQueueUnregisterQueue:
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 80


 2131              	.LFB88:
2369:FreeRTOS/queue.c **** 
2370:FreeRTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2371:FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2372:FreeRTOS/queue.c **** 
2373:FreeRTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2374:FreeRTOS/queue.c **** 
2375:FreeRTOS/queue.c **** 	void vQueueUnregisterQueue( QueueHandle_t xQueue )
2376:FreeRTOS/queue.c **** 	{
 2132              		.loc 1 2376 0
 2133              		.cfi_startproc
 2134              		@ args = 0, pretend = 0, frame = 16
 2135              		@ frame_needed = 1, uses_anonymous_args = 0
 2136              		@ link register save eliminated.
 2137 0000 80B4     		push	{r7}
 2138              		.cfi_def_cfa_offset 4
 2139              		.cfi_offset 7, -4
 2140 0002 85B0     		sub	sp, sp, #20
 2141              		.cfi_def_cfa_offset 24
 2142 0004 00AF     		add	r7, sp, #0
 2143              		.cfi_def_cfa_register 7
 2144 0006 7860     		str	r0, [r7, #4]
2377:FreeRTOS/queue.c **** 	UBaseType_t ux;
2378:FreeRTOS/queue.c **** 
2379:FreeRTOS/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
2380:FreeRTOS/queue.c **** 		registry. */
2381:FreeRTOS/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2145              		.loc 1 2381 0
 2146 0008 0023     		movs	r3, #0
 2147 000a FB60     		str	r3, [r7, #12]
 2148 000c 10E0     		b	.L138
 2149              	.L141:
2382:FreeRTOS/queue.c **** 		{
2383:FreeRTOS/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 2150              		.loc 1 2383 0
 2151 000e 0C4A     		ldr	r2, .L142
 2152 0010 FB68     		ldr	r3, [r7, #12]
 2153 0012 DB00     		lsls	r3, r3, #3
 2154 0014 1344     		add	r3, r3, r2
 2155 0016 5A68     		ldr	r2, [r3, #4]
 2156 0018 7B68     		ldr	r3, [r7, #4]
 2157 001a 9A42     		cmp	r2, r3
 2158 001c 05D1     		bne	.L139
2384:FreeRTOS/queue.c **** 			{
2385:FreeRTOS/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
2386:FreeRTOS/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
 2159              		.loc 1 2386 0
 2160 001e 084A     		ldr	r2, .L142
 2161 0020 FB68     		ldr	r3, [r7, #12]
 2162 0022 0021     		movs	r1, #0
 2163 0024 42F83310 		str	r1, [r2, r3, lsl #3]
2387:FreeRTOS/queue.c **** 				break;
 2164              		.loc 1 2387 0
 2165 0028 05E0     		b	.L140
 2166              	.L139:
2381:FreeRTOS/queue.c **** 		{
 2167              		.loc 1 2381 0 discriminator 2
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 81


 2168 002a FB68     		ldr	r3, [r7, #12]
 2169 002c 0133     		adds	r3, r3, #1
 2170 002e FB60     		str	r3, [r7, #12]
 2171              	.L138:
2381:FreeRTOS/queue.c **** 		{
 2172              		.loc 1 2381 0 is_stmt 0 discriminator 1
 2173 0030 FB68     		ldr	r3, [r7, #12]
 2174 0032 092B     		cmp	r3, #9
 2175 0034 EBD9     		bls	.L141
 2176              	.L140:
2388:FreeRTOS/queue.c **** 			}
2389:FreeRTOS/queue.c **** 			else
2390:FreeRTOS/queue.c **** 			{
2391:FreeRTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2392:FreeRTOS/queue.c **** 			}
2393:FreeRTOS/queue.c **** 		}
2394:FreeRTOS/queue.c **** 
2395:FreeRTOS/queue.c **** 	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2177              		.loc 1 2395 0 is_stmt 1
 2178 0036 00BF     		nop
 2179 0038 1437     		adds	r7, r7, #20
 2180              		.cfi_def_cfa_offset 4
 2181 003a BD46     		mov	sp, r7
 2182              		.cfi_def_cfa_register 13
 2183              		@ sp needed
 2184 003c 80BC     		pop	{r7}
 2185              		.cfi_restore 7
 2186              		.cfi_def_cfa_offset 0
 2187 003e 7047     		bx	lr
 2188              	.L143:
 2189              		.align	2
 2190              	.L142:
 2191 0040 00000000 		.word	xQueueRegistry
 2192              		.cfi_endproc
 2193              	.LFE88:
 2194              		.size	vQueueUnregisterQueue, .-vQueueUnregisterQueue
 2195              		.text
 2196              	.Letext0:
 2197              		.file 2 "c:\\program files (x86)\\cypress\\psoc creator\\4.4\\psoc creator\\import\\gnu\\arm\\5.4.
 2198              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\4.4\\psoc creator\\import\\gnu\\arm\\5.4.
 2199              		.file 4 "c:\\program files (x86)\\cypress\\psoc creator\\4.4\\psoc creator\\import\\gnu\\arm\\5.4.
 2200              		.file 5 "FreeRTOS\\portmacro.h"
 2201              		.file 6 "FreeRTOS\\list.h"
 2202              		.file 7 "FreeRTOS\\task.h"
 2203              		.file 8 "FreeRTOS\\queue.h"
 2204              		.file 9 "Generated_Source\\PSoC5/core_cm3.h"
 2205              		.section	.debug_info,"",%progbits
 2206              	.Ldebug_info0:
 2207 0000 890B0000 		.4byte	0xb89
 2208 0004 0400     		.2byte	0x4
 2209 0006 00000000 		.4byte	.Ldebug_abbrev0
 2210 000a 04       		.byte	0x4
 2211 000b 01       		.uleb128 0x1
 2212 000c DE000000 		.4byte	.LASF117
 2213 0010 0C       		.byte	0xc
 2214 0011 3C070000 		.4byte	.LASF118
 2215 0015 86000000 		.4byte	.LASF119
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 82


 2216 0019 00000000 		.4byte	.Ldebug_ranges0+0
 2217 001d 00000000 		.4byte	0
 2218 0021 00000000 		.4byte	.Ldebug_line0
 2219 0025 02       		.uleb128 0x2
 2220 0026 41000000 		.4byte	.LASF3
 2221 002a 02       		.byte	0x2
 2222 002b D8       		.byte	0xd8
 2223 002c 30000000 		.4byte	0x30
 2224 0030 03       		.uleb128 0x3
 2225 0031 04       		.byte	0x4
 2226 0032 07       		.byte	0x7
 2227 0033 20040000 		.4byte	.LASF0
 2228 0037 04       		.uleb128 0x4
 2229 0038 04       		.byte	0x4
 2230 0039 05       		.byte	0x5
 2231 003a 696E7400 		.ascii	"int\000"
 2232 003e 03       		.uleb128 0x3
 2233 003f 08       		.byte	0x8
 2234 0040 05       		.byte	0x5
 2235 0041 96020000 		.4byte	.LASF1
 2236 0045 03       		.uleb128 0x3
 2237 0046 08       		.byte	0x8
 2238 0047 04       		.byte	0x4
 2239 0048 68030000 		.4byte	.LASF2
 2240 004c 02       		.uleb128 0x2
 2241 004d DD040000 		.4byte	.LASF4
 2242 0051 03       		.byte	0x3
 2243 0052 1B       		.byte	0x1b
 2244 0053 57000000 		.4byte	0x57
 2245 0057 03       		.uleb128 0x3
 2246 0058 01       		.byte	0x1
 2247 0059 06       		.byte	0x6
 2248 005a 33060000 		.4byte	.LASF5
 2249 005e 02       		.uleb128 0x2
 2250 005f 06030000 		.4byte	.LASF6
 2251 0063 03       		.byte	0x3
 2252 0064 1D       		.byte	0x1d
 2253 0065 69000000 		.4byte	0x69
 2254 0069 03       		.uleb128 0x3
 2255 006a 01       		.byte	0x1
 2256 006b 08       		.byte	0x8
 2257 006c A2030000 		.4byte	.LASF7
 2258 0070 03       		.uleb128 0x3
 2259 0071 02       		.byte	0x2
 2260 0072 05       		.byte	0x5
 2261 0073 98010000 		.4byte	.LASF8
 2262 0077 03       		.uleb128 0x3
 2263 0078 02       		.byte	0x2
 2264 0079 07       		.byte	0x7
 2265 007a BC040000 		.4byte	.LASF9
 2266 007e 02       		.uleb128 0x2
 2267 007f 20060000 		.4byte	.LASF10
 2268 0083 03       		.byte	0x3
 2269 0084 3F       		.byte	0x3f
 2270 0085 89000000 		.4byte	0x89
 2271 0089 03       		.uleb128 0x3
 2272 008a 04       		.byte	0x4
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 83


 2273 008b 05       		.byte	0x5
 2274 008c D1020000 		.4byte	.LASF11
 2275 0090 02       		.uleb128 0x2
 2276 0091 76010000 		.4byte	.LASF12
 2277 0095 03       		.byte	0x3
 2278 0096 41       		.byte	0x41
 2279 0097 9B000000 		.4byte	0x9b
 2280 009b 03       		.uleb128 0x3
 2281 009c 04       		.byte	0x4
 2282 009d 07       		.byte	0x7
 2283 009e AB050000 		.4byte	.LASF13
 2284 00a2 03       		.uleb128 0x3
 2285 00a3 08       		.byte	0x8
 2286 00a4 07       		.byte	0x7
 2287 00a5 E2030000 		.4byte	.LASF14
 2288 00a9 03       		.uleb128 0x3
 2289 00aa 04       		.byte	0x4
 2290 00ab 07       		.byte	0x7
 2291 00ac 7B060000 		.4byte	.LASF15
 2292 00b0 05       		.uleb128 0x5
 2293 00b1 04       		.byte	0x4
 2294 00b2 03       		.uleb128 0x3
 2295 00b3 01       		.byte	0x1
 2296 00b4 08       		.byte	0x8
 2297 00b5 07050000 		.4byte	.LASF16
 2298 00b9 06       		.uleb128 0x6
 2299 00ba 04       		.byte	0x4
 2300 00bb BF000000 		.4byte	0xbf
 2301 00bf 07       		.uleb128 0x7
 2302 00c0 B2000000 		.4byte	0xb2
 2303 00c4 06       		.uleb128 0x6
 2304 00c5 04       		.byte	0x4
 2305 00c6 CA000000 		.4byte	0xca
 2306 00ca 08       		.uleb128 0x8
 2307 00cb 02       		.uleb128 0x2
 2308 00cc 26000000 		.4byte	.LASF17
 2309 00d0 04       		.byte	0x4
 2310 00d1 14       		.byte	0x14
 2311 00d2 4C000000 		.4byte	0x4c
 2312 00d6 02       		.uleb128 0x2
 2313 00d7 D7010000 		.4byte	.LASF18
 2314 00db 04       		.byte	0x4
 2315 00dc 18       		.byte	0x18
 2316 00dd 5E000000 		.4byte	0x5e
 2317 00e1 02       		.uleb128 0x2
 2318 00e2 DA030000 		.4byte	.LASF19
 2319 00e6 04       		.byte	0x4
 2320 00e7 2C       		.byte	0x2c
 2321 00e8 7E000000 		.4byte	0x7e
 2322 00ec 02       		.uleb128 0x2
 2323 00ed 01040000 		.4byte	.LASF20
 2324 00f1 04       		.byte	0x4
 2325 00f2 30       		.byte	0x30
 2326 00f3 90000000 		.4byte	0x90
 2327 00f7 03       		.uleb128 0x3
 2328 00f8 04       		.byte	0x4
 2329 00f9 04       		.byte	0x4
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 84


 2330 00fa 5F020000 		.4byte	.LASF21
 2331 00fe 03       		.uleb128 0x3
 2332 00ff 08       		.byte	0x8
 2333 0100 04       		.byte	0x4
 2334 0101 CA060000 		.4byte	.LASF22
 2335 0105 02       		.uleb128 0x2
 2336 0106 38040000 		.4byte	.LASF23
 2337 010a 05       		.byte	0x5
 2338 010b 62       		.byte	0x62
 2339 010c 89000000 		.4byte	0x89
 2340 0110 02       		.uleb128 0x2
 2341 0111 BD050000 		.4byte	.LASF24
 2342 0115 05       		.byte	0x5
 2343 0116 63       		.byte	0x63
 2344 0117 9B000000 		.4byte	0x9b
 2345 011b 02       		.uleb128 0x2
 2346 011c A4020000 		.4byte	.LASF25
 2347 0120 05       		.byte	0x5
 2348 0121 69       		.byte	0x69
 2349 0122 EC000000 		.4byte	0xec
 2350 0126 09       		.uleb128 0x9
 2351 0127 5D030000 		.4byte	.LASF32
 2352 012b 14       		.byte	0x14
 2353 012c 06       		.byte	0x6
 2354 012d B5       		.byte	0xb5
 2355 012e 6F010000 		.4byte	0x16f
 2356 0132 0A       		.uleb128 0xa
 2357 0133 10030000 		.4byte	.LASF26
 2358 0137 06       		.byte	0x6
 2359 0138 B8       		.byte	0xb8
 2360 0139 1B010000 		.4byte	0x11b
 2361 013d 00       		.byte	0
 2362 013e 0A       		.uleb128 0xa
 2363 013f 00000000 		.4byte	.LASF27
 2364 0143 06       		.byte	0x6
 2365 0144 B9       		.byte	0xb9
 2366 0145 6F010000 		.4byte	0x16f
 2367 0149 04       		.byte	0x4
 2368 014a 0A       		.uleb128 0xa
 2369 014b 48000000 		.4byte	.LASF28
 2370 014f 06       		.byte	0x6
 2371 0150 BA       		.byte	0xba
 2372 0151 6F010000 		.4byte	0x16f
 2373 0155 08       		.byte	0x8
 2374 0156 0A       		.uleb128 0xa
 2375 0157 A2010000 		.4byte	.LASF29
 2376 015b 06       		.byte	0x6
 2377 015c BB       		.byte	0xbb
 2378 015d B0000000 		.4byte	0xb0
 2379 0161 0C       		.byte	0xc
 2380 0162 0A       		.uleb128 0xa
 2381 0163 1A000000 		.4byte	.LASF30
 2382 0167 06       		.byte	0x6
 2383 0168 BC       		.byte	0xbc
 2384 0169 B0000000 		.4byte	0xb0
 2385 016d 10       		.byte	0x10
 2386 016e 00       		.byte	0
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 85


 2387 016f 06       		.uleb128 0x6
 2388 0170 04       		.byte	0x4
 2389 0171 26010000 		.4byte	0x126
 2390 0175 02       		.uleb128 0x2
 2391 0176 2D040000 		.4byte	.LASF31
 2392 017a 06       		.byte	0x6
 2393 017b BF       		.byte	0xbf
 2394 017c 26010000 		.4byte	0x126
 2395 0180 09       		.uleb128 0x9
 2396 0181 13070000 		.4byte	.LASF33
 2397 0185 0C       		.byte	0xc
 2398 0186 06       		.byte	0x6
 2399 0187 C1       		.byte	0xc1
 2400 0188 B1010000 		.4byte	0x1b1
 2401 018c 0A       		.uleb128 0xa
 2402 018d 10030000 		.4byte	.LASF26
 2403 0191 06       		.byte	0x6
 2404 0192 C4       		.byte	0xc4
 2405 0193 1B010000 		.4byte	0x11b
 2406 0197 00       		.byte	0
 2407 0198 0A       		.uleb128 0xa
 2408 0199 00000000 		.4byte	.LASF27
 2409 019d 06       		.byte	0x6
 2410 019e C5       		.byte	0xc5
 2411 019f 6F010000 		.4byte	0x16f
 2412 01a3 04       		.byte	0x4
 2413 01a4 0A       		.uleb128 0xa
 2414 01a5 48000000 		.4byte	.LASF28
 2415 01a9 06       		.byte	0x6
 2416 01aa C6       		.byte	0xc6
 2417 01ab 6F010000 		.4byte	0x16f
 2418 01af 08       		.byte	0x8
 2419 01b0 00       		.byte	0
 2420 01b1 02       		.uleb128 0x2
 2421 01b2 87020000 		.4byte	.LASF34
 2422 01b6 06       		.byte	0x6
 2423 01b7 C8       		.byte	0xc8
 2424 01b8 80010000 		.4byte	0x180
 2425 01bc 09       		.uleb128 0x9
 2426 01bd DA020000 		.4byte	.LASF35
 2427 01c1 14       		.byte	0x14
 2428 01c2 06       		.byte	0x6
 2429 01c3 CD       		.byte	0xcd
 2430 01c4 ED010000 		.4byte	0x1ed
 2431 01c8 0A       		.uleb128 0xa
 2432 01c9 D7050000 		.4byte	.LASF36
 2433 01cd 06       		.byte	0x6
 2434 01ce D0       		.byte	0xd0
 2435 01cf 10010000 		.4byte	0x110
 2436 01d3 00       		.byte	0
 2437 01d4 0A       		.uleb128 0xa
 2438 01d5 FE060000 		.4byte	.LASF37
 2439 01d9 06       		.byte	0x6
 2440 01da D1       		.byte	0xd1
 2441 01db ED010000 		.4byte	0x1ed
 2442 01df 04       		.byte	0x4
 2443 01e0 0A       		.uleb128 0xa
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 86


 2444 01e1 2A060000 		.4byte	.LASF38
 2445 01e5 06       		.byte	0x6
 2446 01e6 D2       		.byte	0xd2
 2447 01e7 B1010000 		.4byte	0x1b1
 2448 01eb 08       		.byte	0x8
 2449 01ec 00       		.byte	0
 2450 01ed 06       		.uleb128 0x6
 2451 01ee 04       		.byte	0x4
 2452 01ef 75010000 		.4byte	0x175
 2453 01f3 02       		.uleb128 0x2
 2454 01f4 80020000 		.4byte	.LASF39
 2455 01f8 06       		.byte	0x6
 2456 01f9 D4       		.byte	0xd4
 2457 01fa BC010000 		.4byte	0x1bc
 2458 01fe 09       		.uleb128 0x9
 2459 01ff 2D000000 		.4byte	.LASF40
 2460 0203 08       		.byte	0x8
 2461 0204 07       		.byte	0x7
 2462 0205 86       		.byte	0x86
 2463 0206 23020000 		.4byte	0x223
 2464 020a 0A       		.uleb128 0xa
 2465 020b C0030000 		.4byte	.LASF41
 2466 020f 07       		.byte	0x7
 2467 0210 88       		.byte	0x88
 2468 0211 05010000 		.4byte	0x105
 2469 0215 00       		.byte	0
 2470 0216 0A       		.uleb128 0xa
 2471 0217 B0030000 		.4byte	.LASF42
 2472 021b 07       		.byte	0x7
 2473 021c 89       		.byte	0x89
 2474 021d 1B010000 		.4byte	0x11b
 2475 0221 04       		.byte	0x4
 2476 0222 00       		.byte	0
 2477 0223 02       		.uleb128 0x2
 2478 0224 37000000 		.4byte	.LASF43
 2479 0228 07       		.byte	0x7
 2480 0229 8A       		.byte	0x8a
 2481 022a FE010000 		.4byte	0x1fe
 2482 022e 02       		.uleb128 0x2
 2483 022f A8060000 		.4byte	.LASF44
 2484 0233 08       		.byte	0x8
 2485 0234 58       		.byte	0x58
 2486 0235 B0000000 		.4byte	0xb0
 2487 0239 0B       		.uleb128 0xb
 2488 023a 04       		.byte	0x4
 2489 023b 01       		.byte	0x1
 2490 023c 88       		.byte	0x88
 2491 023d 58020000 		.4byte	0x258
 2492 0241 0C       		.uleb128 0xc
 2493 0242 41050000 		.4byte	.LASF45
 2494 0246 01       		.byte	0x1
 2495 0247 8A       		.byte	0x8a
 2496 0248 58020000 		.4byte	0x258
 2497 024c 0C       		.uleb128 0xc
 2498 024d 5E060000 		.4byte	.LASF46
 2499 0251 01       		.byte	0x1
 2500 0252 8B       		.byte	0x8b
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 87


 2501 0253 10010000 		.4byte	0x110
 2502 0257 00       		.byte	0
 2503 0258 06       		.uleb128 0x6
 2504 0259 04       		.byte	0x4
 2505 025a CB000000 		.4byte	0xcb
 2506 025e 09       		.uleb128 0x9
 2507 025f 96040000 		.4byte	.LASF47
 2508 0263 4C       		.byte	0x4c
 2509 0264 01       		.byte	0x1
 2510 0265 82       		.byte	0x82
 2511 0266 ED020000 		.4byte	0x2ed
 2512 026a 0A       		.uleb128 0xa
 2513 026b 79020000 		.4byte	.LASF48
 2514 026f 01       		.byte	0x1
 2515 0270 84       		.byte	0x84
 2516 0271 58020000 		.4byte	0x258
 2517 0275 00       		.byte	0
 2518 0276 0A       		.uleb128 0xa
 2519 0277 1A020000 		.4byte	.LASF49
 2520 027b 01       		.byte	0x1
 2521 027c 85       		.byte	0x85
 2522 027d 58020000 		.4byte	0x258
 2523 0281 04       		.byte	0x4
 2524 0282 0A       		.uleb128 0xa
 2525 0283 0C050000 		.4byte	.LASF50
 2526 0287 01       		.byte	0x1
 2527 0288 86       		.byte	0x86
 2528 0289 58020000 		.4byte	0x258
 2529 028d 08       		.byte	0x8
 2530 028e 0D       		.uleb128 0xd
 2531 028f 7500     		.ascii	"u\000"
 2532 0291 01       		.byte	0x1
 2533 0292 8C       		.byte	0x8c
 2534 0293 39020000 		.4byte	0x239
 2535 0297 0C       		.byte	0xc
 2536 0298 0A       		.uleb128 0xa
 2537 0299 EA060000 		.4byte	.LASF51
 2538 029d 01       		.byte	0x1
 2539 029e 8E       		.byte	0x8e
 2540 029f F3010000 		.4byte	0x1f3
 2541 02a3 10       		.byte	0x10
 2542 02a4 0A       		.uleb128 0xa
 2543 02a5 64040000 		.4byte	.LASF52
 2544 02a9 01       		.byte	0x1
 2545 02aa 8F       		.byte	0x8f
 2546 02ab F3010000 		.4byte	0x1f3
 2547 02af 24       		.byte	0x24
 2548 02b0 0A       		.uleb128 0xa
 2549 02b1 0E060000 		.4byte	.LASF53
 2550 02b5 01       		.byte	0x1
 2551 02b6 91       		.byte	0x91
 2552 02b7 ED020000 		.4byte	0x2ed
 2553 02bb 38       		.byte	0x38
 2554 02bc 0A       		.uleb128 0xa
 2555 02bd C8020000 		.4byte	.LASF54
 2556 02c1 01       		.byte	0x1
 2557 02c2 92       		.byte	0x92
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 88


 2558 02c3 10010000 		.4byte	0x110
 2559 02c7 3C       		.byte	0x3c
 2560 02c8 0A       		.uleb128 0xa
 2561 02c9 40030000 		.4byte	.LASF55
 2562 02cd 01       		.byte	0x1
 2563 02ce 93       		.byte	0x93
 2564 02cf 10010000 		.4byte	0x110
 2565 02d3 40       		.byte	0x40
 2566 02d4 0A       		.uleb128 0xa
 2567 02d5 3F060000 		.4byte	.LASF56
 2568 02d9 01       		.byte	0x1
 2569 02da 95       		.byte	0x95
 2570 02db F2020000 		.4byte	0x2f2
 2571 02df 44       		.byte	0x44
 2572 02e0 0A       		.uleb128 0xa
 2573 02e1 4C050000 		.4byte	.LASF57
 2574 02e5 01       		.byte	0x1
 2575 02e6 96       		.byte	0x96
 2576 02e7 F2020000 		.4byte	0x2f2
 2577 02eb 48       		.byte	0x48
 2578 02ec 00       		.byte	0
 2579 02ed 0E       		.uleb128 0xe
 2580 02ee 10010000 		.4byte	0x110
 2581 02f2 0E       		.uleb128 0xe
 2582 02f3 05010000 		.4byte	0x105
 2583 02f7 02       		.uleb128 0x2
 2584 02f8 39030000 		.4byte	.LASF58
 2585 02fc 01       		.byte	0x1
 2586 02fd A1       		.byte	0xa1
 2587 02fe 5E020000 		.4byte	0x25e
 2588 0302 02       		.uleb128 0x2
 2589 0303 F9030000 		.4byte	.LASF59
 2590 0307 01       		.byte	0x1
 2591 0308 A5       		.byte	0xa5
 2592 0309 F7020000 		.4byte	0x2f7
 2593 030d 09       		.uleb128 0x9
 2594 030e 72000000 		.4byte	.LASF60
 2595 0312 08       		.byte	0x8
 2596 0313 01       		.byte	0x1
 2597 0314 B2       		.byte	0xb2
 2598 0315 32030000 		.4byte	0x332
 2599 0319 0A       		.uleb128 0xa
 2600 031a 53000000 		.4byte	.LASF61
 2601 031e 01       		.byte	0x1
 2602 031f B4       		.byte	0xb4
 2603 0320 B9000000 		.4byte	0xb9
 2604 0324 00       		.byte	0
 2605 0325 0A       		.uleb128 0xa
 2606 0326 F7050000 		.4byte	.LASF62
 2607 032a 01       		.byte	0x1
 2608 032b B5       		.byte	0xb5
 2609 032c 2E020000 		.4byte	0x22e
 2610 0330 04       		.byte	0x4
 2611 0331 00       		.byte	0
 2612 0332 02       		.uleb128 0x2
 2613 0333 51040000 		.4byte	.LASF63
 2614 0337 01       		.byte	0x1
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 89


 2615 0338 B6       		.byte	0xb6
 2616 0339 0D030000 		.4byte	0x30d
 2617 033d 02       		.uleb128 0x2
 2618 033e 65020000 		.4byte	.LASF64
 2619 0342 01       		.byte	0x1
 2620 0343 BB       		.byte	0xbb
 2621 0344 32030000 		.4byte	0x332
 2622 0348 0F       		.uleb128 0xf
 2623 0349 07000000 		.4byte	.LASF67
 2624 034d 01       		.byte	0x1
 2625 034e 0401     		.2byte	0x104
 2626 0350 05010000 		.4byte	0x105
 2627 0354 00000000 		.4byte	.LFB64
 2628 0358 A4000000 		.4byte	.LFE64-.LFB64
 2629 035c 01       		.uleb128 0x1
 2630 035d 9C       		.byte	0x9c
 2631 035e 90030000 		.4byte	0x390
 2632 0362 10       		.uleb128 0x10
 2633 0363 B5040000 		.4byte	.LASF65
 2634 0367 01       		.byte	0x1
 2635 0368 0401     		.2byte	0x104
 2636 036a 2E020000 		.4byte	0x22e
 2637 036e 02       		.uleb128 0x2
 2638 036f 91       		.byte	0x91
 2639 0370 6C       		.sleb128 -20
 2640 0371 10       		.uleb128 0x10
 2641 0372 84060000 		.4byte	.LASF66
 2642 0376 01       		.byte	0x1
 2643 0377 0401     		.2byte	0x104
 2644 0379 05010000 		.4byte	0x105
 2645 037d 02       		.uleb128 0x2
 2646 037e 91       		.byte	0x91
 2647 037f 68       		.sleb128 -24
 2648 0380 11       		.uleb128 0x11
 2649 0381 E6040000 		.4byte	.LASF71
 2650 0385 01       		.byte	0x1
 2651 0386 0601     		.2byte	0x106
 2652 0388 96030000 		.4byte	0x396
 2653 038c 02       		.uleb128 0x2
 2654 038d 91       		.byte	0x91
 2655 038e 74       		.sleb128 -12
 2656 038f 00       		.byte	0
 2657 0390 06       		.uleb128 0x6
 2658 0391 04       		.byte	0x4
 2659 0392 02030000 		.4byte	0x302
 2660 0396 07       		.uleb128 0x7
 2661 0397 90030000 		.4byte	0x390
 2662 039b 0F       		.uleb128 0xf
 2663 039c 74030000 		.4byte	.LASF68
 2664 03a0 01       		.byte	0x1
 2665 03a1 3901     		.2byte	0x139
 2666 03a3 2E020000 		.4byte	0x22e
 2667 03a7 00000000 		.4byte	.LFB65
 2668 03ab 76000000 		.4byte	.LFE65-.LFB65
 2669 03af 01       		.uleb128 0x1
 2670 03b0 9C       		.byte	0x9c
 2671 03b1 10040000 		.4byte	0x410
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 90


 2672 03b5 10       		.uleb128 0x10
 2673 03b6 CF040000 		.4byte	.LASF69
 2674 03ba 01       		.byte	0x1
 2675 03bb 3901     		.2byte	0x139
 2676 03bd 10040000 		.4byte	0x410
 2677 03c1 02       		.uleb128 0x2
 2678 03c2 91       		.byte	0x91
 2679 03c3 64       		.sleb128 -28
 2680 03c4 10       		.uleb128 0x10
 2681 03c5 40030000 		.4byte	.LASF55
 2682 03c9 01       		.byte	0x1
 2683 03ca 3901     		.2byte	0x139
 2684 03cc 10040000 		.4byte	0x410
 2685 03d0 02       		.uleb128 0x2
 2686 03d1 91       		.byte	0x91
 2687 03d2 60       		.sleb128 -32
 2688 03d3 10       		.uleb128 0x10
 2689 03d4 FA020000 		.4byte	.LASF70
 2690 03d8 01       		.byte	0x1
 2691 03d9 3901     		.2byte	0x139
 2692 03db 15040000 		.4byte	0x415
 2693 03df 02       		.uleb128 0x2
 2694 03e0 91       		.byte	0x91
 2695 03e1 5F       		.sleb128 -33
 2696 03e2 11       		.uleb128 0x11
 2697 03e3 88030000 		.4byte	.LASF72
 2698 03e7 01       		.byte	0x1
 2699 03e8 3B01     		.2byte	0x13b
 2700 03ea 90030000 		.4byte	0x390
 2701 03ee 02       		.uleb128 0x2
 2702 03ef 91       		.byte	0x91
 2703 03f0 6C       		.sleb128 -20
 2704 03f1 11       		.uleb128 0x11
 2705 03f2 7B040000 		.4byte	.LASF73
 2706 03f6 01       		.byte	0x1
 2707 03f7 3C01     		.2byte	0x13c
 2708 03f9 25000000 		.4byte	0x25
 2709 03fd 02       		.uleb128 0x2
 2710 03fe 91       		.byte	0x91
 2711 03ff 74       		.sleb128 -12
 2712 0400 11       		.uleb128 0x11
 2713 0401 73060000 		.4byte	.LASF74
 2714 0405 01       		.byte	0x1
 2715 0406 3D01     		.2byte	0x13d
 2716 0408 2E020000 		.4byte	0x22e
 2717 040c 02       		.uleb128 0x2
 2718 040d 91       		.byte	0x91
 2719 040e 70       		.sleb128 -16
 2720 040f 00       		.byte	0
 2721 0410 07       		.uleb128 0x7
 2722 0411 10010000 		.4byte	0x110
 2723 0415 07       		.uleb128 0x7
 2724 0416 D6000000 		.4byte	0xd6
 2725 041a 0F       		.uleb128 0xf
 2726 041b B6020000 		.4byte	.LASF75
 2727 041f 01       		.byte	0x1
 2728 0420 8701     		.2byte	0x187
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 91


 2729 0422 2E020000 		.4byte	0x22e
 2730 0426 00000000 		.4byte	.LFB66
 2731 042a 7C000000 		.4byte	.LFE66-.LFB66
 2732 042e 01       		.uleb128 0x1
 2733 042f 9C       		.byte	0x9c
 2734 0430 53040000 		.4byte	0x453
 2735 0434 10       		.uleb128 0x10
 2736 0435 FA020000 		.4byte	.LASF70
 2737 0439 01       		.byte	0x1
 2738 043a 8701     		.2byte	0x187
 2739 043c 15040000 		.4byte	0x415
 2740 0440 02       		.uleb128 0x2
 2741 0441 91       		.byte	0x91
 2742 0442 6F       		.sleb128 -17
 2743 0443 11       		.uleb128 0x11
 2744 0444 88030000 		.4byte	.LASF72
 2745 0448 01       		.byte	0x1
 2746 0449 8901     		.2byte	0x189
 2747 044b 90030000 		.4byte	0x390
 2748 044f 02       		.uleb128 0x2
 2749 0450 91       		.byte	0x91
 2750 0451 74       		.sleb128 -12
 2751 0452 00       		.byte	0
 2752 0453 0F       		.uleb128 0xf
 2753 0454 D1060000 		.4byte	.LASF76
 2754 0458 01       		.byte	0x1
 2755 0459 E501     		.2byte	0x1e5
 2756 045b 05010000 		.4byte	0x105
 2757 045f 00000000 		.4byte	.LFB67
 2758 0463 4C000000 		.4byte	.LFE67-.LFB67
 2759 0467 01       		.uleb128 0x1
 2760 0468 9C       		.byte	0x9c
 2761 0469 9B040000 		.4byte	0x49b
 2762 046d 10       		.uleb128 0x10
 2763 046e AF020000 		.4byte	.LASF77
 2764 0472 01       		.byte	0x1
 2765 0473 E501     		.2byte	0x1e5
 2766 0475 2E020000 		.4byte	0x22e
 2767 0479 02       		.uleb128 0x2
 2768 047a 91       		.byte	0x91
 2769 047b 64       		.sleb128 -28
 2770 047c 11       		.uleb128 0x11
 2771 047d 73060000 		.4byte	.LASF74
 2772 0481 01       		.byte	0x1
 2773 0482 E701     		.2byte	0x1e7
 2774 0484 05010000 		.4byte	0x105
 2775 0488 02       		.uleb128 0x2
 2776 0489 91       		.byte	0x91
 2777 048a 6C       		.sleb128 -20
 2778 048b 11       		.uleb128 0x11
 2779 048c 30020000 		.4byte	.LASF78
 2780 0490 01       		.byte	0x1
 2781 0491 E801     		.2byte	0x1e8
 2782 0493 96030000 		.4byte	0x396
 2783 0497 02       		.uleb128 0x2
 2784 0498 91       		.byte	0x91
 2785 0499 68       		.sleb128 -24
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 92


 2786 049a 00       		.byte	0
 2787 049b 0F       		.uleb128 0xf
 2788 049c 23070000 		.4byte	.LASF79
 2789 04a0 01       		.byte	0x1
 2790 04a1 1C02     		.2byte	0x21c
 2791 04a3 05010000 		.4byte	0x105
 2792 04a7 00000000 		.4byte	.LFB68
 2793 04ab 54000000 		.4byte	.LFE68-.LFB68
 2794 04af 01       		.uleb128 0x1
 2795 04b0 9C       		.byte	0x9c
 2796 04b1 F2040000 		.4byte	0x4f2
 2797 04b5 10       		.uleb128 0x10
 2798 04b6 AF020000 		.4byte	.LASF77
 2799 04ba 01       		.byte	0x1
 2800 04bb 1C02     		.2byte	0x21c
 2801 04bd 2E020000 		.4byte	0x22e
 2802 04c1 02       		.uleb128 0x2
 2803 04c2 91       		.byte	0x91
 2804 04c3 64       		.sleb128 -28
 2805 04c4 10       		.uleb128 0x10
 2806 04c5 4D070000 		.4byte	.LASF80
 2807 04c9 01       		.byte	0x1
 2808 04ca 1C02     		.2byte	0x21c
 2809 04cc 1B010000 		.4byte	0x11b
 2810 04d0 02       		.uleb128 0x2
 2811 04d1 91       		.byte	0x91
 2812 04d2 60       		.sleb128 -32
 2813 04d3 11       		.uleb128 0x11
 2814 04d4 73060000 		.4byte	.LASF74
 2815 04d8 01       		.byte	0x1
 2816 04d9 1E02     		.2byte	0x21e
 2817 04db 05010000 		.4byte	0x105
 2818 04df 02       		.uleb128 0x2
 2819 04e0 91       		.byte	0x91
 2820 04e1 6C       		.sleb128 -20
 2821 04e2 11       		.uleb128 0x11
 2822 04e3 30020000 		.4byte	.LASF78
 2823 04e7 01       		.byte	0x1
 2824 04e8 1F02     		.2byte	0x21f
 2825 04ea 96030000 		.4byte	0x396
 2826 04ee 02       		.uleb128 0x2
 2827 04ef 91       		.byte	0x91
 2828 04f0 68       		.sleb128 -24
 2829 04f1 00       		.byte	0
 2830 04f2 0F       		.uleb128 0xf
 2831 04f3 54050000 		.4byte	.LASF81
 2832 04f7 01       		.byte	0x1
 2833 04f8 4602     		.2byte	0x246
 2834 04fa 2E020000 		.4byte	0x22e
 2835 04fe 00000000 		.4byte	.LFB69
 2836 0502 2C000000 		.4byte	.LFE69-.LFB69
 2837 0506 01       		.uleb128 0x1
 2838 0507 9C       		.byte	0x9c
 2839 0508 3A050000 		.4byte	0x53a
 2840 050c 10       		.uleb128 0x10
 2841 050d CF030000 		.4byte	.LASF82
 2842 0511 01       		.byte	0x1
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 93


 2843 0512 4602     		.2byte	0x246
 2844 0514 10040000 		.4byte	0x410
 2845 0518 02       		.uleb128 0x2
 2846 0519 91       		.byte	0x91
 2847 051a 6C       		.sleb128 -20
 2848 051b 10       		.uleb128 0x10
 2849 051c FF050000 		.4byte	.LASF83
 2850 0520 01       		.byte	0x1
 2851 0521 4602     		.2byte	0x246
 2852 0523 10040000 		.4byte	0x410
 2853 0527 02       		.uleb128 0x2
 2854 0528 91       		.byte	0x91
 2855 0529 68       		.sleb128 -24
 2856 052a 11       		.uleb128 0x11
 2857 052b F7050000 		.4byte	.LASF62
 2858 052f 01       		.byte	0x1
 2859 0530 4802     		.2byte	0x248
 2860 0532 2E020000 		.4byte	0x22e
 2861 0536 02       		.uleb128 0x2
 2862 0537 91       		.byte	0x91
 2863 0538 74       		.sleb128 -12
 2864 0539 00       		.byte	0
 2865 053a 0F       		.uleb128 0xf
 2866 053b 38020000 		.4byte	.LASF84
 2867 053f 01       		.byte	0x1
 2868 0540 6102     		.2byte	0x261
 2869 0542 05010000 		.4byte	0x105
 2870 0546 00000000 		.4byte	.LFB70
 2871 054a 1E010000 		.4byte	.LFE70-.LFB70
 2872 054e 01       		.uleb128 0x1
 2873 054f 9C       		.byte	0x9c
 2874 0550 CD050000 		.4byte	0x5cd
 2875 0554 10       		.uleb128 0x10
 2876 0555 B5040000 		.4byte	.LASF65
 2877 0559 01       		.byte	0x1
 2878 055a 6102     		.2byte	0x261
 2879 055c 2E020000 		.4byte	0x22e
 2880 0560 02       		.uleb128 0x2
 2881 0561 91       		.byte	0x91
 2882 0562 5C       		.sleb128 -36
 2883 0563 10       		.uleb128 0x10
 2884 0564 43040000 		.4byte	.LASF85
 2885 0568 01       		.byte	0x1
 2886 0569 6102     		.2byte	0x261
 2887 056b CD050000 		.4byte	0x5cd
 2888 056f 02       		.uleb128 0x2
 2889 0570 91       		.byte	0x91
 2890 0571 58       		.sleb128 -40
 2891 0572 10       		.uleb128 0x10
 2892 0573 4D070000 		.4byte	.LASF80
 2893 0577 01       		.byte	0x1
 2894 0578 6102     		.2byte	0x261
 2895 057a 1B010000 		.4byte	0x11b
 2896 057e 02       		.uleb128 0x2
 2897 057f 91       		.byte	0x91
 2898 0580 54       		.sleb128 -44
 2899 0581 10       		.uleb128 0x10
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 94


 2900 0582 C9050000 		.4byte	.LASF86
 2901 0586 01       		.byte	0x1
 2902 0587 6102     		.2byte	0x261
 2903 0589 D2050000 		.4byte	0x5d2
 2904 058d 02       		.uleb128 0x2
 2905 058e 91       		.byte	0x91
 2906 058f 50       		.sleb128 -48
 2907 0590 11       		.uleb128 0x11
 2908 0591 87050000 		.4byte	.LASF87
 2909 0595 01       		.byte	0x1
 2910 0596 6302     		.2byte	0x263
 2911 0598 05010000 		.4byte	0x105
 2912 059c 02       		.uleb128 0x2
 2913 059d 91       		.byte	0x91
 2914 059e 74       		.sleb128 -12
 2915 059f 11       		.uleb128 0x11
 2916 05a0 21020000 		.4byte	.LASF88
 2917 05a4 01       		.byte	0x1
 2918 05a5 6302     		.2byte	0x263
 2919 05a7 05010000 		.4byte	0x105
 2920 05ab 02       		.uleb128 0x2
 2921 05ac 91       		.byte	0x91
 2922 05ad 6C       		.sleb128 -20
 2923 05ae 11       		.uleb128 0x11
 2924 05af CE010000 		.4byte	.LASF89
 2925 05b3 01       		.byte	0x1
 2926 05b4 6402     		.2byte	0x264
 2927 05b6 23020000 		.4byte	0x223
 2928 05ba 02       		.uleb128 0x2
 2929 05bb 91       		.byte	0x91
 2930 05bc 64       		.sleb128 -28
 2931 05bd 11       		.uleb128 0x11
 2932 05be E6040000 		.4byte	.LASF71
 2933 05c2 01       		.byte	0x1
 2934 05c3 6502     		.2byte	0x265
 2935 05c5 96030000 		.4byte	0x396
 2936 05c9 02       		.uleb128 0x2
 2937 05ca 91       		.byte	0x91
 2938 05cb 70       		.sleb128 -16
 2939 05cc 00       		.byte	0
 2940 05cd 07       		.uleb128 0x7
 2941 05ce C4000000 		.4byte	0xc4
 2942 05d2 07       		.uleb128 0x7
 2943 05d3 05010000 		.4byte	0x105
 2944 05d7 0F       		.uleb128 0xf
 2945 05d8 EE040000 		.4byte	.LASF90
 2946 05dc 01       		.byte	0x1
 2947 05dd 1E04     		.2byte	0x41e
 2948 05df 05010000 		.4byte	0x105
 2949 05e3 00000000 		.4byte	.LFB71
 2950 05e7 88000000 		.4byte	.LFE71-.LFB71
 2951 05eb 01       		.uleb128 0x1
 2952 05ec 9C       		.byte	0x9c
 2953 05ed 5B060000 		.4byte	0x65b
 2954 05f1 10       		.uleb128 0x10
 2955 05f2 B5040000 		.4byte	.LASF65
 2956 05f6 01       		.byte	0x1
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 95


 2957 05f7 1E04     		.2byte	0x41e
 2958 05f9 2E020000 		.4byte	0x22e
 2959 05fd 02       		.uleb128 0x2
 2960 05fe 91       		.byte	0x91
 2961 05ff 64       		.sleb128 -28
 2962 0600 10       		.uleb128 0x10
 2963 0601 43040000 		.4byte	.LASF85
 2964 0605 01       		.byte	0x1
 2965 0606 1E04     		.2byte	0x41e
 2966 0608 CD050000 		.4byte	0x5cd
 2967 060c 02       		.uleb128 0x2
 2968 060d 91       		.byte	0x91
 2969 060e 60       		.sleb128 -32
 2970 060f 10       		.uleb128 0x10
 2971 0610 8E060000 		.4byte	.LASF91
 2972 0614 01       		.byte	0x1
 2973 0615 1E04     		.2byte	0x41e
 2974 0617 61060000 		.4byte	0x661
 2975 061b 02       		.uleb128 0x2
 2976 061c 91       		.byte	0x91
 2977 061d 5C       		.sleb128 -36
 2978 061e 10       		.uleb128 0x10
 2979 061f C9050000 		.4byte	.LASF86
 2980 0623 01       		.byte	0x1
 2981 0624 1E04     		.2byte	0x41e
 2982 0626 D2050000 		.4byte	0x5d2
 2983 062a 02       		.uleb128 0x2
 2984 062b 91       		.byte	0x91
 2985 062c 58       		.sleb128 -40
 2986 062d 11       		.uleb128 0x11
 2987 062e 73060000 		.4byte	.LASF74
 2988 0632 01       		.byte	0x1
 2989 0633 2004     		.2byte	0x420
 2990 0635 05010000 		.4byte	0x105
 2991 0639 02       		.uleb128 0x2
 2992 063a 91       		.byte	0x91
 2993 063b 74       		.sleb128 -12
 2994 063c 11       		.uleb128 0x11
 2995 063d 47060000 		.4byte	.LASF92
 2996 0641 01       		.byte	0x1
 2997 0642 2104     		.2byte	0x421
 2998 0644 10010000 		.4byte	0x110
 2999 0648 02       		.uleb128 0x2
 3000 0649 91       		.byte	0x91
 3001 064a 6C       		.sleb128 -20
 3002 064b 11       		.uleb128 0x11
 3003 064c E6040000 		.4byte	.LASF71
 3004 0650 01       		.byte	0x1
 3005 0651 2204     		.2byte	0x422
 3006 0653 96030000 		.4byte	0x396
 3007 0657 02       		.uleb128 0x2
 3008 0658 91       		.byte	0x91
 3009 0659 70       		.sleb128 -16
 3010 065a 00       		.byte	0
 3011 065b 06       		.uleb128 0x6
 3012 065c 04       		.byte	0x4
 3013 065d 05010000 		.4byte	0x105
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 96


 3014 0661 07       		.uleb128 0x7
 3015 0662 5B060000 		.4byte	0x65b
 3016 0666 0F       		.uleb128 0xf
 3017 0667 16050000 		.4byte	.LASF93
 3018 066b 01       		.byte	0x1
 3019 066c B304     		.2byte	0x4b3
 3020 066e 05010000 		.4byte	0x105
 3021 0672 00000000 		.4byte	.LFB72
 3022 0676 7E000000 		.4byte	.LFE72-.LFB72
 3023 067a 01       		.uleb128 0x1
 3024 067b 9C       		.byte	0x9c
 3025 067c CC060000 		.4byte	0x6cc
 3026 0680 10       		.uleb128 0x10
 3027 0681 B5040000 		.4byte	.LASF65
 3028 0685 01       		.byte	0x1
 3029 0686 B304     		.2byte	0x4b3
 3030 0688 2E020000 		.4byte	0x22e
 3031 068c 02       		.uleb128 0x2
 3032 068d 91       		.byte	0x91
 3033 068e 64       		.sleb128 -28
 3034 068f 10       		.uleb128 0x10
 3035 0690 8E060000 		.4byte	.LASF91
 3036 0694 01       		.byte	0x1
 3037 0695 B304     		.2byte	0x4b3
 3038 0697 61060000 		.4byte	0x661
 3039 069b 02       		.uleb128 0x2
 3040 069c 91       		.byte	0x91
 3041 069d 60       		.sleb128 -32
 3042 069e 11       		.uleb128 0x11
 3043 069f 73060000 		.4byte	.LASF74
 3044 06a3 01       		.byte	0x1
 3045 06a4 B504     		.2byte	0x4b5
 3046 06a6 05010000 		.4byte	0x105
 3047 06aa 02       		.uleb128 0x2
 3048 06ab 91       		.byte	0x91
 3049 06ac 74       		.sleb128 -12
 3050 06ad 11       		.uleb128 0x11
 3051 06ae 47060000 		.4byte	.LASF92
 3052 06b2 01       		.byte	0x1
 3053 06b3 B604     		.2byte	0x4b6
 3054 06b5 10010000 		.4byte	0x110
 3055 06b9 02       		.uleb128 0x2
 3056 06ba 91       		.byte	0x91
 3057 06bb 6C       		.sleb128 -20
 3058 06bc 11       		.uleb128 0x11
 3059 06bd E6040000 		.4byte	.LASF71
 3060 06c1 01       		.byte	0x1
 3061 06c2 B704     		.2byte	0x4b7
 3062 06c4 96030000 		.4byte	0x396
 3063 06c8 02       		.uleb128 0x2
 3064 06c9 91       		.byte	0x91
 3065 06ca 70       		.sleb128 -16
 3066 06cb 00       		.byte	0
 3067 06cc 0F       		.uleb128 0xf
 3068 06cd 72050000 		.4byte	.LASF94
 3069 06d1 01       		.byte	0x1
 3070 06d2 5405     		.2byte	0x554
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 97


 3071 06d4 05010000 		.4byte	0x105
 3072 06d8 00000000 		.4byte	.LFB73
 3073 06dc 6C010000 		.4byte	.LFE73-.LFB73
 3074 06e0 01       		.uleb128 0x1
 3075 06e1 9C       		.byte	0x9c
 3076 06e2 5F070000 		.4byte	0x75f
 3077 06e6 10       		.uleb128 0x10
 3078 06e7 B5040000 		.4byte	.LASF65
 3079 06eb 01       		.byte	0x1
 3080 06ec 5405     		.2byte	0x554
 3081 06ee 2E020000 		.4byte	0x22e
 3082 06f2 02       		.uleb128 0x2
 3083 06f3 91       		.byte	0x91
 3084 06f4 5C       		.sleb128 -36
 3085 06f5 10       		.uleb128 0x10
 3086 06f6 8D040000 		.4byte	.LASF95
 3087 06fa 01       		.byte	0x1
 3088 06fb 5405     		.2byte	0x554
 3089 06fd 5F070000 		.4byte	0x75f
 3090 0701 02       		.uleb128 0x2
 3091 0702 91       		.byte	0x91
 3092 0703 58       		.sleb128 -40
 3093 0704 10       		.uleb128 0x10
 3094 0705 4D070000 		.4byte	.LASF80
 3095 0709 01       		.byte	0x1
 3096 070a 5405     		.2byte	0x554
 3097 070c 1B010000 		.4byte	0x11b
 3098 0710 02       		.uleb128 0x2
 3099 0711 91       		.byte	0x91
 3100 0712 54       		.sleb128 -44
 3101 0713 10       		.uleb128 0x10
 3102 0714 AA010000 		.4byte	.LASF96
 3103 0718 01       		.byte	0x1
 3104 0719 5405     		.2byte	0x554
 3105 071b D2050000 		.4byte	0x5d2
 3106 071f 02       		.uleb128 0x2
 3107 0720 91       		.byte	0x91
 3108 0721 50       		.sleb128 -48
 3109 0722 11       		.uleb128 0x11
 3110 0723 87050000 		.4byte	.LASF87
 3111 0727 01       		.byte	0x1
 3112 0728 5605     		.2byte	0x556
 3113 072a 05010000 		.4byte	0x105
 3114 072e 02       		.uleb128 0x2
 3115 072f 91       		.byte	0x91
 3116 0730 74       		.sleb128 -12
 3117 0731 11       		.uleb128 0x11
 3118 0732 CE010000 		.4byte	.LASF89
 3119 0736 01       		.byte	0x1
 3120 0737 5705     		.2byte	0x557
 3121 0739 23020000 		.4byte	0x223
 3122 073d 02       		.uleb128 0x2
 3123 073e 91       		.byte	0x91
 3124 073f 64       		.sleb128 -28
 3125 0740 11       		.uleb128 0x11
 3126 0741 F4010000 		.4byte	.LASF97
 3127 0745 01       		.byte	0x1
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 98


 3128 0746 5805     		.2byte	0x558
 3129 0748 58020000 		.4byte	0x258
 3130 074c 02       		.uleb128 0x2
 3131 074d 91       		.byte	0x91
 3132 074e 6C       		.sleb128 -20
 3133 074f 11       		.uleb128 0x11
 3134 0750 E6040000 		.4byte	.LASF71
 3135 0754 01       		.byte	0x1
 3136 0755 5905     		.2byte	0x559
 3137 0757 96030000 		.4byte	0x396
 3138 075b 02       		.uleb128 0x2
 3139 075c 91       		.byte	0x91
 3140 075d 70       		.sleb128 -16
 3141 075e 00       		.byte	0
 3142 075f 07       		.uleb128 0x7
 3143 0760 B0000000 		.4byte	0xb0
 3144 0764 0F       		.uleb128 0xf
 3145 0765 DF010000 		.4byte	.LASF98
 3146 0769 01       		.byte	0x1
 3147 076a 0F06     		.2byte	0x60f
 3148 076c 05010000 		.4byte	0x105
 3149 0770 00000000 		.4byte	.LFB74
 3150 0774 84000000 		.4byte	.LFE74-.LFB74
 3151 0778 01       		.uleb128 0x1
 3152 0779 9C       		.byte	0x9c
 3153 077a D9070000 		.4byte	0x7d9
 3154 077e 10       		.uleb128 0x10
 3155 077f B5040000 		.4byte	.LASF65
 3156 0783 01       		.byte	0x1
 3157 0784 0F06     		.2byte	0x60f
 3158 0786 2E020000 		.4byte	0x22e
 3159 078a 02       		.uleb128 0x2
 3160 078b 91       		.byte	0x91
 3161 078c 64       		.sleb128 -28
 3162 078d 10       		.uleb128 0x10
 3163 078e 8D040000 		.4byte	.LASF95
 3164 0792 01       		.byte	0x1
 3165 0793 0F06     		.2byte	0x60f
 3166 0795 5F070000 		.4byte	0x75f
 3167 0799 02       		.uleb128 0x2
 3168 079a 91       		.byte	0x91
 3169 079b 60       		.sleb128 -32
 3170 079c 10       		.uleb128 0x10
 3171 079d 8E060000 		.4byte	.LASF91
 3172 07a1 01       		.byte	0x1
 3173 07a2 0F06     		.2byte	0x60f
 3174 07a4 61060000 		.4byte	0x661
 3175 07a8 02       		.uleb128 0x2
 3176 07a9 91       		.byte	0x91
 3177 07aa 5C       		.sleb128 -36
 3178 07ab 11       		.uleb128 0x11
 3179 07ac 73060000 		.4byte	.LASF74
 3180 07b0 01       		.byte	0x1
 3181 07b1 1106     		.2byte	0x611
 3182 07b3 05010000 		.4byte	0x105
 3183 07b7 02       		.uleb128 0x2
 3184 07b8 91       		.byte	0x91
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 99


 3185 07b9 74       		.sleb128 -12
 3186 07ba 11       		.uleb128 0x11
 3187 07bb 47060000 		.4byte	.LASF92
 3188 07bf 01       		.byte	0x1
 3189 07c0 1206     		.2byte	0x612
 3190 07c2 10010000 		.4byte	0x110
 3191 07c6 02       		.uleb128 0x2
 3192 07c7 91       		.byte	0x91
 3193 07c8 6C       		.sleb128 -20
 3194 07c9 11       		.uleb128 0x11
 3195 07ca E6040000 		.4byte	.LASF71
 3196 07ce 01       		.byte	0x1
 3197 07cf 1306     		.2byte	0x613
 3198 07d1 96030000 		.4byte	0x396
 3199 07d5 02       		.uleb128 0x2
 3200 07d6 91       		.byte	0x91
 3201 07d7 70       		.sleb128 -16
 3202 07d8 00       		.byte	0
 3203 07d9 0F       		.uleb128 0xf
 3204 07da 4B030000 		.4byte	.LASF99
 3205 07de 01       		.byte	0x1
 3206 07df 6606     		.2byte	0x666
 3207 07e1 05010000 		.4byte	0x105
 3208 07e5 00000000 		.4byte	.LFB75
 3209 07e9 4A000000 		.4byte	.LFE75-.LFB75
 3210 07ed 01       		.uleb128 0x1
 3211 07ee 9C       		.byte	0x9c
 3212 07ef 4E080000 		.4byte	0x84e
 3213 07f3 10       		.uleb128 0x10
 3214 07f4 B5040000 		.4byte	.LASF65
 3215 07f8 01       		.byte	0x1
 3216 07f9 6606     		.2byte	0x666
 3217 07fb 2E020000 		.4byte	0x22e
 3218 07ff 02       		.uleb128 0x2
 3219 0800 91       		.byte	0x91
 3220 0801 64       		.sleb128 -28
 3221 0802 10       		.uleb128 0x10
 3222 0803 8D040000 		.4byte	.LASF95
 3223 0807 01       		.byte	0x1
 3224 0808 6606     		.2byte	0x666
 3225 080a 5F070000 		.4byte	0x75f
 3226 080e 02       		.uleb128 0x2
 3227 080f 91       		.byte	0x91
 3228 0810 60       		.sleb128 -32
 3229 0811 11       		.uleb128 0x11
 3230 0812 73060000 		.4byte	.LASF74
 3231 0816 01       		.byte	0x1
 3232 0817 6806     		.2byte	0x668
 3233 0819 05010000 		.4byte	0x105
 3234 081d 02       		.uleb128 0x2
 3235 081e 91       		.byte	0x91
 3236 081f 74       		.sleb128 -12
 3237 0820 11       		.uleb128 0x11
 3238 0821 47060000 		.4byte	.LASF92
 3239 0825 01       		.byte	0x1
 3240 0826 6906     		.2byte	0x669
 3241 0828 10010000 		.4byte	0x110
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 100


 3242 082c 02       		.uleb128 0x2
 3243 082d 91       		.byte	0x91
 3244 082e 6C       		.sleb128 -20
 3245 082f 11       		.uleb128 0x11
 3246 0830 F4010000 		.4byte	.LASF97
 3247 0834 01       		.byte	0x1
 3248 0835 6A06     		.2byte	0x66a
 3249 0837 58020000 		.4byte	0x258
 3250 083b 02       		.uleb128 0x2
 3251 083c 91       		.byte	0x91
 3252 083d 68       		.sleb128 -24
 3253 083e 11       		.uleb128 0x11
 3254 083f E6040000 		.4byte	.LASF71
 3255 0843 01       		.byte	0x1
 3256 0844 6B06     		.2byte	0x66b
 3257 0846 96030000 		.4byte	0x396
 3258 084a 02       		.uleb128 0x2
 3259 084b 91       		.byte	0x91
 3260 084c 70       		.sleb128 -16
 3261 084d 00       		.byte	0
 3262 084e 0F       		.uleb128 0xf
 3263 084f 81010000 		.4byte	.LASF100
 3264 0853 01       		.byte	0x1
 3265 0854 9C06     		.2byte	0x69c
 3266 0856 10010000 		.4byte	0x110
 3267 085a 00000000 		.4byte	.LFB76
 3268 085e 20000000 		.4byte	.LFE76-.LFB76
 3269 0862 01       		.uleb128 0x1
 3270 0863 9C       		.byte	0x9c
 3271 0864 87080000 		.4byte	0x887
 3272 0868 10       		.uleb128 0x10
 3273 0869 B5040000 		.4byte	.LASF65
 3274 086d 01       		.byte	0x1
 3275 086e 9C06     		.2byte	0x69c
 3276 0870 87080000 		.4byte	0x887
 3277 0874 02       		.uleb128 0x2
 3278 0875 91       		.byte	0x91
 3279 0876 6C       		.sleb128 -20
 3280 0877 11       		.uleb128 0x11
 3281 0878 A2050000 		.4byte	.LASF101
 3282 087c 01       		.byte	0x1
 3283 087d 9E06     		.2byte	0x69e
 3284 087f 10010000 		.4byte	0x110
 3285 0883 02       		.uleb128 0x2
 3286 0884 91       		.byte	0x91
 3287 0885 74       		.sleb128 -12
 3288 0886 00       		.byte	0
 3289 0887 07       		.uleb128 0x7
 3290 0888 2E020000 		.4byte	0x22e
 3291 088c 0F       		.uleb128 0xf
 3292 088d B7010000 		.4byte	.LASF102
 3293 0891 01       		.byte	0x1
 3294 0892 AC06     		.2byte	0x6ac
 3295 0894 10010000 		.4byte	0x110
 3296 0898 00000000 		.4byte	.LFB77
 3297 089c 2A000000 		.4byte	.LFE77-.LFB77
 3298 08a0 01       		.uleb128 0x1
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 101


 3299 08a1 9C       		.byte	0x9c
 3300 08a2 D4080000 		.4byte	0x8d4
 3301 08a6 10       		.uleb128 0x10
 3302 08a7 B5040000 		.4byte	.LASF65
 3303 08ab 01       		.byte	0x1
 3304 08ac AC06     		.2byte	0x6ac
 3305 08ae 87080000 		.4byte	0x887
 3306 08b2 02       		.uleb128 0x2
 3307 08b3 91       		.byte	0x91
 3308 08b4 6C       		.sleb128 -20
 3309 08b5 11       		.uleb128 0x11
 3310 08b6 A2050000 		.4byte	.LASF101
 3311 08ba 01       		.byte	0x1
 3312 08bb AE06     		.2byte	0x6ae
 3313 08bd 10010000 		.4byte	0x110
 3314 08c1 02       		.uleb128 0x2
 3315 08c2 91       		.byte	0x91
 3316 08c3 70       		.sleb128 -16
 3317 08c4 11       		.uleb128 0x11
 3318 08c5 E6040000 		.4byte	.LASF71
 3319 08c9 01       		.byte	0x1
 3320 08ca AF06     		.2byte	0x6af
 3321 08cc 90030000 		.4byte	0x390
 3322 08d0 02       		.uleb128 0x2
 3323 08d1 91       		.byte	0x91
 3324 08d2 74       		.sleb128 -12
 3325 08d3 00       		.byte	0
 3326 08d4 12       		.uleb128 0x12
 3327 08d5 1B030000 		.4byte	.LASF103
 3328 08d9 01       		.byte	0x1
 3329 08da BE06     		.2byte	0x6be
 3330 08dc 10010000 		.4byte	0x110
 3331 08e0 00000000 		.4byte	.LFB78
 3332 08e4 1A000000 		.4byte	.LFE78-.LFB78
 3333 08e8 01       		.uleb128 0x1
 3334 08e9 9C       		.byte	0x9c
 3335 08ea 0D090000 		.4byte	0x90d
 3336 08ee 10       		.uleb128 0x10
 3337 08ef B5040000 		.4byte	.LASF65
 3338 08f3 01       		.byte	0x1
 3339 08f4 BE06     		.2byte	0x6be
 3340 08f6 87080000 		.4byte	0x887
 3341 08fa 02       		.uleb128 0x2
 3342 08fb 91       		.byte	0x91
 3343 08fc 6C       		.sleb128 -20
 3344 08fd 11       		.uleb128 0x11
 3345 08fe A2050000 		.4byte	.LASF101
 3346 0902 01       		.byte	0x1
 3347 0903 C006     		.2byte	0x6c0
 3348 0905 10010000 		.4byte	0x110
 3349 0909 02       		.uleb128 0x2
 3350 090a 91       		.byte	0x91
 3351 090b 74       		.sleb128 -12
 3352 090c 00       		.byte	0
 3353 090d 13       		.uleb128 0x13
 3354 090e 95050000 		.4byte	.LASF112
 3355 0912 01       		.byte	0x1
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 102


 3356 0913 CA06     		.2byte	0x6ca
 3357 0915 00000000 		.4byte	.LFB79
 3358 0919 20000000 		.4byte	.LFE79-.LFB79
 3359 091d 01       		.uleb128 0x1
 3360 091e 9C       		.byte	0x9c
 3361 091f 42090000 		.4byte	0x942
 3362 0923 10       		.uleb128 0x10
 3363 0924 B5040000 		.4byte	.LASF65
 3364 0928 01       		.byte	0x1
 3365 0929 CA06     		.2byte	0x6ca
 3366 092b 2E020000 		.4byte	0x22e
 3367 092f 02       		.uleb128 0x2
 3368 0930 91       		.byte	0x91
 3369 0931 6C       		.sleb128 -20
 3370 0932 11       		.uleb128 0x11
 3371 0933 E6040000 		.4byte	.LASF71
 3372 0937 01       		.byte	0x1
 3373 0938 CC06     		.2byte	0x6cc
 3374 093a 96030000 		.4byte	0x396
 3375 093e 02       		.uleb128 0x2
 3376 093f 91       		.byte	0x91
 3377 0940 74       		.sleb128 -12
 3378 0941 00       		.byte	0
 3379 0942 14       		.uleb128 0x14
 3380 0943 5F000000 		.4byte	.LASF107
 3381 0947 01       		.byte	0x1
 3382 0948 F806     		.2byte	0x6f8
 3383 094a 05010000 		.4byte	0x105
 3384 094e 00000000 		.4byte	.LFB80
 3385 0952 D6000000 		.4byte	.LFE80-.LFB80
 3386 0956 01       		.uleb128 0x1
 3387 0957 9C       		.byte	0x9c
 3388 0958 99090000 		.4byte	0x999
 3389 095c 10       		.uleb128 0x10
 3390 095d E6040000 		.4byte	.LASF71
 3391 0961 01       		.byte	0x1
 3392 0962 F806     		.2byte	0x6f8
 3393 0964 96030000 		.4byte	0x396
 3394 0968 02       		.uleb128 0x2
 3395 0969 91       		.byte	0x91
 3396 096a 6C       		.sleb128 -20
 3397 096b 10       		.uleb128 0x10
 3398 096c 43040000 		.4byte	.LASF85
 3399 0970 01       		.byte	0x1
 3400 0971 F806     		.2byte	0x6f8
 3401 0973 C4000000 		.4byte	0xc4
 3402 0977 02       		.uleb128 0x2
 3403 0978 91       		.byte	0x91
 3404 0979 68       		.sleb128 -24
 3405 097a 10       		.uleb128 0x10
 3406 097b 6C010000 		.4byte	.LASF104
 3407 097f 01       		.byte	0x1
 3408 0980 F806     		.2byte	0x6f8
 3409 0982 D2050000 		.4byte	0x5d2
 3410 0986 02       		.uleb128 0x2
 3411 0987 91       		.byte	0x91
 3412 0988 64       		.sleb128 -28
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 103


 3413 0989 11       		.uleb128 0x11
 3414 098a 73060000 		.4byte	.LASF74
 3415 098e 01       		.byte	0x1
 3416 098f FA06     		.2byte	0x6fa
 3417 0991 05010000 		.4byte	0x105
 3418 0995 02       		.uleb128 0x2
 3419 0996 91       		.byte	0x91
 3420 0997 74       		.sleb128 -12
 3421 0998 00       		.byte	0
 3422 0999 15       		.uleb128 0x15
 3423 099a 4A020000 		.4byte	.LASF105
 3424 099e 01       		.byte	0x1
 3425 099f 4207     		.2byte	0x742
 3426 09a1 00000000 		.4byte	.LFB81
 3427 09a5 4C000000 		.4byte	.LFE81-.LFB81
 3428 09a9 01       		.uleb128 0x1
 3429 09aa 9C       		.byte	0x9c
 3430 09ab CE090000 		.4byte	0x9ce
 3431 09af 10       		.uleb128 0x10
 3432 09b0 E6040000 		.4byte	.LASF71
 3433 09b4 01       		.byte	0x1
 3434 09b5 4207     		.2byte	0x742
 3435 09b7 96030000 		.4byte	0x396
 3436 09bb 02       		.uleb128 0x2
 3437 09bc 91       		.byte	0x91
 3438 09bd 74       		.sleb128 -12
 3439 09be 10       		.uleb128 0x10
 3440 09bf 8D040000 		.4byte	.LASF95
 3441 09c3 01       		.byte	0x1
 3442 09c4 4207     		.2byte	0x742
 3443 09c6 5F070000 		.4byte	0x75f
 3444 09ca 02       		.uleb128 0x2
 3445 09cb 91       		.byte	0x91
 3446 09cc 70       		.sleb128 -16
 3447 09cd 00       		.byte	0
 3448 09ce 15       		.uleb128 0x15
 3449 09cf A6040000 		.4byte	.LASF106
 3450 09d3 01       		.byte	0x1
 3451 09d4 5407     		.2byte	0x754
 3452 09d6 00000000 		.4byte	.LFB82
 3453 09da 98000000 		.4byte	.LFE82-.LFB82
 3454 09de 01       		.uleb128 0x1
 3455 09df 9C       		.byte	0x9c
 3456 09e0 F4090000 		.4byte	0x9f4
 3457 09e4 10       		.uleb128 0x10
 3458 09e5 E6040000 		.4byte	.LASF71
 3459 09e9 01       		.byte	0x1
 3460 09ea 5407     		.2byte	0x754
 3461 09ec 96030000 		.4byte	0x396
 3462 09f0 02       		.uleb128 0x2
 3463 09f1 91       		.byte	0x91
 3464 09f2 74       		.sleb128 -12
 3465 09f3 00       		.byte	0
 3466 09f4 14       		.uleb128 0x14
 3467 09f5 E7050000 		.4byte	.LASF108
 3468 09f9 01       		.byte	0x1
 3469 09fa C707     		.2byte	0x7c7
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 104


 3470 09fc 05010000 		.4byte	0x105
 3471 0a00 00000000 		.4byte	.LFB83
 3472 0a04 2C000000 		.4byte	.LFE83-.LFB83
 3473 0a08 01       		.uleb128 0x1
 3474 0a09 9C       		.byte	0x9c
 3475 0a0a 2D0A0000 		.4byte	0xa2d
 3476 0a0e 10       		.uleb128 0x10
 3477 0a0f E6040000 		.4byte	.LASF71
 3478 0a13 01       		.byte	0x1
 3479 0a14 C707     		.2byte	0x7c7
 3480 0a16 2D0A0000 		.4byte	0xa2d
 3481 0a1a 02       		.uleb128 0x2
 3482 0a1b 91       		.byte	0x91
 3483 0a1c 6C       		.sleb128 -20
 3484 0a1d 11       		.uleb128 0x11
 3485 0a1e 73060000 		.4byte	.LASF74
 3486 0a22 01       		.byte	0x1
 3487 0a23 C907     		.2byte	0x7c9
 3488 0a25 05010000 		.4byte	0x105
 3489 0a29 02       		.uleb128 0x2
 3490 0a2a 91       		.byte	0x91
 3491 0a2b 74       		.sleb128 -12
 3492 0a2c 00       		.byte	0
 3493 0a2d 06       		.uleb128 0x6
 3494 0a2e 04       		.byte	0x4
 3495 0a2f 330A0000 		.4byte	0xa33
 3496 0a33 07       		.uleb128 0x7
 3497 0a34 02030000 		.4byte	0x302
 3498 0a38 12       		.uleb128 0x12
 3499 0a39 E0020000 		.4byte	.LASF109
 3500 0a3d 01       		.byte	0x1
 3501 0a3e DC07     		.2byte	0x7dc
 3502 0a40 05010000 		.4byte	0x105
 3503 0a44 00000000 		.4byte	.LFB84
 3504 0a48 26000000 		.4byte	.LFE84-.LFB84
 3505 0a4c 01       		.uleb128 0x1
 3506 0a4d 9C       		.byte	0x9c
 3507 0a4e 710A0000 		.4byte	0xa71
 3508 0a52 10       		.uleb128 0x10
 3509 0a53 B5040000 		.4byte	.LASF65
 3510 0a57 01       		.byte	0x1
 3511 0a58 DC07     		.2byte	0x7dc
 3512 0a5a 87080000 		.4byte	0x887
 3513 0a5e 02       		.uleb128 0x2
 3514 0a5f 91       		.byte	0x91
 3515 0a60 6C       		.sleb128 -20
 3516 0a61 11       		.uleb128 0x11
 3517 0a62 73060000 		.4byte	.LASF74
 3518 0a66 01       		.byte	0x1
 3519 0a67 DE07     		.2byte	0x7de
 3520 0a69 05010000 		.4byte	0x105
 3521 0a6d 02       		.uleb128 0x2
 3522 0a6e 91       		.byte	0x91
 3523 0a6f 74       		.sleb128 -12
 3524 0a70 00       		.byte	0
 3525 0a71 14       		.uleb128 0x14
 3526 0a72 0B020000 		.4byte	.LASF110
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 105


 3527 0a76 01       		.byte	0x1
 3528 0a77 EE07     		.2byte	0x7ee
 3529 0a79 05010000 		.4byte	0x105
 3530 0a7d 00000000 		.4byte	.LFB85
 3531 0a81 30000000 		.4byte	.LFE85-.LFB85
 3532 0a85 01       		.uleb128 0x1
 3533 0a86 9C       		.byte	0x9c
 3534 0a87 AA0A0000 		.4byte	0xaaa
 3535 0a8b 10       		.uleb128 0x10
 3536 0a8c E6040000 		.4byte	.LASF71
 3537 0a90 01       		.byte	0x1
 3538 0a91 EE07     		.2byte	0x7ee
 3539 0a93 2D0A0000 		.4byte	0xa2d
 3540 0a97 02       		.uleb128 0x2
 3541 0a98 91       		.byte	0x91
 3542 0a99 6C       		.sleb128 -20
 3543 0a9a 11       		.uleb128 0x11
 3544 0a9b 73060000 		.4byte	.LASF74
 3545 0a9f 01       		.byte	0x1
 3546 0aa0 F007     		.2byte	0x7f0
 3547 0aa2 05010000 		.4byte	0x105
 3548 0aa6 02       		.uleb128 0x2
 3549 0aa7 91       		.byte	0x91
 3550 0aa8 74       		.sleb128 -12
 3551 0aa9 00       		.byte	0
 3552 0aaa 12       		.uleb128 0x12
 3553 0aab 28050000 		.4byte	.LASF111
 3554 0aaf 01       		.byte	0x1
 3555 0ab0 0308     		.2byte	0x803
 3556 0ab2 05010000 		.4byte	0x105
 3557 0ab6 00000000 		.4byte	.LFB86
 3558 0aba 2A000000 		.4byte	.LFE86-.LFB86
 3559 0abe 01       		.uleb128 0x1
 3560 0abf 9C       		.byte	0x9c
 3561 0ac0 E30A0000 		.4byte	0xae3
 3562 0ac4 10       		.uleb128 0x10
 3563 0ac5 B5040000 		.4byte	.LASF65
 3564 0ac9 01       		.byte	0x1
 3565 0aca 0308     		.2byte	0x803
 3566 0acc 87080000 		.4byte	0x887
 3567 0ad0 02       		.uleb128 0x2
 3568 0ad1 91       		.byte	0x91
 3569 0ad2 6C       		.sleb128 -20
 3570 0ad3 11       		.uleb128 0x11
 3571 0ad4 73060000 		.4byte	.LASF74
 3572 0ad8 01       		.byte	0x1
 3573 0ad9 0508     		.2byte	0x805
 3574 0adb 05010000 		.4byte	0x105
 3575 0adf 02       		.uleb128 0x2
 3576 0ae0 91       		.byte	0x91
 3577 0ae1 74       		.sleb128 -12
 3578 0ae2 00       		.byte	0
 3579 0ae3 16       		.uleb128 0x16
 3580 0ae4 B6060000 		.4byte	.LASF113
 3581 0ae8 01       		.byte	0x1
 3582 0ae9 2A09     		.2byte	0x92a
 3583 0aeb 00000000 		.4byte	.LFB87
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 106


 3584 0aef 50000000 		.4byte	.LFE87-.LFB87
 3585 0af3 01       		.uleb128 0x1
 3586 0af4 9C       		.byte	0x9c
 3587 0af5 260B0000 		.4byte	0xb26
 3588 0af9 10       		.uleb128 0x10
 3589 0afa B5040000 		.4byte	.LASF65
 3590 0afe 01       		.byte	0x1
 3591 0aff 2A09     		.2byte	0x92a
 3592 0b01 2E020000 		.4byte	0x22e
 3593 0b05 02       		.uleb128 0x2
 3594 0b06 91       		.byte	0x91
 3595 0b07 6C       		.sleb128 -20
 3596 0b08 10       		.uleb128 0x10
 3597 0b09 53000000 		.4byte	.LASF61
 3598 0b0d 01       		.byte	0x1
 3599 0b0e 2A09     		.2byte	0x92a
 3600 0b10 B9000000 		.4byte	0xb9
 3601 0b14 02       		.uleb128 0x2
 3602 0b15 91       		.byte	0x91
 3603 0b16 68       		.sleb128 -24
 3604 0b17 17       		.uleb128 0x17
 3605 0b18 757800   		.ascii	"ux\000"
 3606 0b1b 01       		.byte	0x1
 3607 0b1c 2C09     		.2byte	0x92c
 3608 0b1e 10010000 		.4byte	0x110
 3609 0b22 02       		.uleb128 0x2
 3610 0b23 91       		.byte	0x91
 3611 0b24 74       		.sleb128 -12
 3612 0b25 00       		.byte	0
 3613 0b26 16       		.uleb128 0x16
 3614 0b27 0A040000 		.4byte	.LASF114
 3615 0b2b 01       		.byte	0x1
 3616 0b2c 4709     		.2byte	0x947
 3617 0b2e 00000000 		.4byte	.LFB88
 3618 0b32 44000000 		.4byte	.LFE88-.LFB88
 3619 0b36 01       		.uleb128 0x1
 3620 0b37 9C       		.byte	0x9c
 3621 0b38 5A0B0000 		.4byte	0xb5a
 3622 0b3c 10       		.uleb128 0x10
 3623 0b3d B5040000 		.4byte	.LASF65
 3624 0b41 01       		.byte	0x1
 3625 0b42 4709     		.2byte	0x947
 3626 0b44 2E020000 		.4byte	0x22e
 3627 0b48 02       		.uleb128 0x2
 3628 0b49 91       		.byte	0x91
 3629 0b4a 6C       		.sleb128 -20
 3630 0b4b 17       		.uleb128 0x17
 3631 0b4c 757800   		.ascii	"ux\000"
 3632 0b4f 01       		.byte	0x1
 3633 0b50 4909     		.2byte	0x949
 3634 0b52 10010000 		.4byte	0x110
 3635 0b56 02       		.uleb128 0x2
 3636 0b57 91       		.byte	0x91
 3637 0b58 74       		.sleb128 -12
 3638 0b59 00       		.byte	0
 3639 0b5a 18       		.uleb128 0x18
 3640 0b5b 06070000 		.4byte	.LASF115
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 107


 3641 0b5f 09       		.byte	0x9
 3642 0b60 1207     		.2byte	0x712
 3643 0b62 660B0000 		.4byte	0xb66
 3644 0b66 0E       		.uleb128 0xe
 3645 0b67 E1000000 		.4byte	0xe1
 3646 0b6b 19       		.uleb128 0x19
 3647 0b6c 3D030000 		.4byte	0x33d
 3648 0b70 7B0B0000 		.4byte	0xb7b
 3649 0b74 1A       		.uleb128 0x1a
 3650 0b75 A9000000 		.4byte	0xa9
 3651 0b79 09       		.byte	0x9
 3652 0b7a 00       		.byte	0
 3653 0b7b 1B       		.uleb128 0x1b
 3654 0b7c 93030000 		.4byte	.LASF116
 3655 0b80 01       		.byte	0x1
 3656 0b81 C0       		.byte	0xc0
 3657 0b82 6B0B0000 		.4byte	0xb6b
 3658 0b86 05       		.uleb128 0x5
 3659 0b87 03       		.byte	0x3
 3660 0b88 00000000 		.4byte	xQueueRegistry
 3661 0b8c 00       		.byte	0
 3662              		.section	.debug_abbrev,"",%progbits
 3663              	.Ldebug_abbrev0:
 3664 0000 01       		.uleb128 0x1
 3665 0001 11       		.uleb128 0x11
 3666 0002 01       		.byte	0x1
 3667 0003 25       		.uleb128 0x25
 3668 0004 0E       		.uleb128 0xe
 3669 0005 13       		.uleb128 0x13
 3670 0006 0B       		.uleb128 0xb
 3671 0007 03       		.uleb128 0x3
 3672 0008 0E       		.uleb128 0xe
 3673 0009 1B       		.uleb128 0x1b
 3674 000a 0E       		.uleb128 0xe
 3675 000b 55       		.uleb128 0x55
 3676 000c 17       		.uleb128 0x17
 3677 000d 11       		.uleb128 0x11
 3678 000e 01       		.uleb128 0x1
 3679 000f 10       		.uleb128 0x10
 3680 0010 17       		.uleb128 0x17
 3681 0011 00       		.byte	0
 3682 0012 00       		.byte	0
 3683 0013 02       		.uleb128 0x2
 3684 0014 16       		.uleb128 0x16
 3685 0015 00       		.byte	0
 3686 0016 03       		.uleb128 0x3
 3687 0017 0E       		.uleb128 0xe
 3688 0018 3A       		.uleb128 0x3a
 3689 0019 0B       		.uleb128 0xb
 3690 001a 3B       		.uleb128 0x3b
 3691 001b 0B       		.uleb128 0xb
 3692 001c 49       		.uleb128 0x49
 3693 001d 13       		.uleb128 0x13
 3694 001e 00       		.byte	0
 3695 001f 00       		.byte	0
 3696 0020 03       		.uleb128 0x3
 3697 0021 24       		.uleb128 0x24
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 108


 3698 0022 00       		.byte	0
 3699 0023 0B       		.uleb128 0xb
 3700 0024 0B       		.uleb128 0xb
 3701 0025 3E       		.uleb128 0x3e
 3702 0026 0B       		.uleb128 0xb
 3703 0027 03       		.uleb128 0x3
 3704 0028 0E       		.uleb128 0xe
 3705 0029 00       		.byte	0
 3706 002a 00       		.byte	0
 3707 002b 04       		.uleb128 0x4
 3708 002c 24       		.uleb128 0x24
 3709 002d 00       		.byte	0
 3710 002e 0B       		.uleb128 0xb
 3711 002f 0B       		.uleb128 0xb
 3712 0030 3E       		.uleb128 0x3e
 3713 0031 0B       		.uleb128 0xb
 3714 0032 03       		.uleb128 0x3
 3715 0033 08       		.uleb128 0x8
 3716 0034 00       		.byte	0
 3717 0035 00       		.byte	0
 3718 0036 05       		.uleb128 0x5
 3719 0037 0F       		.uleb128 0xf
 3720 0038 00       		.byte	0
 3721 0039 0B       		.uleb128 0xb
 3722 003a 0B       		.uleb128 0xb
 3723 003b 00       		.byte	0
 3724 003c 00       		.byte	0
 3725 003d 06       		.uleb128 0x6
 3726 003e 0F       		.uleb128 0xf
 3727 003f 00       		.byte	0
 3728 0040 0B       		.uleb128 0xb
 3729 0041 0B       		.uleb128 0xb
 3730 0042 49       		.uleb128 0x49
 3731 0043 13       		.uleb128 0x13
 3732 0044 00       		.byte	0
 3733 0045 00       		.byte	0
 3734 0046 07       		.uleb128 0x7
 3735 0047 26       		.uleb128 0x26
 3736 0048 00       		.byte	0
 3737 0049 49       		.uleb128 0x49
 3738 004a 13       		.uleb128 0x13
 3739 004b 00       		.byte	0
 3740 004c 00       		.byte	0
 3741 004d 08       		.uleb128 0x8
 3742 004e 26       		.uleb128 0x26
 3743 004f 00       		.byte	0
 3744 0050 00       		.byte	0
 3745 0051 00       		.byte	0
 3746 0052 09       		.uleb128 0x9
 3747 0053 13       		.uleb128 0x13
 3748 0054 01       		.byte	0x1
 3749 0055 03       		.uleb128 0x3
 3750 0056 0E       		.uleb128 0xe
 3751 0057 0B       		.uleb128 0xb
 3752 0058 0B       		.uleb128 0xb
 3753 0059 3A       		.uleb128 0x3a
 3754 005a 0B       		.uleb128 0xb
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 109


 3755 005b 3B       		.uleb128 0x3b
 3756 005c 0B       		.uleb128 0xb
 3757 005d 01       		.uleb128 0x1
 3758 005e 13       		.uleb128 0x13
 3759 005f 00       		.byte	0
 3760 0060 00       		.byte	0
 3761 0061 0A       		.uleb128 0xa
 3762 0062 0D       		.uleb128 0xd
 3763 0063 00       		.byte	0
 3764 0064 03       		.uleb128 0x3
 3765 0065 0E       		.uleb128 0xe
 3766 0066 3A       		.uleb128 0x3a
 3767 0067 0B       		.uleb128 0xb
 3768 0068 3B       		.uleb128 0x3b
 3769 0069 0B       		.uleb128 0xb
 3770 006a 49       		.uleb128 0x49
 3771 006b 13       		.uleb128 0x13
 3772 006c 38       		.uleb128 0x38
 3773 006d 0B       		.uleb128 0xb
 3774 006e 00       		.byte	0
 3775 006f 00       		.byte	0
 3776 0070 0B       		.uleb128 0xb
 3777 0071 17       		.uleb128 0x17
 3778 0072 01       		.byte	0x1
 3779 0073 0B       		.uleb128 0xb
 3780 0074 0B       		.uleb128 0xb
 3781 0075 3A       		.uleb128 0x3a
 3782 0076 0B       		.uleb128 0xb
 3783 0077 3B       		.uleb128 0x3b
 3784 0078 0B       		.uleb128 0xb
 3785 0079 01       		.uleb128 0x1
 3786 007a 13       		.uleb128 0x13
 3787 007b 00       		.byte	0
 3788 007c 00       		.byte	0
 3789 007d 0C       		.uleb128 0xc
 3790 007e 0D       		.uleb128 0xd
 3791 007f 00       		.byte	0
 3792 0080 03       		.uleb128 0x3
 3793 0081 0E       		.uleb128 0xe
 3794 0082 3A       		.uleb128 0x3a
 3795 0083 0B       		.uleb128 0xb
 3796 0084 3B       		.uleb128 0x3b
 3797 0085 0B       		.uleb128 0xb
 3798 0086 49       		.uleb128 0x49
 3799 0087 13       		.uleb128 0x13
 3800 0088 00       		.byte	0
 3801 0089 00       		.byte	0
 3802 008a 0D       		.uleb128 0xd
 3803 008b 0D       		.uleb128 0xd
 3804 008c 00       		.byte	0
 3805 008d 03       		.uleb128 0x3
 3806 008e 08       		.uleb128 0x8
 3807 008f 3A       		.uleb128 0x3a
 3808 0090 0B       		.uleb128 0xb
 3809 0091 3B       		.uleb128 0x3b
 3810 0092 0B       		.uleb128 0xb
 3811 0093 49       		.uleb128 0x49
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 110


 3812 0094 13       		.uleb128 0x13
 3813 0095 38       		.uleb128 0x38
 3814 0096 0B       		.uleb128 0xb
 3815 0097 00       		.byte	0
 3816 0098 00       		.byte	0
 3817 0099 0E       		.uleb128 0xe
 3818 009a 35       		.uleb128 0x35
 3819 009b 00       		.byte	0
 3820 009c 49       		.uleb128 0x49
 3821 009d 13       		.uleb128 0x13
 3822 009e 00       		.byte	0
 3823 009f 00       		.byte	0
 3824 00a0 0F       		.uleb128 0xf
 3825 00a1 2E       		.uleb128 0x2e
 3826 00a2 01       		.byte	0x1
 3827 00a3 3F       		.uleb128 0x3f
 3828 00a4 19       		.uleb128 0x19
 3829 00a5 03       		.uleb128 0x3
 3830 00a6 0E       		.uleb128 0xe
 3831 00a7 3A       		.uleb128 0x3a
 3832 00a8 0B       		.uleb128 0xb
 3833 00a9 3B       		.uleb128 0x3b
 3834 00aa 05       		.uleb128 0x5
 3835 00ab 27       		.uleb128 0x27
 3836 00ac 19       		.uleb128 0x19
 3837 00ad 49       		.uleb128 0x49
 3838 00ae 13       		.uleb128 0x13
 3839 00af 11       		.uleb128 0x11
 3840 00b0 01       		.uleb128 0x1
 3841 00b1 12       		.uleb128 0x12
 3842 00b2 06       		.uleb128 0x6
 3843 00b3 40       		.uleb128 0x40
 3844 00b4 18       		.uleb128 0x18
 3845 00b5 9642     		.uleb128 0x2116
 3846 00b7 19       		.uleb128 0x19
 3847 00b8 01       		.uleb128 0x1
 3848 00b9 13       		.uleb128 0x13
 3849 00ba 00       		.byte	0
 3850 00bb 00       		.byte	0
 3851 00bc 10       		.uleb128 0x10
 3852 00bd 05       		.uleb128 0x5
 3853 00be 00       		.byte	0
 3854 00bf 03       		.uleb128 0x3
 3855 00c0 0E       		.uleb128 0xe
 3856 00c1 3A       		.uleb128 0x3a
 3857 00c2 0B       		.uleb128 0xb
 3858 00c3 3B       		.uleb128 0x3b
 3859 00c4 05       		.uleb128 0x5
 3860 00c5 49       		.uleb128 0x49
 3861 00c6 13       		.uleb128 0x13
 3862 00c7 02       		.uleb128 0x2
 3863 00c8 18       		.uleb128 0x18
 3864 00c9 00       		.byte	0
 3865 00ca 00       		.byte	0
 3866 00cb 11       		.uleb128 0x11
 3867 00cc 34       		.uleb128 0x34
 3868 00cd 00       		.byte	0
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 111


 3869 00ce 03       		.uleb128 0x3
 3870 00cf 0E       		.uleb128 0xe
 3871 00d0 3A       		.uleb128 0x3a
 3872 00d1 0B       		.uleb128 0xb
 3873 00d2 3B       		.uleb128 0x3b
 3874 00d3 05       		.uleb128 0x5
 3875 00d4 49       		.uleb128 0x49
 3876 00d5 13       		.uleb128 0x13
 3877 00d6 02       		.uleb128 0x2
 3878 00d7 18       		.uleb128 0x18
 3879 00d8 00       		.byte	0
 3880 00d9 00       		.byte	0
 3881 00da 12       		.uleb128 0x12
 3882 00db 2E       		.uleb128 0x2e
 3883 00dc 01       		.byte	0x1
 3884 00dd 3F       		.uleb128 0x3f
 3885 00de 19       		.uleb128 0x19
 3886 00df 03       		.uleb128 0x3
 3887 00e0 0E       		.uleb128 0xe
 3888 00e1 3A       		.uleb128 0x3a
 3889 00e2 0B       		.uleb128 0xb
 3890 00e3 3B       		.uleb128 0x3b
 3891 00e4 05       		.uleb128 0x5
 3892 00e5 27       		.uleb128 0x27
 3893 00e6 19       		.uleb128 0x19
 3894 00e7 49       		.uleb128 0x49
 3895 00e8 13       		.uleb128 0x13
 3896 00e9 11       		.uleb128 0x11
 3897 00ea 01       		.uleb128 0x1
 3898 00eb 12       		.uleb128 0x12
 3899 00ec 06       		.uleb128 0x6
 3900 00ed 40       		.uleb128 0x40
 3901 00ee 18       		.uleb128 0x18
 3902 00ef 9742     		.uleb128 0x2117
 3903 00f1 19       		.uleb128 0x19
 3904 00f2 01       		.uleb128 0x1
 3905 00f3 13       		.uleb128 0x13
 3906 00f4 00       		.byte	0
 3907 00f5 00       		.byte	0
 3908 00f6 13       		.uleb128 0x13
 3909 00f7 2E       		.uleb128 0x2e
 3910 00f8 01       		.byte	0x1
 3911 00f9 3F       		.uleb128 0x3f
 3912 00fa 19       		.uleb128 0x19
 3913 00fb 03       		.uleb128 0x3
 3914 00fc 0E       		.uleb128 0xe
 3915 00fd 3A       		.uleb128 0x3a
 3916 00fe 0B       		.uleb128 0xb
 3917 00ff 3B       		.uleb128 0x3b
 3918 0100 05       		.uleb128 0x5
 3919 0101 27       		.uleb128 0x27
 3920 0102 19       		.uleb128 0x19
 3921 0103 11       		.uleb128 0x11
 3922 0104 01       		.uleb128 0x1
 3923 0105 12       		.uleb128 0x12
 3924 0106 06       		.uleb128 0x6
 3925 0107 40       		.uleb128 0x40
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 112


 3926 0108 18       		.uleb128 0x18
 3927 0109 9642     		.uleb128 0x2116
 3928 010b 19       		.uleb128 0x19
 3929 010c 01       		.uleb128 0x1
 3930 010d 13       		.uleb128 0x13
 3931 010e 00       		.byte	0
 3932 010f 00       		.byte	0
 3933 0110 14       		.uleb128 0x14
 3934 0111 2E       		.uleb128 0x2e
 3935 0112 01       		.byte	0x1
 3936 0113 03       		.uleb128 0x3
 3937 0114 0E       		.uleb128 0xe
 3938 0115 3A       		.uleb128 0x3a
 3939 0116 0B       		.uleb128 0xb
 3940 0117 3B       		.uleb128 0x3b
 3941 0118 05       		.uleb128 0x5
 3942 0119 27       		.uleb128 0x27
 3943 011a 19       		.uleb128 0x19
 3944 011b 49       		.uleb128 0x49
 3945 011c 13       		.uleb128 0x13
 3946 011d 11       		.uleb128 0x11
 3947 011e 01       		.uleb128 0x1
 3948 011f 12       		.uleb128 0x12
 3949 0120 06       		.uleb128 0x6
 3950 0121 40       		.uleb128 0x40
 3951 0122 18       		.uleb128 0x18
 3952 0123 9642     		.uleb128 0x2116
 3953 0125 19       		.uleb128 0x19
 3954 0126 01       		.uleb128 0x1
 3955 0127 13       		.uleb128 0x13
 3956 0128 00       		.byte	0
 3957 0129 00       		.byte	0
 3958 012a 15       		.uleb128 0x15
 3959 012b 2E       		.uleb128 0x2e
 3960 012c 01       		.byte	0x1
 3961 012d 03       		.uleb128 0x3
 3962 012e 0E       		.uleb128 0xe
 3963 012f 3A       		.uleb128 0x3a
 3964 0130 0B       		.uleb128 0xb
 3965 0131 3B       		.uleb128 0x3b
 3966 0132 05       		.uleb128 0x5
 3967 0133 27       		.uleb128 0x27
 3968 0134 19       		.uleb128 0x19
 3969 0135 11       		.uleb128 0x11
 3970 0136 01       		.uleb128 0x1
 3971 0137 12       		.uleb128 0x12
 3972 0138 06       		.uleb128 0x6
 3973 0139 40       		.uleb128 0x40
 3974 013a 18       		.uleb128 0x18
 3975 013b 9642     		.uleb128 0x2116
 3976 013d 19       		.uleb128 0x19
 3977 013e 01       		.uleb128 0x1
 3978 013f 13       		.uleb128 0x13
 3979 0140 00       		.byte	0
 3980 0141 00       		.byte	0
 3981 0142 16       		.uleb128 0x16
 3982 0143 2E       		.uleb128 0x2e
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 113


 3983 0144 01       		.byte	0x1
 3984 0145 3F       		.uleb128 0x3f
 3985 0146 19       		.uleb128 0x19
 3986 0147 03       		.uleb128 0x3
 3987 0148 0E       		.uleb128 0xe
 3988 0149 3A       		.uleb128 0x3a
 3989 014a 0B       		.uleb128 0xb
 3990 014b 3B       		.uleb128 0x3b
 3991 014c 05       		.uleb128 0x5
 3992 014d 27       		.uleb128 0x27
 3993 014e 19       		.uleb128 0x19
 3994 014f 11       		.uleb128 0x11
 3995 0150 01       		.uleb128 0x1
 3996 0151 12       		.uleb128 0x12
 3997 0152 06       		.uleb128 0x6
 3998 0153 40       		.uleb128 0x40
 3999 0154 18       		.uleb128 0x18
 4000 0155 9742     		.uleb128 0x2117
 4001 0157 19       		.uleb128 0x19
 4002 0158 01       		.uleb128 0x1
 4003 0159 13       		.uleb128 0x13
 4004 015a 00       		.byte	0
 4005 015b 00       		.byte	0
 4006 015c 17       		.uleb128 0x17
 4007 015d 34       		.uleb128 0x34
 4008 015e 00       		.byte	0
 4009 015f 03       		.uleb128 0x3
 4010 0160 08       		.uleb128 0x8
 4011 0161 3A       		.uleb128 0x3a
 4012 0162 0B       		.uleb128 0xb
 4013 0163 3B       		.uleb128 0x3b
 4014 0164 05       		.uleb128 0x5
 4015 0165 49       		.uleb128 0x49
 4016 0166 13       		.uleb128 0x13
 4017 0167 02       		.uleb128 0x2
 4018 0168 18       		.uleb128 0x18
 4019 0169 00       		.byte	0
 4020 016a 00       		.byte	0
 4021 016b 18       		.uleb128 0x18
 4022 016c 34       		.uleb128 0x34
 4023 016d 00       		.byte	0
 4024 016e 03       		.uleb128 0x3
 4025 016f 0E       		.uleb128 0xe
 4026 0170 3A       		.uleb128 0x3a
 4027 0171 0B       		.uleb128 0xb
 4028 0172 3B       		.uleb128 0x3b
 4029 0173 05       		.uleb128 0x5
 4030 0174 49       		.uleb128 0x49
 4031 0175 13       		.uleb128 0x13
 4032 0176 3F       		.uleb128 0x3f
 4033 0177 19       		.uleb128 0x19
 4034 0178 3C       		.uleb128 0x3c
 4035 0179 19       		.uleb128 0x19
 4036 017a 00       		.byte	0
 4037 017b 00       		.byte	0
 4038 017c 19       		.uleb128 0x19
 4039 017d 01       		.uleb128 0x1
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 114


 4040 017e 01       		.byte	0x1
 4041 017f 49       		.uleb128 0x49
 4042 0180 13       		.uleb128 0x13
 4043 0181 01       		.uleb128 0x1
 4044 0182 13       		.uleb128 0x13
 4045 0183 00       		.byte	0
 4046 0184 00       		.byte	0
 4047 0185 1A       		.uleb128 0x1a
 4048 0186 21       		.uleb128 0x21
 4049 0187 00       		.byte	0
 4050 0188 49       		.uleb128 0x49
 4051 0189 13       		.uleb128 0x13
 4052 018a 2F       		.uleb128 0x2f
 4053 018b 0B       		.uleb128 0xb
 4054 018c 00       		.byte	0
 4055 018d 00       		.byte	0
 4056 018e 1B       		.uleb128 0x1b
 4057 018f 34       		.uleb128 0x34
 4058 0190 00       		.byte	0
 4059 0191 03       		.uleb128 0x3
 4060 0192 0E       		.uleb128 0xe
 4061 0193 3A       		.uleb128 0x3a
 4062 0194 0B       		.uleb128 0xb
 4063 0195 3B       		.uleb128 0x3b
 4064 0196 0B       		.uleb128 0xb
 4065 0197 49       		.uleb128 0x49
 4066 0198 13       		.uleb128 0x13
 4067 0199 3F       		.uleb128 0x3f
 4068 019a 19       		.uleb128 0x19
 4069 019b 02       		.uleb128 0x2
 4070 019c 18       		.uleb128 0x18
 4071 019d 00       		.byte	0
 4072 019e 00       		.byte	0
 4073 019f 00       		.byte	0
 4074              		.section	.debug_aranges,"",%progbits
 4075 0000 DC000000 		.4byte	0xdc
 4076 0004 0200     		.2byte	0x2
 4077 0006 00000000 		.4byte	.Ldebug_info0
 4078 000a 04       		.byte	0x4
 4079 000b 00       		.byte	0
 4080 000c 0000     		.2byte	0
 4081 000e 0000     		.2byte	0
 4082 0010 00000000 		.4byte	.LFB64
 4083 0014 A4000000 		.4byte	.LFE64-.LFB64
 4084 0018 00000000 		.4byte	.LFB65
 4085 001c 76000000 		.4byte	.LFE65-.LFB65
 4086 0020 00000000 		.4byte	.LFB66
 4087 0024 7C000000 		.4byte	.LFE66-.LFB66
 4088 0028 00000000 		.4byte	.LFB67
 4089 002c 4C000000 		.4byte	.LFE67-.LFB67
 4090 0030 00000000 		.4byte	.LFB68
 4091 0034 54000000 		.4byte	.LFE68-.LFB68
 4092 0038 00000000 		.4byte	.LFB69
 4093 003c 2C000000 		.4byte	.LFE69-.LFB69
 4094 0040 00000000 		.4byte	.LFB70
 4095 0044 1E010000 		.4byte	.LFE70-.LFB70
 4096 0048 00000000 		.4byte	.LFB71
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 115


 4097 004c 88000000 		.4byte	.LFE71-.LFB71
 4098 0050 00000000 		.4byte	.LFB72
 4099 0054 7E000000 		.4byte	.LFE72-.LFB72
 4100 0058 00000000 		.4byte	.LFB73
 4101 005c 6C010000 		.4byte	.LFE73-.LFB73
 4102 0060 00000000 		.4byte	.LFB74
 4103 0064 84000000 		.4byte	.LFE74-.LFB74
 4104 0068 00000000 		.4byte	.LFB75
 4105 006c 4A000000 		.4byte	.LFE75-.LFB75
 4106 0070 00000000 		.4byte	.LFB76
 4107 0074 20000000 		.4byte	.LFE76-.LFB76
 4108 0078 00000000 		.4byte	.LFB77
 4109 007c 2A000000 		.4byte	.LFE77-.LFB77
 4110 0080 00000000 		.4byte	.LFB78
 4111 0084 1A000000 		.4byte	.LFE78-.LFB78
 4112 0088 00000000 		.4byte	.LFB79
 4113 008c 20000000 		.4byte	.LFE79-.LFB79
 4114 0090 00000000 		.4byte	.LFB80
 4115 0094 D6000000 		.4byte	.LFE80-.LFB80
 4116 0098 00000000 		.4byte	.LFB81
 4117 009c 4C000000 		.4byte	.LFE81-.LFB81
 4118 00a0 00000000 		.4byte	.LFB82
 4119 00a4 98000000 		.4byte	.LFE82-.LFB82
 4120 00a8 00000000 		.4byte	.LFB83
 4121 00ac 2C000000 		.4byte	.LFE83-.LFB83
 4122 00b0 00000000 		.4byte	.LFB84
 4123 00b4 26000000 		.4byte	.LFE84-.LFB84
 4124 00b8 00000000 		.4byte	.LFB85
 4125 00bc 30000000 		.4byte	.LFE85-.LFB85
 4126 00c0 00000000 		.4byte	.LFB86
 4127 00c4 2A000000 		.4byte	.LFE86-.LFB86
 4128 00c8 00000000 		.4byte	.LFB87
 4129 00cc 50000000 		.4byte	.LFE87-.LFB87
 4130 00d0 00000000 		.4byte	.LFB88
 4131 00d4 44000000 		.4byte	.LFE88-.LFB88
 4132 00d8 00000000 		.4byte	0
 4133 00dc 00000000 		.4byte	0
 4134              		.section	.debug_ranges,"",%progbits
 4135              	.Ldebug_ranges0:
 4136 0000 00000000 		.4byte	.LFB64
 4137 0004 A4000000 		.4byte	.LFE64
 4138 0008 00000000 		.4byte	.LFB65
 4139 000c 76000000 		.4byte	.LFE65
 4140 0010 00000000 		.4byte	.LFB66
 4141 0014 7C000000 		.4byte	.LFE66
 4142 0018 00000000 		.4byte	.LFB67
 4143 001c 4C000000 		.4byte	.LFE67
 4144 0020 00000000 		.4byte	.LFB68
 4145 0024 54000000 		.4byte	.LFE68
 4146 0028 00000000 		.4byte	.LFB69
 4147 002c 2C000000 		.4byte	.LFE69
 4148 0030 00000000 		.4byte	.LFB70
 4149 0034 1E010000 		.4byte	.LFE70
 4150 0038 00000000 		.4byte	.LFB71
 4151 003c 88000000 		.4byte	.LFE71
 4152 0040 00000000 		.4byte	.LFB72
 4153 0044 7E000000 		.4byte	.LFE72
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 116


 4154 0048 00000000 		.4byte	.LFB73
 4155 004c 6C010000 		.4byte	.LFE73
 4156 0050 00000000 		.4byte	.LFB74
 4157 0054 84000000 		.4byte	.LFE74
 4158 0058 00000000 		.4byte	.LFB75
 4159 005c 4A000000 		.4byte	.LFE75
 4160 0060 00000000 		.4byte	.LFB76
 4161 0064 20000000 		.4byte	.LFE76
 4162 0068 00000000 		.4byte	.LFB77
 4163 006c 2A000000 		.4byte	.LFE77
 4164 0070 00000000 		.4byte	.LFB78
 4165 0074 1A000000 		.4byte	.LFE78
 4166 0078 00000000 		.4byte	.LFB79
 4167 007c 20000000 		.4byte	.LFE79
 4168 0080 00000000 		.4byte	.LFB80
 4169 0084 D6000000 		.4byte	.LFE80
 4170 0088 00000000 		.4byte	.LFB81
 4171 008c 4C000000 		.4byte	.LFE81
 4172 0090 00000000 		.4byte	.LFB82
 4173 0094 98000000 		.4byte	.LFE82
 4174 0098 00000000 		.4byte	.LFB83
 4175 009c 2C000000 		.4byte	.LFE83
 4176 00a0 00000000 		.4byte	.LFB84
 4177 00a4 26000000 		.4byte	.LFE84
 4178 00a8 00000000 		.4byte	.LFB85
 4179 00ac 30000000 		.4byte	.LFE85
 4180 00b0 00000000 		.4byte	.LFB86
 4181 00b4 2A000000 		.4byte	.LFE86
 4182 00b8 00000000 		.4byte	.LFB87
 4183 00bc 50000000 		.4byte	.LFE87
 4184 00c0 00000000 		.4byte	.LFB88
 4185 00c4 44000000 		.4byte	.LFE88
 4186 00c8 00000000 		.4byte	0
 4187 00cc 00000000 		.4byte	0
 4188              		.section	.debug_line,"",%progbits
 4189              	.Ldebug_line0:
 4190 0000 79050000 		.section	.debug_str,"MS",%progbits,1
 4190      0200F901 
 4190      00000201 
 4190      FB0E0D00 
 4190      01010101 
 4191              	.LASF27:
 4192 0000 70784E65 		.ascii	"pxNext\000"
 4192      787400
 4193              	.LASF67:
 4194 0007 78517565 		.ascii	"xQueueGenericReset\000"
 4194      75654765 
 4194      6E657269 
 4194      63526573 
 4194      657400
 4195              	.LASF30:
 4196 001a 7076436F 		.ascii	"pvContainer\000"
 4196      6E746169 
 4196      6E657200 
 4197              	.LASF17:
 4198 0026 696E7438 		.ascii	"int8_t\000"
 4198      5F7400
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 117


 4199              	.LASF40:
 4200 002d 7854494D 		.ascii	"xTIME_OUT\000"
 4200      455F4F55 
 4200      5400
 4201              	.LASF43:
 4202 0037 54696D65 		.ascii	"TimeOut_t\000"
 4202      4F75745F 
 4202      7400
 4203              	.LASF3:
 4204 0041 73697A65 		.ascii	"size_t\000"
 4204      5F7400
 4205              	.LASF28:
 4206 0048 70785072 		.ascii	"pxPrevious\000"
 4206      6576696F 
 4206      757300
 4207              	.LASF61:
 4208 0053 70635175 		.ascii	"pcQueueName\000"
 4208      6575654E 
 4208      616D6500 
 4209              	.LASF107:
 4210 005f 70727643 		.ascii	"prvCopyDataToQueue\000"
 4210      6F707944 
 4210      61746154 
 4210      6F517565 
 4210      756500
 4211              	.LASF60:
 4212 0072 51554555 		.ascii	"QUEUE_REGISTRY_ITEM\000"
 4212      455F5245 
 4212      47495354 
 4212      52595F49 
 4212      54454D00 
 4213              	.LASF119:
 4214 0086 453A5C50 		.ascii	"E:\\PSoC_Creator\\CY8CKIT-059\\CY8CKIT-059_CW_Decod"
 4214      536F435F 
 4214      43726561 
 4214      746F725C 
 4214      43593843 
 4215 00b6 65725F55 		.ascii	"er_USB\\CY8CKIT-059_CW_Decoder_USB.cydsn\000"
 4215      53425C43 
 4215      5938434B 
 4215      49542D30 
 4215      35395F43 
 4216              	.LASF117:
 4217 00de 474E5520 		.ascii	"GNU C11 5.4.1 20160609 (release) [ARM/embedded-5-br"
 4217      43313120 
 4217      352E342E 
 4217      31203230 
 4217      31363036 
 4218 0111 616E6368 		.ascii	"anch revision 237715] -mcpu=cortex-m3 -mthumb -g -O"
 4218      20726576 
 4218      6973696F 
 4218      6E203233 
 4218      37373135 
 4219 0144 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 4219      66756E63 
 4219      74696F6E 
 4219      2D736563 
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 118


 4219      74696F6E 
 4220              	.LASF104:
 4221 016c 78506F73 		.ascii	"xPosition\000"
 4221      6974696F 
 4221      6E00
 4222              	.LASF12:
 4223 0176 5F5F7569 		.ascii	"__uint32_t\000"
 4223      6E743332 
 4223      5F7400
 4224              	.LASF100:
 4225 0181 75785175 		.ascii	"uxQueueMessagesWaiting\000"
 4225      6575654D 
 4225      65737361 
 4225      67657357 
 4225      61697469 
 4226              	.LASF8:
 4227 0198 73686F72 		.ascii	"short int\000"
 4227      7420696E 
 4227      7400
 4228              	.LASF29:
 4229 01a2 70764F77 		.ascii	"pvOwner\000"
 4229      6E657200 
 4230              	.LASF96:
 4231 01aa 784A7573 		.ascii	"xJustPeeking\000"
 4231      74506565 
 4231      6B696E67 
 4231      00
 4232              	.LASF102:
 4233 01b7 75785175 		.ascii	"uxQueueSpacesAvailable\000"
 4233      65756553 
 4233      70616365 
 4233      73417661 
 4233      696C6162 
 4234              	.LASF89:
 4235 01ce 7854696D 		.ascii	"xTimeOut\000"
 4235      654F7574 
 4235      00
 4236              	.LASF18:
 4237 01d7 75696E74 		.ascii	"uint8_t\000"
 4237      385F7400 
 4238              	.LASF98:
 4239 01df 78517565 		.ascii	"xQueueReceiveFromISR\000"
 4239      75655265 
 4239      63656976 
 4239      6546726F 
 4239      6D495352 
 4240              	.LASF97:
 4241 01f4 70634F72 		.ascii	"pcOriginalReadPosition\000"
 4241      6967696E 
 4241      616C5265 
 4241      6164506F 
 4241      73697469 
 4242              	.LASF110:
 4243 020b 70727649 		.ascii	"prvIsQueueFull\000"
 4243      73517565 
 4243      75654675 
 4243      6C6C00
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 119


 4244              	.LASF49:
 4245 021a 70635461 		.ascii	"pcTail\000"
 4245      696C00
 4246              	.LASF88:
 4247 0221 78596965 		.ascii	"xYieldRequired\000"
 4247      6C645265 
 4247      71756972 
 4247      656400
 4248              	.LASF78:
 4249 0230 70784D75 		.ascii	"pxMutex\000"
 4249      74657800 
 4250              	.LASF84:
 4251 0238 78517565 		.ascii	"xQueueGenericSend\000"
 4251      75654765 
 4251      6E657269 
 4251      6353656E 
 4251      6400
 4252              	.LASF105:
 4253 024a 70727643 		.ascii	"prvCopyDataFromQueue\000"
 4253      6F707944 
 4253      61746146 
 4253      726F6D51 
 4253      75657565 
 4254              	.LASF21:
 4255 025f 666C6F61 		.ascii	"float\000"
 4255      7400
 4256              	.LASF64:
 4257 0265 51756575 		.ascii	"QueueRegistryItem_t\000"
 4257      65526567 
 4257      69737472 
 4257      79497465 
 4257      6D5F7400 
 4258              	.LASF48:
 4259 0279 70634865 		.ascii	"pcHead\000"
 4259      616400
 4260              	.LASF39:
 4261 0280 4C697374 		.ascii	"List_t\000"
 4261      5F7400
 4262              	.LASF34:
 4263 0287 4D696E69 		.ascii	"MiniListItem_t\000"
 4263      4C697374 
 4263      4974656D 
 4263      5F7400
 4264              	.LASF1:
 4265 0296 6C6F6E67 		.ascii	"long long int\000"
 4265      206C6F6E 
 4265      6720696E 
 4265      7400
 4266              	.LASF25:
 4267 02a4 5469636B 		.ascii	"TickType_t\000"
 4267      54797065 
 4267      5F7400
 4268              	.LASF77:
 4269 02af 784D7574 		.ascii	"xMutex\000"
 4269      657800
 4270              	.LASF75:
 4271 02b6 78517565 		.ascii	"xQueueCreateMutex\000"
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 120


 4271      75654372 
 4271      65617465 
 4271      4D757465 
 4271      7800
 4272              	.LASF54:
 4273 02c8 75784C65 		.ascii	"uxLength\000"
 4273      6E677468 
 4273      00
 4274              	.LASF11:
 4275 02d1 6C6F6E67 		.ascii	"long int\000"
 4275      20696E74 
 4275      00
 4276              	.LASF35:
 4277 02da 784C4953 		.ascii	"xLIST\000"
 4277      5400
 4278              	.LASF109:
 4279 02e0 78517565 		.ascii	"xQueueIsQueueEmptyFromISR\000"
 4279      75654973 
 4279      51756575 
 4279      65456D70 
 4279      74794672 
 4280              	.LASF70:
 4281 02fa 75635175 		.ascii	"ucQueueType\000"
 4281      65756554 
 4281      79706500 
 4282              	.LASF6:
 4283 0306 5F5F7569 		.ascii	"__uint8_t\000"
 4283      6E74385F 
 4283      7400
 4284              	.LASF26:
 4285 0310 78497465 		.ascii	"xItemValue\000"
 4285      6D56616C 
 4285      756500
 4286              	.LASF103:
 4287 031b 75785175 		.ascii	"uxQueueMessagesWaitingFromISR\000"
 4287      6575654D 
 4287      65737361 
 4287      67657357 
 4287      61697469 
 4288              	.LASF58:
 4289 0339 78515545 		.ascii	"xQUEUE\000"
 4289      554500
 4290              	.LASF55:
 4291 0340 75784974 		.ascii	"uxItemSize\000"
 4291      656D5369 
 4291      7A6500
 4292              	.LASF99:
 4293 034b 78517565 		.ascii	"xQueuePeekFromISR\000"
 4293      75655065 
 4293      656B4672 
 4293      6F6D4953 
 4293      5200
 4294              	.LASF32:
 4295 035d 784C4953 		.ascii	"xLIST_ITEM\000"
 4295      545F4954 
 4295      454D00
 4296              	.LASF2:
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 121


 4297 0368 6C6F6E67 		.ascii	"long double\000"
 4297      20646F75 
 4297      626C6500 
 4298              	.LASF68:
 4299 0374 78517565 		.ascii	"xQueueGenericCreate\000"
 4299      75654765 
 4299      6E657269 
 4299      63437265 
 4299      61746500 
 4300              	.LASF72:
 4301 0388 70784E65 		.ascii	"pxNewQueue\000"
 4301      77517565 
 4301      756500
 4302              	.LASF116:
 4303 0393 78517565 		.ascii	"xQueueRegistry\000"
 4303      75655265 
 4303      67697374 
 4303      727900
 4304              	.LASF7:
 4305 03a2 756E7369 		.ascii	"unsigned char\000"
 4305      676E6564 
 4305      20636861 
 4305      7200
 4306              	.LASF42:
 4307 03b0 7854696D 		.ascii	"xTimeOnEntering\000"
 4307      654F6E45 
 4307      6E746572 
 4307      696E6700 
 4308              	.LASF41:
 4309 03c0 784F7665 		.ascii	"xOverflowCount\000"
 4309      72666C6F 
 4309      77436F75 
 4309      6E7400
 4310              	.LASF82:
 4311 03cf 75784D61 		.ascii	"uxMaxCount\000"
 4311      78436F75 
 4311      6E7400
 4312              	.LASF19:
 4313 03da 696E7433 		.ascii	"int32_t\000"
 4313      325F7400 
 4314              	.LASF14:
 4315 03e2 6C6F6E67 		.ascii	"long long unsigned int\000"
 4315      206C6F6E 
 4315      6720756E 
 4315      7369676E 
 4315      65642069 
 4316              	.LASF59:
 4317 03f9 51756575 		.ascii	"Queue_t\000"
 4317      655F7400 
 4318              	.LASF20:
 4319 0401 75696E74 		.ascii	"uint32_t\000"
 4319      33325F74 
 4319      00
 4320              	.LASF114:
 4321 040a 76517565 		.ascii	"vQueueUnregisterQueue\000"
 4321      7565556E 
 4321      72656769 
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 122


 4321      73746572 
 4321      51756575 
 4322              	.LASF0:
 4323 0420 756E7369 		.ascii	"unsigned int\000"
 4323      676E6564 
 4323      20696E74 
 4323      00
 4324              	.LASF31:
 4325 042d 4C697374 		.ascii	"ListItem_t\000"
 4325      4974656D 
 4325      5F7400
 4326              	.LASF23:
 4327 0438 42617365 		.ascii	"BaseType_t\000"
 4327      54797065 
 4327      5F7400
 4328              	.LASF85:
 4329 0443 70764974 		.ascii	"pvItemToQueue\000"
 4329      656D546F 
 4329      51756575 
 4329      6500
 4330              	.LASF63:
 4331 0451 78517565 		.ascii	"xQueueRegistryItem\000"
 4331      75655265 
 4331      67697374 
 4331      72794974 
 4331      656D00
 4332              	.LASF52:
 4333 0464 78546173 		.ascii	"xTasksWaitingToReceive\000"
 4333      6B735761 
 4333      6974696E 
 4333      67546F52 
 4333      65636569 
 4334              	.LASF73:
 4335 047b 78517565 		.ascii	"xQueueSizeInBytes\000"
 4335      75655369 
 4335      7A65496E 
 4335      42797465 
 4335      7300
 4336              	.LASF95:
 4337 048d 70764275 		.ascii	"pvBuffer\000"
 4337      66666572 
 4337      00
 4338              	.LASF47:
 4339 0496 51756575 		.ascii	"QueueDefinition\000"
 4339      65446566 
 4339      696E6974 
 4339      696F6E00 
 4340              	.LASF106:
 4341 04a6 70727655 		.ascii	"prvUnlockQueue\000"
 4341      6E6C6F63 
 4341      6B517565 
 4341      756500
 4342              	.LASF65:
 4343 04b5 78517565 		.ascii	"xQueue\000"
 4343      756500
 4344              	.LASF9:
 4345 04bc 73686F72 		.ascii	"short unsigned int\000"
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 123


 4345      7420756E 
 4345      7369676E 
 4345      65642069 
 4345      6E7400
 4346              	.LASF69:
 4347 04cf 75785175 		.ascii	"uxQueueLength\000"
 4347      6575654C 
 4347      656E6774 
 4347      6800
 4348              	.LASF4:
 4349 04dd 5F5F696E 		.ascii	"__int8_t\000"
 4349      74385F74 
 4349      00
 4350              	.LASF71:
 4351 04e6 70785175 		.ascii	"pxQueue\000"
 4351      65756500 
 4352              	.LASF90:
 4353 04ee 78517565 		.ascii	"xQueueGenericSendFromISR\000"
 4353      75654765 
 4353      6E657269 
 4353      6353656E 
 4353      6446726F 
 4354              	.LASF16:
 4355 0507 63686172 		.ascii	"char\000"
 4355      00
 4356              	.LASF50:
 4357 050c 70635772 		.ascii	"pcWriteTo\000"
 4357      69746554 
 4357      6F00
 4358              	.LASF93:
 4359 0516 78517565 		.ascii	"xQueueGiveFromISR\000"
 4359      75654769 
 4359      76654672 
 4359      6F6D4953 
 4359      5200
 4360              	.LASF111:
 4361 0528 78517565 		.ascii	"xQueueIsQueueFullFromISR\000"
 4361      75654973 
 4361      51756575 
 4361      6546756C 
 4361      6C46726F 
 4362              	.LASF45:
 4363 0541 70635265 		.ascii	"pcReadFrom\000"
 4363      61644672 
 4363      6F6D00
 4364              	.LASF57:
 4365 054c 7854784C 		.ascii	"xTxLock\000"
 4365      6F636B00 
 4366              	.LASF81:
 4367 0554 78517565 		.ascii	"xQueueCreateCountingSemaphore\000"
 4367      75654372 
 4367      65617465 
 4367      436F756E 
 4367      74696E67 
 4368              	.LASF94:
 4369 0572 78517565 		.ascii	"xQueueGenericReceive\000"
 4369      75654765 
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 124


 4369      6E657269 
 4369      63526563 
 4369      65697665 
 4370              	.LASF87:
 4371 0587 78456E74 		.ascii	"xEntryTimeSet\000"
 4371      72795469 
 4371      6D655365 
 4371      7400
 4372              	.LASF112:
 4373 0595 76517565 		.ascii	"vQueueDelete\000"
 4373      75654465 
 4373      6C657465 
 4373      00
 4374              	.LASF101:
 4375 05a2 75785265 		.ascii	"uxReturn\000"
 4375      7475726E 
 4375      00
 4376              	.LASF13:
 4377 05ab 6C6F6E67 		.ascii	"long unsigned int\000"
 4377      20756E73 
 4377      69676E65 
 4377      6420696E 
 4377      7400
 4378              	.LASF24:
 4379 05bd 55426173 		.ascii	"UBaseType_t\000"
 4379      65547970 
 4379      655F7400 
 4380              	.LASF86:
 4381 05c9 78436F70 		.ascii	"xCopyPosition\000"
 4381      79506F73 
 4381      6974696F 
 4381      6E00
 4382              	.LASF36:
 4383 05d7 75784E75 		.ascii	"uxNumberOfItems\000"
 4383      6D626572 
 4383      4F664974 
 4383      656D7300 
 4384              	.LASF108:
 4385 05e7 70727649 		.ascii	"prvIsQueueEmpty\000"
 4385      73517565 
 4385      7565456D 
 4385      70747900 
 4386              	.LASF62:
 4387 05f7 7848616E 		.ascii	"xHandle\000"
 4387      646C6500 
 4388              	.LASF83:
 4389 05ff 7578496E 		.ascii	"uxInitialCount\000"
 4389      69746961 
 4389      6C436F75 
 4389      6E7400
 4390              	.LASF53:
 4391 060e 75784D65 		.ascii	"uxMessagesWaiting\000"
 4391      73736167 
 4391      65735761 
 4391      6974696E 
 4391      6700
 4392              	.LASF10:
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 125


 4393 0620 5F5F696E 		.ascii	"__int32_t\000"
 4393      7433325F 
 4393      7400
 4394              	.LASF38:
 4395 062a 784C6973 		.ascii	"xListEnd\000"
 4395      74456E64 
 4395      00
 4396              	.LASF5:
 4397 0633 7369676E 		.ascii	"signed char\000"
 4397      65642063 
 4397      68617200 
 4398              	.LASF56:
 4399 063f 7852784C 		.ascii	"xRxLock\000"
 4399      6F636B00 
 4400              	.LASF92:
 4401 0647 75785361 		.ascii	"uxSavedInterruptStatus\000"
 4401      76656449 
 4401      6E746572 
 4401      72757074 
 4401      53746174 
 4402              	.LASF46:
 4403 065e 75785265 		.ascii	"uxRecursiveCallCount\000"
 4403      63757273 
 4403      69766543 
 4403      616C6C43 
 4403      6F756E74 
 4404              	.LASF74:
 4405 0673 78526574 		.ascii	"xReturn\000"
 4405      75726E00 
 4406              	.LASF15:
 4407 067b 73697A65 		.ascii	"sizetype\000"
 4407      74797065 
 4407      00
 4408              	.LASF66:
 4409 0684 784E6577 		.ascii	"xNewQueue\000"
 4409      51756575 
 4409      6500
 4410              	.LASF91:
 4411 068e 70784869 		.ascii	"pxHigherPriorityTaskWoken\000"
 4411      67686572 
 4411      5072696F 
 4411      72697479 
 4411      5461736B 
 4412              	.LASF44:
 4413 06a8 51756575 		.ascii	"QueueHandle_t\000"
 4413      6548616E 
 4413      646C655F 
 4413      7400
 4414              	.LASF113:
 4415 06b6 76517565 		.ascii	"vQueueAddToRegistry\000"
 4415      75654164 
 4415      64546F52 
 4415      65676973 
 4415      74727900 
 4416              	.LASF22:
 4417 06ca 646F7562 		.ascii	"double\000"
 4417      6C6500
ARM GAS  C:\Users\koseki\AppData\Local\Temp\ccDCxLOa.s 			page 126


 4418              	.LASF76:
 4419 06d1 78517565 		.ascii	"xQueueGiveMutexRecursive\000"
 4419      75654769 
 4419      76654D75 
 4419      74657852 
 4419      65637572 
 4420              	.LASF51:
 4421 06ea 78546173 		.ascii	"xTasksWaitingToSend\000"
 4421      6B735761 
 4421      6974696E 
 4421      67546F53 
 4421      656E6400 
 4422              	.LASF37:
 4423 06fe 7078496E 		.ascii	"pxIndex\000"
 4423      64657800 
 4424              	.LASF115:
 4425 0706 49544D5F 		.ascii	"ITM_RxBuffer\000"
 4425      52784275 
 4425      66666572 
 4425      00
 4426              	.LASF33:
 4427 0713 784D494E 		.ascii	"xMINI_LIST_ITEM\000"
 4427      495F4C49 
 4427      53545F49 
 4427      54454D00 
 4428              	.LASF79:
 4429 0723 78517565 		.ascii	"xQueueTakeMutexRecursive\000"
 4429      75655461 
 4429      6B654D75 
 4429      74657852 
 4429      65637572 
 4430              	.LASF118:
 4431 073c 46726565 		.ascii	"FreeRTOS\\queue.c\000"
 4431      52544F53 
 4431      5C717565 
 4431      75652E63 
 4431      00
 4432              	.LASF80:
 4433 074d 78546963 		.ascii	"xTicksToWait\000"
 4433      6B73546F 
 4433      57616974 
 4433      00
 4434              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 5.4.1 20160609 (release) [ARM/embedded-5-bran
